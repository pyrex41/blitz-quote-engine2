This file is a merged representation of a subset of the codebase, containing files not matching ignore patterns, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching these patterns are excluded: **/*.sql
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.github/
  workflows/
    buildandpush.yml
    test.yml
.zed/
  settings.json
cmd/
  serverd/
    main.go
  simplemaps/
    main.go
frontend/
  src/
    Html/
      Attributes/
        Extra.elm
      Events/
        Extra.elm
      Extra.elm
    Layouts/
      Default.elm
    Modal/
      ClientForm.elm
    Pages/
      Clients/
        Id_.elm
      Quotes/
        Id_/
          Edit.elm
        UrlId_/
          Review.elm
        Id_.elm
        New.elm
      Home_.elm
      NotFound_.elm
      Quotes.elm
      SignIn.elm
    PagesExt/
      Quotes/
        Id_/
          SendModal.elm
        New/
          ClientSearch.elm
          Form.elm
          SupplementalPlanSet.elm
    Shared/
      Model.elm
      Msg.elm
    UI/
      Icon/
        GoogleG.elm
      Alert.elm
      Button.elm
      Cents.elm
      ErrorPage.elm
      Icon.elm
      Quote.elm
      Select.elm
      Time.elm
    Auth.elm
    Effect.elm
    interop.js
    Server.elm
    Shared.elm
    styles.css
    Validate.elm
    View.elm
  static/
    medicare_school_com_logo.svg
  .gitignore
  elm-land.json
  elm.json
  package.json
  postcss.config.js
  README.md
  tailwind.config.js
internal/
  config/
    config.go
  domain/
    agent/
      agent.go
      store_test.go
      store.go
    client/
      client.go
      store_test.go
      store.go
    common/
      clock.go
      common_test.go
      common.go
    currency/
      currency.go
    dental/
      dental.go
      store_test.go
      store.go
    drug/
      drug.go
      store_test.go
      store.go
    geo/
      geo.go
      store_test.go
      store.go
      values_test.go
      values.go
    irmaa/
      irmaa_test.go
      irmaa.go
      store_test.go
      store.go
    quote/
      email_notifier_test.go
      email_notifier.go
      quote.go
      sms_notifier_test.go
      sms_notifier.go
      store_test.go
      store.go
      urlid_gen_test.go
      urlid_gen.go
    sup/
      store_test.go
      store.go
      sup.go
  handlers/
    frontend/
      testdata/
        css/
          main.css
        index.html
        root-main.css
      frontend_test.go
      frontend.go
    oauth/
      google/
        google.go
  maxquoteserver/
    dashboard.go
    mapping.go
    middleware.go
    public.go
  postgres/
    postgres.go
  session/
    session.go
  sqlc/
    agent.sql.go
    client.sql.go
    copyfrom.go
    county.sql.go
    db.go
    dental_quote.sql.go
    drug_quote.sql.go
    irmaa_bracket.sql.go
    models.go
    preferred_supplemental_carrier.sql.go
    querier.go
    quote_supplemental_carrier_plan_type.sql.go
    quote.sql.go
    supplemental_carrier_logo.sql.go
    zip_code_county.sql.go
    zip_code.sql.go
rpc/
  maxquote/
    service.gen.go
    service.ridl
.gitignore
Dockerfile
embed.go
go.mod
Makefile
README.md
sqlc.yaml

================================================================
Files
================================================================

================
File: .github/workflows/buildandpush.yml
================
name: Build and Push to ACR
on:
  push:
    tags:
      - "v*" # Push events to matching v*, i.e. v1.0, v20.15.10
jobs:
  build:
    name: "Build and Push to ACR"
    runs-on: ubuntu-latest

    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Docker Login
        uses: azure/docker-login@v1
        with:
          login-server: ${{ secrets.ACR_LOGIN_SERVER }}
          username: ${{ secrets.ACR_USERNAME }}
          password: ${{ secrets.ACR_PASSWORD }}

      - name: Build and Push to ACR
        uses: docker/build-push-action@v6
        with:
          push: true
          tags: medicareschoolcom.azurecr.io/maxquote:${{ github.ref_name }}
          file: Dockerfile

================
File: .github/workflows/test.yml
================
name: Go test
on: [push]

jobs:
  build:
    name: "Test"
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4
      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.23.x"

      - name: Install Go dependencies
        run: go get .

      - name: Test Go
        run: go test ./internal/... -v

================
File: .zed/settings.json
================
{
  "language_overrides": {
    "Elm": {
      "format_on_save": "on",
      "formatter": {
        "external": {
          "command": "frontend/node_modules/.bin/elm-format",
          "arguments": ["--stdin"]
        }
      }
    }
  }
}

================
File: cmd/serverd/main.go
================
package main

import (
	"context"
	"fmt"
	"io/fs"
	"log/slog"
	"net/http"
	"os"
	"syscall"
	"time"

	"github.com/alexedwards/scs/pgxstore"
	"github.com/alexedwards/scs/v2"
	"github.com/coreos/go-oidc/v3/oidc"
	"github.com/go-chi/chi/v5"
	"github.com/go-chi/httplog/v2"
	"github.com/medicareschoolcom/maxquote"
	"github.com/medicareschoolcom/maxquote/internal/config"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/client"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/dental"
	"github.com/medicareschoolcom/maxquote/internal/domain/drug"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
	"github.com/medicareschoolcom/maxquote/internal/domain/irmaa"
	"github.com/medicareschoolcom/maxquote/internal/domain/quote"
	"github.com/medicareschoolcom/maxquote/internal/domain/sup"
	"github.com/medicareschoolcom/maxquote/internal/handlers/frontend"
	"github.com/medicareschoolcom/maxquote/internal/handlers/oauth/google"
	mqserver "github.com/medicareschoolcom/maxquote/internal/maxquoteserver"
	"github.com/medicareschoolcom/maxquote/internal/postgres"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
	mq "github.com/medicareschoolcom/maxquote/rpc/maxquote"
	"github.com/oklog/run"
	"github.com/sendgrid/sendgrid-go"
)

const serviceName = "dashboard"

const (
	httpMaxIdleConns        = 100
	httpMaxConnsPerHost     = 100
	httpMaxIdleConnsPerHost = 100
	httpTimeoutSeconds      = 60
	httpShutdownPeriod      = 20 * time.Second
)

const (
	defaultHTTPIdleTimeout  = time.Minute
	defaultHTTPReadTimeout  = 10 * time.Second
	defaultHTTPWriteTimeout = 30 * time.Second
)

func main() {
	ctx := context.Background()

	// Create a new structured logger
	logger := httplog.NewLogger(serviceName, httplog.Options{JSON: true})

	// Assign the structured logger to the default log.Logger
	slog.SetDefault(logger.Logger)

	if err := exec(ctx, logger); err != nil {
		logger.ErrorContext(ctx, "failed exec", slog.Any("error", err))
		os.Exit(1)
	}
}

func exec(ctx context.Context, logger *httplog.Logger) error {
	// Parse configuration data
	cfg, err := config.Parse(serviceName)
	if err != nil {
		return fmt.Errorf("failed to parse config: %w", err)
	}

	// Establish database connection
	db, err := postgres.NewPool(ctx, cfg.Database)
	if err != nil {
		return fmt.Errorf("failed to open database connection pool: %w", err)
	}
	defer db.Close()

	// Create http client
	httpClientTransport := http.DefaultTransport.(*http.Transport).Clone()
	httpClientTransport.MaxIdleConns = httpMaxIdleConns
	httpClientTransport.MaxConnsPerHost = httpMaxConnsPerHost
	httpClientTransport.MaxIdleConnsPerHost = httpMaxIdleConnsPerHost
	httpClient := &http.Client{
		Timeout:   httpTimeoutSeconds * time.Second,
		Transport: httpClientTransport,
	}

	// Create domain services
	clock := common.SystemClock{}
	querier := sqlc.New()
	agentStore := agent.NewPGStore(querier)
	clientStore := client.NewPGStore(querier)
	countyStore := geo.NewPGCountyStore(querier)
	zipCodeCountyStore := geo.NewPGZipCodeCountyStore(querier)
	irmaaBracketStore := irmaa.NewPGBracketStore(querier)
	drugQuoteStore := drug.NewPGQuoteStore(querier)
	dentalQuoteStore := dental.NewPGQuoteStore(querier)
	quoteStore := quote.NewPGStore(querier)
	quoteURLIDGen := quote.NewNanoQuoteURLIDGenerator(32)
	quoteEmailNotifier := quote.NewSendGridEmailNotifier(cfg.Sendgrid.FromName, cfg.Sendgrid.FromEmailAddress, cfg.BaseURL, sendgrid.NewSendClient(cfg.Sendgrid.APIKey))
	quoteSMSNotifier := quote.NewTwilioSMSNotifier(quote.NewTwilioApiService(cfg.Twilio.Username, cfg.Twilio.Password), cfg.Twilio.FromPhoneNumber, cfg.BaseURL)
	supQuoteStore := sup.NewPGQuoteStore(sup.NewCSGQuoteStore(cfg.CSGCache.APIKey, cfg.CSGCache.BaseURL, httpClient), db)

	// Create session manager
	sessionManager := scs.New()
	sessionManager.Store = pgxstore.NewWithCleanupInterval(db, 30*time.Minute)
	sessionManager.Cookie.Name = cfg.Cookie.Name
	sessionManager.Cookie.Domain = cfg.Cookie.Domain
	sessionManager.Cookie.HttpOnly = cfg.Cookie.HTTPOnly
	sessionManager.Cookie.Path = cfg.Cookie.Path
	sessionManager.Cookie.SameSite = http.SameSite(cfg.Cookie.SameSite)
	sessionManager.Cookie.Secure = cfg.Cookie.Secure

	// Create google OIDC provider
	googleOIDCProvider, err := oidc.NewProvider(ctx, "https://accounts.google.com")
	if err != nil {
		return fmt.Errorf("failed to create new google oidc provider: %w", err)
	}

	// Get embedded file system
	frontendFS, err := fs.Sub(maxquote.EmbeddedFS, "frontend/dist")
	if err != nil {
		return fmt.Errorf("failed to get subdirectory of embeded frontend filesystem: %w", err)
	}

	// Routing
	r := chi.NewRouter()
	r.Use(httplog.RequestLogger(logger))
	r.Use(sessionManager.LoadAndSave)
	if !cfg.Development {
		r.Method(http.MethodGet, "/*", frontend.Serve(frontendFS))
	}
	r.Method(http.MethodGet, "/oauth/google/login", google.Login(cfg, googleOIDCProvider, sessionManager, logger))
	r.Method(http.MethodGet, "/oauth/google/callback", google.Callback(cfg, googleOIDCProvider, sessionManager, db, agentStore, logger))
	r.With(mqserver.RequireAgent(*sessionManager, agentStore, logger, db)).
		Mount("/rpc/Dashboard", mq.NewDashboardServer(mqserver.NewDashboardServer(db, logger, sessionManager, agentStore, countyStore, zipCodeCountyStore, clientStore, irmaaBracketStore, drugQuoteStore, supQuoteStore, dentalQuoteStore, quoteStore, quoteURLIDGen, quoteEmailNotifier, quoteSMSNotifier, clock, cfg)))
	r.Mount("/rpc/Public", mq.NewPublicServer(mqserver.NewPublicServer(db, logger, agentStore, clientStore, countyStore, irmaaBracketStore, drugQuoteStore, supQuoteStore, dentalQuoteStore, quoteStore, clock, cfg)))
	r.Get("/healthz", handleHealthz)

	httpServer := &http.Server{
		Addr:         fmt.Sprintf(":%d", cfg.Port),
		Handler:      r,
		IdleTimeout:  defaultHTTPIdleTimeout,
		ReadTimeout:  defaultHTTPReadTimeout,
		WriteTimeout: defaultHTTPWriteTimeout,
	}

	var g run.Group

	// Add web server to run group
	g.Add(func() error {
		logger.With(slog.Int("port", cfg.Port)).Info("starting http server")
		return httpServer.ListenAndServe()
	}, func(error) {
		ctx, cancel := context.WithTimeout(context.Background(), httpShutdownPeriod)
		defer cancel()
		logger.With(slog.Int("port", cfg.Port)).Info("stopping http server")
		httpServer.Shutdown(ctx)
	})

	// Initiate shutdown of all services on sig term
	g.Add(run.SignalHandler(ctx, os.Interrupt, syscall.SIGTERM))

	// Start all services
	return g.Run()
}

func handleHealthz(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusOK)
}

================
File: cmd/simplemaps/main.go
================
package main

import (
	"context"
	"flag"
	"log"
	"os"
	"strings"

	"github.com/gocarina/gocsv"
	"github.com/medicareschoolcom/maxquote/internal/postgres"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
)

type ZipCode struct { // Our example struct, you can use "-" to ignore a field
	Zip            string `csv:"zip"`
	CountyNamesAll string `csv:"county_names_all"`
	CountyFipsAll  string `csv:"county_fips_all"`
	StateID        string `csv:"state_id"`
}

type County struct { // Our example struct, you can use "-" to ignore a field
	County     string `csv:"county"`
	CountyFips string `csv:"county_fips"`
	StateID    string `csv:"state_id"`
	Zips       string `csv:"zips"`
}

func main() {

	// Parse incoming flags
	var (
		zipsCSVPath        string
		countiesCSVPath    string
		dbConnectionString string
	)

	flag.StringVar(&zipsCSVPath, "zip-csv-path", "", "The path to the zips file.")
	flag.StringVar(&countiesCSVPath, "counties-csv-path", "", "The path to the counties file.")
	flag.StringVar(&dbConnectionString, "db-connection-string", "", "The database connection string.")
	flag.Parse()

	if zipsCSVPath == "" {
		log.Fatal("flag required: zip-csv-path")
	}

	if countiesCSVPath == "" {
		log.Fatal("flag required: counties-csv-path")
	}

	if dbConnectionString == "" {
		log.Fatal("flag required: db-connection-string")
	}

	// Create context
	ctx := context.Background()

	// Establish database connection
	db, err := postgres.NewPool(ctx, dbConnectionString)
	if err != nil {
		log.Fatalf("failed to open database connection pool: %s", err)
	}
	defer db.Close()

	zipsBytes, err := os.ReadFile(zipsCSVPath)
	if err != nil {
		log.Fatalf("failed ReadFile: %s", err)
	}

	zipCodes := []*ZipCode{}
	if err := gocsv.UnmarshalBytes(zipsBytes, &zipCodes); err != nil {
		log.Fatalf("failed UnmarshalBytes with zip: %s", err)
	}

	countiesBytes, err := os.ReadFile(countiesCSVPath)
	if err != nil {
		log.Fatalf("failed ReadFile: %s", err)
	}

	counties := []*County{}
	if err := gocsv.UnmarshalBytes(countiesBytes, &counties); err != nil {
		log.Fatalf("failed UnmarshalBytes with counties: %s", err)
	}

	tx, err := db.Begin(ctx)
	if err != nil {
		log.Fatalf("failed to begin transaction: %s", err)
	}
	defer tx.Rollback(ctx)

	for _, zipCode := range zipCodes {

		// Upsert zip code
		if err := sqlc.New().UpsertZipCode(ctx, tx, zipCode.Zip); err != nil {
			log.Fatalf("failed to upsert zipCode '%s': %s", zipCode.Zip, err)
		}

		// Upsert counties from zipcode
		countyFipsCodes := strings.Split(zipCode.CountyFipsAll, "|")
		countyNames := strings.Split(zipCode.CountyNamesAll, "|")
		for i, _ := range countyFipsCodes {
			countyFipsCode := countyFipsCodes[i]
			countyName := countyNames[i]
			err := sqlc.New().UpsertCounty(ctx, tx, sqlc.UpsertCountyParams{
				FipsCode:       countyFipsCode,
				Name:           countyName,
				StateAlphaCode: zipCode.StateID,
			})
			if err != nil {
				log.Fatalf("failed to upsert county '%s': %s", countyFipsCode, err)
			}
			log.Printf("county fips '%s' upserted", countyFipsCode)
		}

		log.Printf("zip '%s' upserted", zipCode.Zip)
	}

	// Upsert counties from counties csv
	for _, county := range counties {
		err := sqlc.New().UpsertCounty(ctx, tx, sqlc.UpsertCountyParams{
			FipsCode:       county.CountyFips,
			Name:           county.County,
			StateAlphaCode: county.StateID,
		})
		if err != nil {
			log.Fatalf("failed to upsert county '%s': %s", county.CountyFips, err)
		}
		log.Printf("county fips '%s' upserted", county.CountyFips)
	}

	for _, zipCode := range zipCodes {
		countyFipsCodes := strings.Split(zipCode.CountyFipsAll, "|")
		for _, countyFipsCode := range countyFipsCodes {
			err := sqlc.New().UpsertZipCodeCounty(ctx, tx, sqlc.UpsertZipCodeCountyParams{
				ZipCode:        zipCode.Zip,
				CountyFipsCode: countyFipsCode,
			})
			if err != nil {
				log.Fatalf("failed to upsert zipCodeCounty '%s/%s': %s", zipCode.Zip, countyFipsCode, err)
			}
			log.Printf("zipCodeCounty '%s/%s' upserted", zipCode.Zip, countyFipsCode)
		}
	}

	if err := tx.Commit(ctx); err != nil {
		log.Fatalf("failed to commit transaction: %s", err)
	}

	log.Print("Simplemaps zips and counties parsed successfully.")
}

================
File: frontend/src/Html/Attributes/Extra.elm
================
module Html.Attributes.Extra exposing (..)

import Html
import Html.Attributes


label : String -> Html.Attribute msg
label =
    Html.Attributes.attribute "label"

================
File: frontend/src/Html/Events/Extra.elm
================
module Html.Events.Extra exposing (alwaysStopPropagationOn)

import Html
import Html.Events
import Json.Decode


alwaysStopPropagationOn : String -> msg -> Html.Attribute msg
alwaysStopPropagationOn event msg =
    Html.Events.stopPropagationOn event (Json.Decode.succeed ( msg, True ))

================
File: frontend/src/Html/Extra.elm
================
module Html.Extra exposing (..)

import Html exposing (..)


dialog : List (Attribute msg) -> List (Html msg) -> Html msg
dialog =
    node "dialog"

================
File: frontend/src/Layouts/Default.elm
================
module Layouts.Default exposing (Model, Msg, Props, layout)

import Browser.Events
import Debounce exposing (Debounce)
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Html.Events.Extra exposing (..)
import Json.Decode
import Layout exposing (Layout)
import RemoteData exposing (RemoteData)
import Route exposing (Route)
import Route.Path
import Server
import Shared
import UI.Button
import UI.Icon
import View exposing (View)


type alias Props =
    { agent : Server.Agent
    }


layout : Props -> Shared.Model -> Route () -> Layout () Model Msg contentMsg
layout props shared route =
    Layout.new
        { init = init
        , update = update
        , view = view props route
        , subscriptions = subscriptions
        }



-- MODEL


type alias Model =
    { searchTerm : String
    , searchResults : RemoteData Server.Error (List Server.SearchResult)
    , showSearchResults : Bool
    , debounce : Debounce String
    , isUserMenuOpen : Bool
    }


init : () -> ( Model, Effect Msg )
init _ =
    ( { searchTerm = ""
      , searchResults = RemoteData.NotAsked
      , showSearchResults = False
      , debounce = Debounce.init
      , isUserMenuOpen = False
      }
    , Effect.none
    )



-- UPDATE


type Msg
    = ChangedSearch String
    | ClickedDocument
    | ClickedNewQuote
    | ClickedSearchResult
    | ClickedSignOut
    | ClickedUserMenu
    | CompletedSearch (Result Server.Error (List Server.SearchResult))
    | DebounceMsg Debounce.Msg
    | FocussedSearch
    | NoOp


searchCharsLimit : Int
searchCharsLimit =
    2


update : Msg -> Model -> ( Model, Effect Msg )
update msg model =
    case msg of
        ChangedSearch searchTerm ->
            let
                trimmedSearchTerm =
                    String.trim searchTerm
            in
            if String.length trimmedSearchTerm >= searchCharsLimit then
                let
                    ( debounce, debouceCmd ) =
                        Debounce.push debounceConfig searchTerm model.debounce
                in
                ( { model
                    | searchTerm = searchTerm
                    , debounce = debounce
                    , searchResults = RemoteData.Loading
                  }
                , Effect.sendCmd debouceCmd
                )

            else
                ( { model
                    | searchTerm = searchTerm
                    , searchResults = RemoteData.NotAsked
                  }
                , Effect.none
                )

        ClickedDocument ->
            ( { model
                | showSearchResults = False
                , isUserMenuOpen = False
              }
            , Effect.none
            )

        ClickedNewQuote ->
            ( model
            , Effect.pushRoutePath Route.Path.Quotes_New
            )

        ClickedSearchResult ->
            ( { model | searchTerm = "", searchResults = RemoteData.NotAsked }
            , Effect.none
            )

        ClickedSignOut ->
            ( model
            , Effect.signOut
            )

        ClickedUserMenu ->
            ( { model | isUserMenuOpen = not model.isUserMenuOpen }
            , Effect.none
            )

        CompletedSearch result ->
            ( { model | searchResults = RemoteData.fromResult result }
            , Effect.none
            )

        DebounceMsg debouncedMsg ->
            let
                searchCmd searchTerm =
                    Server.dashboard.search searchTerm |> Server.send CompletedSearch

                ( debounce, cmd ) =
                    Debounce.update debounceConfig (Debounce.takeLast searchCmd) debouncedMsg model.debounce
            in
            ( { model | debounce = debounce }
            , Effect.sendCmd cmd
            )

        FocussedSearch ->
            ( { model | showSearchResults = True }
            , Effect.none
            )

        NoOp ->
            ( model, Effect.none )


subscriptions : Model -> Sub Msg
subscriptions model =
    Browser.Events.onClick (Json.Decode.succeed ClickedDocument)


debounceConfig : Debounce.Config Msg
debounceConfig =
    { strategy = Debounce.later 300
    , transform = DebounceMsg
    }



-- VIEW


view : Props -> Route () -> { toContentMsg : Msg -> contentMsg, content : View contentMsg, model : Model } -> View contentMsg
view props route { toContentMsg, model, content } =
    let
        agentName =
            props.agent.firstName ++ " " ++ props.agent.lastName
    in
    { title = content.title
    , body =
        [ -- SIDEBAR
          div [ class "fixed w-[var(--sidebar-width)] top-0 left-0 bottom-0 border-r border-gray-200 px-8 py-4 space-y-8 bg-white" ]
            [ div [] [ img [ src "/medicare_school_com_logo.svg" ] [] ]
            , viewNav props route
            ]

        -- HEADER
        , div [ class "fixed left-[var(--sidebar-width)] top-0 right-0 h-[var(--header-height)] bg-white" ]
            [ div [ class "mx-auto max-w-[var(--content-max-width)] px-8 h-full" ]
                [ div [ class "w-full h-full flex items-center" ]
                    [ -- SEARCH
                      viewSearch model |> Html.map toContentMsg

                    -- ACTION MENU
                    , div [ class "ml-auto flex items-center space-x-4" ]
                        [ -- NEW QUOTE BUTTON
                          UI.Button.new "New quote"
                            |> UI.Button.withIcon UI.Icon.Plus
                            |> UI.Button.withType (UI.Button.Link (Route.Path.toString Route.Path.Quotes_New))
                            |> UI.Button.withStyle UI.Button.Secondary
                            |> UI.Button.view
                            |> Html.map toContentMsg

                        -- USER MENU
                        , div [ class "relative", alwaysStopPropagationOn "click" (toContentMsg NoOp) ]
                            [ button [ class "flex items-center justify-center rounded-full bg-[#F2F2F2] text-gray-500 w-[2.375rem] h-[2.375rem]", onClick (toContentMsg ClickedUserMenu) ]
                                [ UI.Icon.new UI.Icon.User1
                                    |> UI.Icon.withSize 20
                                    |> UI.Icon.view
                                ]
                            , if model.isUserMenuOpen then
                                div [ class "absolute top-full right-0 mt-3 bg-white rounded-lg border border-gray-300 px-4 shadow-md divide-y divide-gray-300" ]
                                    [ div [ class "py-3" ]
                                        [ div [ class "font-medium text-gray-950" ] [ text agentName ]
                                        , div [ class "text-gray-500" ] [ text props.agent.email ]
                                        ]
                                    , div [ class "py-3" ]
                                        [ button [ class "text-[var(--brand-color)] flex items-center space-x-1", type_ "button", onClick (toContentMsg ClickedSignOut) ]
                                            [ UI.Icon.new UI.Icon.LogOut1
                                                |> UI.Icon.withSize 16
                                                |> UI.Icon.view
                                            , span [] [ text "Sign out" ]
                                            ]
                                        ]
                                    ]

                              else
                                viewNothing
                            ]
                        ]
                    ]
                ]
            ]

        -- CONTENT
        , div [ class "ml-[var(--sidebar-width)] mt-[var(--header-height)] pt" ]
            [ div [ class "mx-auto max-w-[var(--content-max-width)] px-8 py-8" ] content.body
            ]
        ]
    }


viewNav : Props -> Route () -> Html msg
viewNav props route =
    let
        viewItem prefix path icon label =
            let
                isSelected =
                    String.startsWith prefix (Route.Path.toString route.path)
            in
            a
                [ Route.Path.href path
                , classList
                    [ ( "flex items-center space-x-2", True )
                    , ( "text-[var(--brand-color)]", isSelected )
                    , ( "text-gray-700", not isSelected )
                    ]
                ]
                [ UI.Icon.new icon
                    |> UI.Icon.withSize 18
                    |> UI.Icon.view
                , span [] [ text label ]
                ]
    in
    div []
        [ viewItem "/quotes" Route.Path.Quotes UI.Icon.File6 "Quotes"
        ]


viewSearch : Model -> Html Msg
viewSearch model =
    let
        isValidSearchTerm =
            String.length model.searchTerm >= searchCharsLimit

        searchingText =
            div [ class "text-gray-950 leading-7 px-2" ]
                [ span [] [ text "Searching for " ]
                , span [ class "font-semibold" ] [ text model.searchTerm ]
                ]

        searchIcon =
            case model.searchResults of
                RemoteData.Loading ->
                    UI.Icon.new UI.Icon.Loading4Animated
                        |> UI.Icon.withSize 16
                        |> UI.Icon.view

                _ ->
                    UI.Icon.new UI.Icon.SearchMd
                        |> UI.Icon.withStrokeWidth 2
                        |> UI.Icon.view

        isClientSearchResult searchResult =
            searchResult.type_ == Server.SearchResultTypeClient

        isQuoteSearchResult searchResult =
            searchResult.type_ == Server.SearchResultTypeQuote

        clientSearchResults searchResults_ =
            List.filter isClientSearchResult searchResults_

        quoteSearchResults searchResults_ =
            List.filter isQuoteSearchResult searchResults_

        hasQuoteSearchResults searchResults_ =
            not (List.isEmpty (quoteSearchResults searchResults_))

        viewClientSearchResults searchResults_ =
            case clientSearchResults searchResults_ of
                [] ->
                    viewNothing

                clientSearchResults_ ->
                    div []
                        [ div [ class "text-gray-500 text-xs font-semibold leading-7 px-2" ] [ text "Clients" ]
                        , div [] (List.map viewClientSearchResult clientSearchResults_)
                        ]

        viewClientSearchResult searchResult =
            a
                [ class "inline-flex items-center leading-7 w-full px-2 hover:bg-gray-100 rounded-lg cursor-pointer whitespace-nowrap text-ellipsis overflow-hidden space-x-2 text-gray-500"
                , Route.Path.href (Route.Path.Clients_Id_ { id = String.fromInt searchResult.id })
                , onClick ClickedSearchResult
                ]
                [ UI.Icon.new UI.Icon.User1
                    |> UI.Icon.withSize 14
                    |> UI.Icon.view
                , span [ class "text-gray-950" ] [ text searchResult.primaryDescription ]
                , span [] [ text searchResult.secondaryDescription ]
                ]

        viewQuoteSearchResults searchResults_ =
            case quoteSearchResults searchResults_ of
                [] ->
                    viewNothing

                quoteSearchResults_ ->
                    div []
                        [ div [ class "text-gray-500 text-xs font-semibold leading-7 px-2" ] [ text "Quotes" ]
                        , div [] (List.map viewQuoteSearchResult quoteSearchResults_)
                        ]

        viewQuoteSearchResult searchResult =
            a
                [ class "inline-flex items-center leading-7 w-full px-2 hover:bg-gray-100 rounded-lg cursor-pointer whitespace-nowrap text-ellipsis overflow-hidden space-x-2 text-gray-500"
                , Route.Path.href (Route.Path.Quotes_Id_ { id = String.fromInt searchResult.id })
                , onClick ClickedSearchResult
                ]
                [ UI.Icon.new UI.Icon.File6
                    |> UI.Icon.withSize 14
                    |> UI.Icon.view
                , span [ class "text-gray-950" ] [ text searchResult.primaryDescription ]
                , span [] [ text searchResult.secondaryDescription ]
                ]
    in
    div [ class "relative" ]
        [ div [ class "relative w-[500px]", alwaysStopPropagationOn "click" NoOp ]
            [ input
                [ class "w-full pl-8 bg-[#F2F2F2] border-0 placeholder:text-gray-500 placeholder:font-medium !rounded-lg"
                , type_ "text"
                , value model.searchTerm
                , placeholder "Search"
                , onInput ChangedSearch
                , onFocus FocussedSearch
                ]
                []
            , div [ class "absolute h-full flex items-center justify-center left-0 top-0 w-[36px]  pointer-events-none text-gray-500" ]
                [ searchIcon
                ]
            ]

        -- RESULTS
        , if model.showSearchResults then
            div [ class "absolute w-full top-full left-0 p-2 border border-gray-300 bg-white shadow-md rounded-lg mt-2 space-y-[14px]" ]
                (case ( isValidSearchTerm, model.searchResults ) of
                    ( False, _ ) ->
                        [ div [ class "text-gray-500 leading-7 px-2 italic" ] [ text "Enter a search term" ]
                        ]

                    ( True, RemoteData.NotAsked ) ->
                        [ searchingText ]

                    ( True, RemoteData.Loading ) ->
                        [ searchingText ]

                    ( True, RemoteData.Success [] ) ->
                        [ div [ class "text-gray-950 leading-7 px-2" ] [ text "No results found" ]
                        ]

                    ( True, RemoteData.Success searchResults_ ) ->
                        [ searchingText
                        , viewClientSearchResults searchResults_
                        , viewQuoteSearchResults searchResults_
                        ]

                    ( True, RemoteData.Failure _ ) ->
                        [ div [ class "text-gray-950 leading-7 px-2" ] [ text "Unable to load search results" ]
                        ]
                )

          else
            viewNothing
        ]


viewNothing : Html msg
viewNothing =
    text ""

================
File: frontend/src/Modal/ClientForm.elm
================
module Modal.ClientForm exposing (Model, Msg, Values, new, subscriptions, update, view)

import Browser.Dom
import Browser.Events
import Date
import Dict.Any as AnyDict exposing (AnyDict)
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Html.Extra exposing (..)
import RemoteData
import Server
import Set.Any as AnySet exposing (AnySet)
import Shared
import Task
import Time
import UI.Button
import UI.Icon
import UI.Select
import Validate


type Model
    = Model
        { modalId : String
        , firstName : String
        , lastName : String
        , dateOfBirthMonth : Maybe Time.Month
        , dateOfBirthDay : Maybe Int
        , dateOfBirthYear : Maybe Int
        , gender : Maybe Server.Gender
        , zipCode : String
        , countyFipsCode : String
        , email : String
        , isEmailTaken : Bool
        , phone : String
        , isTobaccoUser : Bool
        , counties : RemoteData.RemoteData Server.Error (List Server.County)
        , modalStatus : ModalStatus
        , fieldsValidating : AnySet Int Field
        , isSubmitting : Bool
        }


type ModalStatus
    = Closed
    | Opening
    | Open


new :
    Shared.Model
    -> String
    ->
        { firstName : Maybe String
        , lastName : Maybe String
        , dateOfBirth : Maybe String
        , gender : Maybe Server.Gender
        , zipCode : Maybe String
        , countyFipsCode : Maybe String
        , email : Maybe String
        , phone : Maybe String
        , isTobaccoUser : Maybe Bool
        }
    -> ( Model, Effect Msg )
new shared modalId params =
    let
        firstName =
            params.firstName
                |> Maybe.withDefault ""

        lastName =
            params.lastName
                |> Maybe.withDefault ""

        dateOfBirth =
            params.dateOfBirth
                |> Maybe.andThen (Date.fromIsoString >> Result.toMaybe)

        dateOfBirthMonth =
            dateOfBirth
                |> Maybe.map Date.month

        dateOfBirthDay =
            dateOfBirth
                |> Maybe.map Date.day

        year65YearsAgo =
            Time.toYear shared.zone shared.time - 65

        dateOfBirthYear =
            case Maybe.map Date.year dateOfBirth of
                Just year ->
                    Just year

                Nothing ->
                    Just year65YearsAgo

        gender =
            params.gender

        zipCode =
            params.zipCode
                |> Maybe.withDefault ""

        countyFipsCode =
            params.countyFipsCode
                |> Maybe.withDefault ""

        email =
            params.email
                |> Maybe.withDefault ""

        phone =
            params.phone
                |> Maybe.withDefault ""

        isTobaccoUser =
            params.isTobaccoUser
                |> Maybe.withDefault False

        listCountiesByZipCodeEffect =
            case params.zipCode of
                Just zipCode_ ->
                    if Validate.isZipCode zipCode_ then
                        Server.dashboard.listCountiesByZipCode zipCode_
                            |> Server.send (CompletedListCountiesByZipCode zipCode_)
                            |> Effect.sendCmd

                    else
                        Effect.none

                Nothing ->
                    Effect.none
    in
    ( Model
        { modalId = modalId
        , firstName = firstName
        , lastName = lastName
        , dateOfBirthMonth = dateOfBirthMonth
        , dateOfBirthDay = dateOfBirthDay
        , dateOfBirthYear = dateOfBirthYear
        , gender = gender
        , zipCode = zipCode
        , countyFipsCode = countyFipsCode
        , email = email
        , isEmailTaken = False
        , phone = phone
        , isTobaccoUser = isTobaccoUser
        , counties = RemoteData.NotAsked
        , modalStatus = Opening
        , fieldsValidating = AnySet.empty fieldToInt
        , isSubmitting = False
        }
    , listCountiesByZipCodeEffect
    )


type Msg
    = BlurredEmail
    | BlurredField Field
    | ChangedCountyFipsCode String
    | ChangedDateOfBirthMonth (Maybe Time.Month)
    | ChangedDateOfBirthDay (Maybe Int)
    | ChangedDateOfBirthYear (Maybe Int)
    | ChangedEmail String
    | ChangedFirstName String
    | ChangedGender (Maybe Server.Gender)
    | ChangedLastName String
    | ChangedPhone String
    | ChangedZipCode String
    | ClickedCancel
    | ClickedIsTobaccoUser
    | CompletedStoreClient (Result Server.Error Server.Client)
    | CompletedListCountiesByZipCode String (Result Server.Error (List Server.County))
    | CompletedIsClientEmailTaken (Result Server.Error Bool)
    | GotModalElement (Result Browser.Dom.Error Browser.Dom.Element)
    | SubmittedForm
    | Tick


type alias Values =
    { firstName : String
    , lastName : String
    , dateOfBirth : String
    , gender : Server.Gender
    , zipCode : String
    , countyFipsCode : String
    , email : Maybe String
    , phone : Maybe String
    , isTobaccoUser : Bool
    }


type alias StoreClientFn =
    Values -> (Result Server.Error Server.Client -> Msg) -> Cmd Msg


type alias IsClientEmailTakenFn =
    String -> (Result Server.Error Bool -> Msg) -> Cmd Msg


update : StoreClientFn -> IsClientEmailTakenFn -> Msg -> Model -> ( Model, Effect Msg, Maybe Server.Client )
update storeClientFn isClientEmailTakenFn msg (Model model) =
    case msg of
        BlurredEmail ->
            let
                effect =
                    if Validate.isEmail model.email then
                        isClientEmailTakenFn model.email CompletedIsClientEmailTaken
                            |> Effect.sendCmd

                    else
                        Effect.none
            in
            ( Model { model | fieldsValidating = AnySet.insert Email model.fieldsValidating }
            , effect
            , Nothing
            )

        BlurredField field ->
            ( Model { model | fieldsValidating = AnySet.insert field model.fieldsValidating }
            , Effect.none
            , Nothing
            )

        ChangedCountyFipsCode countyFipsCode ->
            ( Model
                { model
                    | countyFipsCode = countyFipsCode
                    , fieldsValidating = AnySet.insert CountyFipsCode model.fieldsValidating
                }
            , Effect.none
            , Nothing
            )

        ChangedDateOfBirthMonth month ->
            ( Model
                { model
                    | dateOfBirthMonth = month
                    , fieldsValidating = AnySet.insert DateOfBirthMonth model.fieldsValidating
                }
            , Effect.none
            , Nothing
            )

        ChangedDateOfBirthDay day ->
            ( Model
                { model
                    | dateOfBirthDay = day
                    , fieldsValidating = AnySet.insert DateOfBirthDay model.fieldsValidating
                }
            , Effect.none
            , Nothing
            )

        ChangedDateOfBirthYear year ->
            ( Model
                { model
                    | dateOfBirthYear = year
                    , fieldsValidating = AnySet.insert DateOfBirthYear model.fieldsValidating
                }
            , Effect.none
            , Nothing
            )

        ChangedEmail email ->
            ( Model
                { model
                    | email = email
                    , isEmailTaken = False
                }
            , Effect.none
            , Nothing
            )

        ChangedFirstName firstName ->
            ( Model { model | firstName = firstName }
            , Effect.none
            , Nothing
            )

        ChangedGender gender ->
            ( Model
                { model
                    | gender = gender
                    , fieldsValidating = AnySet.insert Gender model.fieldsValidating
                }
            , Effect.none
            , Nothing
            )

        ChangedLastName lastName ->
            ( Model
                { model | lastName = lastName }
            , Effect.none
            , Nothing
            )

        ChangedPhone phone ->
            ( Model
                { model | phone = phone }
            , Effect.none
            , Nothing
            )

        ChangedZipCode zipCode ->
            let
                ( counties, listCountiesByZipCode ) =
                    if Validate.isZipCode zipCode then
                        ( RemoteData.Loading
                        , Server.dashboard.listCountiesByZipCode zipCode
                            |> Server.send (CompletedListCountiesByZipCode zipCode)
                            |> Effect.sendCmd
                        )

                    else
                        ( RemoteData.NotAsked
                        , Effect.none
                        )
            in
            ( Model
                { model
                    | zipCode = zipCode
                    , countyFipsCode = ""
                    , counties = counties
                    , fieldsValidating = AnySet.insert ZipCode model.fieldsValidating
                }
            , listCountiesByZipCode
            , Nothing
            )

        ClickedCancel ->
            ( Model { model | modalStatus = Closed }
            , Effect.closeDialog model.modalId
            , Nothing
            )

        ClickedIsTobaccoUser ->
            ( Model { model | isTobaccoUser = not model.isTobaccoUser }
            , Effect.none
            , Nothing
            )

        CompletedStoreClient (Ok client) ->
            ( Model { model | isSubmitting = False }
            , Effect.none
            , Just client
            )

        CompletedStoreClient (Err e) ->
            ( Model { model | isSubmitting = False }
            , Effect.none
            , Nothing
            )

        CompletedListCountiesByZipCode zipCode (Ok counties) ->
            let
                countyFipsCode =
                    case counties of
                        county :: _ ->
                            county.fipsCode

                        _ ->
                            ""
            in
            if zipCode == model.zipCode then
                ( Model
                    { model
                        | counties = RemoteData.Success counties
                        , countyFipsCode = countyFipsCode
                    }
                , Effect.none
                , Nothing
                )

            else
                ( Model model
                , Effect.none
                , Nothing
                )

        CompletedListCountiesByZipCode zipCode (Err e) ->
            if zipCode == model.zipCode then
                ( Model { model | counties = RemoteData.Failure e }
                , Effect.none
                , Nothing
                )

            else
                ( Model model
                , Effect.none
                , Nothing
                )

        CompletedIsClientEmailTaken (Ok isEmailTaken) ->
            ( Model { model | isEmailTaken = isEmailTaken }
            , Effect.none
            , Nothing
            )

        CompletedIsClientEmailTaken (Err e) ->
            ( Model model, Effect.none, Nothing )

        GotModalElement (Ok _) ->
            ( Model { model | modalStatus = Open }
            , Effect.showDialog model.modalId
            , Nothing
            )

        GotModalElement (Err _) ->
            ( Model model
            , Effect.none
            , Nothing
            )

        SubmittedForm ->
            if isValid (Model model) then
                ( Model
                    { model
                        | isSubmitting = True
                        , fieldsValidating = validateAllFields model.fieldsValidating
                    }
                , storeClient storeClientFn CompletedStoreClient (Model model)
                , Nothing
                )

            else
                ( Model { model | fieldsValidating = validateAllFields model.fieldsValidating }
                , Effect.none
                , Nothing
                )

        Tick ->
            ( Model model
            , Browser.Dom.getElement model.modalId
                |> Task.attempt GotModalElement
                |> Effect.sendCmd
            , Nothing
            )


subscriptions : Model -> Sub Msg
subscriptions (Model model) =
    case model.modalStatus of
        Opening ->
            Browser.Events.onAnimationFrame (always Tick)

        _ ->
            Sub.none



-- modalId : String
-- modalId =
--     "modal-new_client"


view :
    { title : String
    , buttonText : String
    , model : Model
    }
    -> Html Msg
view opts =
    let
        (Model model) =
            opts.model

        errors =
            validate (Model model)

        error field =
            if AnySet.member field model.fieldsValidating then
                AnyDict.get field errors

            else
                Nothing

        firstError fields =
            List.filterMap error fields
                |> List.head

        hasError field =
            error field /= Nothing

        viewError field =
            case error field of
                Just msg ->
                    div [ class "text-red-700 text-xs" ] [ text msg ]

                Nothing ->
                    text ""

        viewFirstError fields =
            case firstError fields of
                Just msg ->
                    div [ class "text-red-700 text-xs" ] [ text msg ]

                Nothing ->
                    text ""
    in
    dialog [ id model.modalId, class "min-w-[500px] rounded-lg shadow-md" ]
        [ Html.form [ id "clientForm", class "px-6 py-5 space-y-6", onSubmit SubmittedForm ]
            [ div [ class "text-gray-950 text-xl font-semibold" ] [ text opts.title ]
            , div [ class "text-blue-700 bg-blue-50 text-xs rounded-lg p-2" ] [ text "*  indicates a required field" ]
            , div [ class "space-y-[6px]" ]
                [ label [ class "block", for "first_name" ]
                    [ span [ class "text-red-700" ] [ text "*" ]
                    , span [] [ text " First name" ]
                    ]
                , input
                    [ id "first_name"
                    , type_ "text"
                    , classList [ ( "w-full", True ), ( "input-error", hasError FirstName ) ]
                    , value model.firstName
                    , onInput ChangedFirstName
                    , onBlur (BlurredField FirstName)
                    ]
                    []
                , viewError FirstName
                ]
            , div [ class "space-y-[6px]" ]
                [ label [ class "block", for "last_name" ]
                    [ span [ class "text-red-700" ] [ text "*" ]
                    , span [] [ text " Last name" ]
                    ]
                , input
                    [ id "last_name"
                    , type_ "text"
                    , classList [ ( "w-full", True ), ( "input-error", hasError LastName ) ]
                    , value model.lastName
                    , onInput ChangedLastName
                    , onBlur (BlurredField LastName)
                    ]
                    []
                , viewError LastName
                ]
            , div [ class "space-y-[6px]" ]
                [ div [ class "" ]
                    [ span [ class "text-red-700" ] [ text "*" ]
                    , span [] [ text " Date of birth" ]
                    ]
                , div [ class "flex gap-2" ]
                    [ div []
                        [ label [ class "block text-xs text-gray-500", for "dob_month" ] [ text "Month" ]
                        , UI.Select.fromValuesWithLabels model.dateOfBirthMonth
                            ChangedDateOfBirthMonth
                            [ id "dob_month", classList [ ( "input-error", hasError DateOfBirthMonth ) ], onBlur (BlurredField DateOfBirthMonth) ]
                            [ ( Nothing, "" )
                            , ( Just Time.Jan, "1-Jan" )
                            , ( Just Time.Feb, "2-Feb" )
                            , ( Just Time.Mar, "3-Mar" )
                            , ( Just Time.Apr, "4-Apr" )
                            , ( Just Time.May, "5-May" )
                            , ( Just Time.Jun, "6-Jun" )
                            , ( Just Time.Jul, "7-Jul" )
                            , ( Just Time.Aug, "8-Aug" )
                            , ( Just Time.Sep, "9-Sep" )
                            , ( Just Time.Oct, "10-Oct" )
                            , ( Just Time.Nov, "11-Nov" )
                            , ( Just Time.Dec, "12-Dec" )
                            ]
                        ]
                    , div []
                        [ label [ class "block text-xs text-gray-500", for "dob_day" ] [ text "Day" ]
                        , UI.Select.fromValuesWithLabels model.dateOfBirthDay
                            ChangedDateOfBirthDay
                            [ id "dob_day", classList [ ( "input-error", hasError DateOfBirthDay ) ], onBlur (BlurredField DateOfBirthDay) ]
                            (( Nothing, "" ) :: (List.range 1 31 |> List.map (\n -> ( Just n, String.fromInt n |> String.padLeft 2 '0' ))))
                        ]
                    , div []
                        [ label [ class "block text-xs text-gray-500", for "dob_year" ] [ text "Year" ]
                        , UI.Select.fromValuesWithLabels model.dateOfBirthYear
                            ChangedDateOfBirthYear
                            [ id "dob_year", classList [ ( "input-error", hasError DateOfBirthYear ) ], onBlur (BlurredField DateOfBirthYear) ]
                            (( Nothing, "" ) :: (List.range 1900 2024 |> List.map (\n -> ( Just n, String.fromInt n ))))
                        ]
                    ]
                , viewFirstError [ DateOfBirthMonth, DateOfBirthDay, DateOfBirthYear ]
                ]
            , div [ class "space-y-[6px]" ]
                [ label [ class "block", for "gender" ]
                    [ span [ class "text-red-700" ] [ text "*" ]
                    , span [] [ text " Gender" ]
                    ]
                , UI.Select.fromValuesWithLabels model.gender
                    ChangedGender
                    [ id "gender", classList [ ( "input-error", hasError Gender ) ], onBlur (BlurredField Gender) ]
                    [ ( Nothing, "" )
                    , ( Just Server.GenderMale, "Male" )
                    , ( Just Server.GenderFemale, "Female" )
                    ]
                , viewError Gender
                ]
            , div [ class "space-y-[6px]" ]
                [ label [ class "block", for "zip_code" ]
                    [ span [ class "text-red-700" ] [ text "*" ]
                    , span [] [ text " Zip code" ]
                    ]
                , input
                    [ id "zip_code"
                    , type_ "text"
                    , classList [ ( "input-error", hasError ZipCode ) ]
                    , value model.zipCode
                    , onInput ChangedZipCode
                    , onBlur (BlurredField ZipCode)
                    ]
                    []
                , viewError ZipCode
                ]
            , case model.counties of
                RemoteData.Success [] ->
                    viewNothing

                RemoteData.Success [ county ] ->
                    viewNothing

                RemoteData.Success counties ->
                    div [ class "space-y-[6px]" ]
                        [ label [ class "block", for "countyFipsCode" ]
                            [ span [ class "text-red-700" ] [ text "*" ]
                            , span [] [ text " County" ]
                            ]
                        , UI.Select.fromValuesWithLabels model.countyFipsCode
                            ChangedCountyFipsCode
                            [ id "countyFipsCode", classList [ ( "input-error", hasError CountyFipsCode ) ], onBlur (BlurredField CountyFipsCode) ]
                            (List.map (\county -> ( county.fipsCode, county.name )) counties)
                        , viewError CountyFipsCode
                        ]

                _ ->
                    viewNothing
            , div [ class "space-y-[6px]" ]
                [ label [ class "block", for "email" ] [ text "Email" ]
                , input
                    [ id "email"
                    , type_ "text"
                    , classList [ ( "w-full", True ), ( "input-error", hasError Email ) ]
                    , value model.email
                    , onInput ChangedEmail
                    , onBlur BlurredEmail
                    ]
                    []
                , viewError Email
                ]
            , div [ class "space-y-[6px]" ]
                [ label [ class "block", for "phone" ] [ text "Phone" ]
                , input
                    [ id "phone"
                    , type_ "text"
                    , classList [ ( "w-full", True ), ( "input-error", hasError Phone ) ]
                    , value model.phone
                    , onInput ChangedPhone
                    , onBlur (BlurredField Phone)
                    ]
                    []
                , viewError Phone
                ]
            , div []
                [ label []
                    [ input [ type_ "checkbox", checked model.isTobaccoUser, onClick ClickedIsTobaccoUser ] []
                    , span [ class "ml-2" ] [ text "Is a tobacco user?" ]
                    ]
                ]
            , div [ class "flex items-center justify-end gap-4" ]
                [ UI.Button.new "Cancel"
                    |> UI.Button.withStyle UI.Button.Secondary
                    |> UI.Button.withType (UI.Button.Button ClickedCancel)
                    |> UI.Button.view
                , UI.Button.new opts.buttonText
                    |> (if model.isSubmitting then
                            UI.Button.withIcon UI.Icon.Loading4Animated

                        else
                            identity
                       )
                    |> UI.Button.view
                ]
            ]
        ]


viewNothing : Html msg
viewNothing =
    text ""



-- FORM VALIDATION


type Field
    = FirstName
    | LastName
    | DateOfBirthMonth
    | DateOfBirthDay
    | DateOfBirthYear
    | Gender
    | ZipCode
    | CountyFipsCode
    | Email
    | Phone


validateAllFields : AnySet Int Field -> AnySet Int Field
validateAllFields fieldsValiating =
    fieldsValiating
        |> AnySet.insert FirstName
        |> AnySet.insert LastName
        |> AnySet.insert DateOfBirthMonth
        |> AnySet.insert DateOfBirthDay
        |> AnySet.insert DateOfBirthYear
        |> AnySet.insert Gender
        |> AnySet.insert ZipCode
        |> AnySet.insert CountyFipsCode
        |> AnySet.insert Email
        |> AnySet.insert Phone


fieldToInt : Field -> Int
fieldToInt field =
    case field of
        FirstName ->
            0

        LastName ->
            1

        DateOfBirthMonth ->
            2

        DateOfBirthDay ->
            3

        DateOfBirthYear ->
            4

        Gender ->
            5

        ZipCode ->
            6

        CountyFipsCode ->
            7

        Email ->
            8

        Phone ->
            9


type alias Errors =
    AnyDict Int Field String


emptyErrors : Errors
emptyErrors =
    AnyDict.empty fieldToInt


isValid : Model -> Bool
isValid model =
    AnyDict.isEmpty (validate model)


validate : Model -> Errors
validate (Model model) =
    let
        validateFirstName errors =
            if Validate.isBlank model.firstName then
                AnyDict.insert FirstName "Required" errors

            else
                errors

        validateLastName errors =
            if Validate.isBlank model.lastName then
                AnyDict.insert LastName "Required" errors

            else
                errors

        validateDateOfBirthMonth errors =
            if model.dateOfBirthMonth == Nothing then
                AnyDict.insert DateOfBirthMonth "Month required" errors

            else
                errors

        validateDateOfBirthDay errors =
            case model.dateOfBirthDay of
                Just day ->
                    if day < 1 || day > 31 then
                        AnyDict.insert DateOfBirthDay "Day invalid" errors

                    else
                        errors

                Nothing ->
                    AnyDict.insert DateOfBirthDay "Day required" errors

        validateDateOfBirthYear errors =
            case model.dateOfBirthYear of
                Just year ->
                    if year < 1800 || year > 2100 then
                        AnyDict.insert DateOfBirthYear "Year invalid" errors

                    else
                        errors

                Nothing ->
                    AnyDict.insert DateOfBirthYear "Year required" errors

        validateGender errors =
            if model.gender == Nothing then
                AnyDict.insert Gender "Required" errors

            else
                errors

        validateZipCode errors =
            if Validate.isBlank model.zipCode then
                AnyDict.insert ZipCode "Required" errors

            else if not (Validate.isZipCode model.zipCode) then
                AnyDict.insert ZipCode "Invalid zip code" errors

            else if RemoteData.map List.isEmpty model.counties |> RemoteData.withDefault False then
                AnyDict.insert ZipCode "Zip code not found" errors

            else
                errors

        validateCountyFipsCode errors =
            if Validate.isBlank model.countyFipsCode then
                AnyDict.insert CountyFipsCode "Required" errors

            else if not (Validate.isCountyFipsCode model.countyFipsCode) then
                AnyDict.insert CountyFipsCode "Invalid county" errors

            else
                errors

        validateEmail errors =
            if Validate.isBlank model.email then
                errors

            else if not (Validate.isEmail model.email) then
                AnyDict.insert Email "Invalid email" errors

            else if model.isEmailTaken then
                AnyDict.insert Email "Email is taken" errors

            else
                errors

        validatePhone errors =
            if Validate.isBlank model.phone then
                errors

            else if not (Validate.isPhoneNumber model.phone) then
                AnyDict.insert Phone "Must contain only numbers and hyphens" errors

            else
                errors
    in
    emptyErrors
        |> validateFirstName
        |> validateLastName
        |> validateDateOfBirthMonth
        |> validateDateOfBirthDay
        |> validateDateOfBirthYear
        |> validateGender
        |> validateZipCode
        |> validateCountyFipsCode
        |> validateEmail
        |> validatePhone



-- EFFECTS


storeClient : StoreClientFn -> (Result Server.Error Server.Client -> Msg) -> Model -> Effect Msg
storeClient storeClientFn toMsg (Model model) =
    let
        dateOfBirth =
            Maybe.map3 Date.fromCalendarDate model.dateOfBirthYear model.dateOfBirthMonth model.dateOfBirthDay
                |> Maybe.map Date.toIsoString
                |> Maybe.withDefault ""

        gender =
            Maybe.withDefault Server.GenderMale model.gender

        email =
            if Validate.isBlank model.email then
                Nothing

            else
                Just model.email

        phone =
            if Validate.isBlank model.phone then
                Nothing

            else
                Just model.phone

        values =
            { firstName = model.firstName
            , lastName = model.lastName
            , dateOfBirth = dateOfBirth
            , gender = gender
            , zipCode = model.zipCode
            , countyFipsCode = model.countyFipsCode
            , email = email
            , phone = phone
            , isTobaccoUser = model.isTobaccoUser
            }
    in
    storeClientFn values toMsg
        |> Effect.sendCmd

================
File: frontend/src/Pages/Clients/Id_.elm
================
module Pages.Clients.Id_ exposing (Model, Msg, page)

import Auth
import Date
import Dict
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Layouts
import Modal.ClientForm as ClientForm
import Page exposing (Page)
import RemoteData exposing (RemoteData)
import Route exposing (Route)
import Route.Path
import Server
import Shared
import UI.Alert
import UI.Button
import UI.Icon
import UI.Quote
import UI.Time
import View exposing (View)


page : Auth.User -> Shared.Model -> Route { id : String } -> Page Model Msg
page user shared route =
    Page.new
        { init = init route
        , update = update shared
        , subscriptions = subscriptions
        , view = view shared
        }
        |> Page.withLayout (toLayout user)


toLayout : Auth.User -> Model -> Layouts.Layout Msg
toLayout user model =
    Layouts.Default
        { agent = user
        }



-- INIT


type alias Model =
    { client : RemoteData Server.Error Server.Client
    , quotes : RemoteData Server.Error Server.ListQuotesResponse
    , clientForm : Maybe ClientForm.Model
    }


init : Route { id : String } -> () -> ( Model, Effect Msg )
init route () =
    let
        clientId =
            route.params.id
                |> String.toInt
                |> Maybe.withDefault 0
    in
    ( { client = RemoteData.Loading
      , quotes = RemoteData.Loading
      , clientForm = Nothing
      }
    , Effect.batch
        [ Server.dashboard.getClient clientId
            |> Server.send CompletedGetClient
            |> Effect.sendCmd
        , Server.dashboard.listQuotes
            { clientId = Just clientId
            , startingAfter = Nothing
            , endingBefore = Nothing
            , limit = 100
            }
            |> Server.send CompletedListQuotes
            |> Effect.sendCmd
        ]
    )



-- UPDATE


type Msg
    = ClickedEdit
    | ClickedQuote Int
    | CompletedGetClient (Result Server.Error Server.Client)
    | CompletedListQuotes (Result Server.Error Server.ListQuotesResponse)
    | GotClientFormMsg ClientForm.Msg


update : Shared.Model -> Msg -> Model -> ( Model, Effect Msg )
update shared msg model =
    let
        noop =
            ( model, Effect.none )
    in
    case msg of
        ClickedEdit ->
            case model.client of
                RemoteData.Success client ->
                    let
                        ( clientForm, clientFormEffect ) =
                            ClientForm.new shared
                                "edit_client_modal"
                                { firstName = Just client.firstName
                                , lastName = Just client.lastName
                                , dateOfBirth = Just client.dateOfBirth
                                , gender = Just client.gender
                                , zipCode = Just client.zipCode
                                , countyFipsCode = Just client.county.fipsCode
                                , email = client.email
                                , phone = client.phone
                                , isTobaccoUser = Just client.isTobaccoUser
                                }
                    in
                    ( { model | clientForm = Just clientForm }
                    , Effect.map GotClientFormMsg clientFormEffect
                    )

                _ ->
                    noop

        ClickedQuote quoteId ->
            ( model
            , Effect.pushRoutePath (Route.Path.Quotes_Id_ { id = String.fromInt quoteId })
            )

        CompletedGetClient result ->
            ( { model | client = RemoteData.fromResult result }
            , Effect.none
            )

        CompletedListQuotes result ->
            ( { model | quotes = RemoteData.fromResult result }
            , Effect.none
            )

        GotClientFormMsg clientFormMsg ->
            case ( model.client, model.clientForm ) of
                ( RemoteData.Success client, Just clientForm ) ->
                    let
                        ( updatedClientForm, clientFormEffect, updatedClient ) =
                            ClientForm.update (storeClientFn client) (isClientEmailTakenFn client) clientFormMsg clientForm
                    in
                    case updatedClient of
                        Just updatedClient_ ->
                            ( { model
                                | client = RemoteData.map (always updatedClient_) model.client
                                , clientForm = Nothing
                              }
                            , Effect.none
                            )

                        Nothing ->
                            ( { model | clientForm = Just updatedClientForm }
                            , Effect.map GotClientFormMsg clientFormEffect
                            )

                _ ->
                    noop


storeClientFn : Server.Client -> ClientForm.Values -> (Result Server.Error Server.Client -> ClientForm.Msg) -> Cmd ClientForm.Msg
storeClientFn client values toMsg =
    Server.dashboard.updateClient
        { id = client.id
        , firstName = values.firstName
        , lastName = values.lastName
        , dateOfBirth = values.dateOfBirth
        , gender = values.gender
        , zipCode = values.zipCode
        , countyFipsCode = values.countyFipsCode
        , email = values.email
        , phone = values.phone
        , isTobaccoUser = values.isTobaccoUser
        }
        |> Server.send toMsg


isClientEmailTakenFn : Server.Client -> String -> (Result Server.Error Bool -> ClientForm.Msg) -> Cmd ClientForm.Msg
isClientEmailTakenFn client email toMsg =
    Server.dashboard.isClientEmailTaken email (Just client.id)
        |> Server.send toMsg



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    case model.clientForm of
        Just clientForm ->
            ClientForm.subscriptions clientForm |> Sub.map GotClientFormMsg

        Nothing ->
            Sub.none



-- VIEW


view : Shared.Model -> Model -> View Msg
view shared model =
    { title = "Client"
    , body =
        case RemoteData.map2 Tuple.pair model.client model.quotes of
            RemoteData.NotAsked ->
                []

            RemoteData.Loading ->
                [ div [ class "w-full text-gray-300 flex justify-center py-8" ]
                    [ UI.Icon.new UI.Icon.Loading4Animated
                        |> UI.Icon.withSize 24
                        |> UI.Icon.withStrokeWidth 2
                        |> UI.Icon.view
                    ]
                ]

            RemoteData.Success ( client, quotes ) ->
                let
                    name =
                        client.firstName ++ " " ++ client.lastName

                    dateOfBirth =
                        client.dateOfBirth
                            |> Date.fromIsoString
                            |> Result.toMaybe
                            |> Maybe.map (Date.format "MMM d, y")
                            |> Maybe.withDefault ""

                    age =
                        String.fromInt client.age

                    dateOfBirthAndAge =
                        dateOfBirth ++ " (Age: " ++ age ++ ")"

                    gender =
                        case client.gender of
                            Server.GenderMale ->
                                "Male"

                            Server.GenderFemale ->
                                "Female"

                    zipCode =
                        client.zipCode

                    county =
                        client.county.name

                    email =
                        case client.email of
                            Just email_ ->
                                email_

                            Nothing ->
                                "--"

                    phone =
                        case client.phone of
                            Just phone_ ->
                                phone_

                            Nothing ->
                                "--"

                    isTobaccoUser =
                        if client.isTobaccoUser then
                            "Yes"

                        else
                            "No"

                    clientId =
                        String.fromInt client.id

                    created =
                        UI.Time.posixToString shared.zone client.createdAt

                    updated =
                        UI.Time.posixToString shared.zone client.updatedAt
                in
                [ div [ class "space-y-8" ]
                    [ -- HEADER
                      div [ class "flex items-center" ]
                        [ div []
                            [ div [ class "text-gray-500 text-xs font-semibold" ] [ text "Clients" ]
                            , div [ class "text-gray-950 text-3xl font-bold" ] [ text name ]
                            ]
                        , div [ class "ml-auto" ]
                            [ UI.Button.new "Edit"
                                |> UI.Button.withIcon UI.Icon.Edit2
                                |> UI.Button.withType (UI.Button.Button ClickedEdit)
                                |> UI.Button.view
                            ]
                        ]

                    -- CONTENT
                    , div [ class "flex gap-8" ]
                        [ -- LEFT COLUMN
                          div [ class "grow space-y-8" ]
                            [ -- SUMMARY
                              div []
                                [ div [ class "border-b border-gray-300 font-semibold text-xl text-gray-950 pb-4 mb-6" ] [ text "Summary" ]
                                , div [ class "grid grid-cols-2 gap-[1.3125rem]" ]
                                    [ div []
                                        [ div [ class "font-semibold" ] [ text "Date of birth" ]
                                        , div [] [ text dateOfBirthAndAge ]
                                        ]
                                    , div []
                                        [ div [ class "font-semibold" ] [ text "Gender" ]
                                        , div [] [ text gender ]
                                        ]
                                    , div []
                                        [ div [ class "font-semibold" ] [ text "Zip code" ]
                                        , div [] [ text zipCode ]
                                        ]
                                    , div []
                                        [ div [ class "font-semibold" ] [ text "County" ]
                                        , div [] [ text county ]
                                        ]
                                    , div []
                                        [ div [ class "font-semibold" ] [ text "Email" ]
                                        , div [] [ text email ]
                                        ]
                                    , div []
                                        [ div [ class "font-semibold" ] [ text "Phone" ]
                                        , div [] [ text phone ]
                                        ]
                                    , div []
                                        [ div [ class "font-semibold" ] [ text "Tobacco user" ]
                                        , div [] [ text isTobaccoUser ]
                                        ]
                                    ]
                                ]

                            -- QUOTES
                            , div []
                                [ div [ class "flex items-center pb-4" ]
                                    [ div [ class "font-semibold text-xl text-gray-950" ] [ text "Quotes" ]
                                    , div [ class "ml-auto flex items-center" ]
                                        [ UI.Button.new "New quote"
                                            |> UI.Button.withIcon UI.Icon.Plus
                                            |> UI.Button.withSize UI.Button.Small
                                            |> UI.Button.withStyle UI.Button.Secondary
                                            |> UI.Button.withType
                                                (UI.Button.Link
                                                    (Route.toString
                                                        { path = Route.Path.Quotes_New
                                                        , query = Dict.singleton "clientId" (String.fromInt client.id)
                                                        , hash = Nothing
                                                        }
                                                    )
                                                )
                                            |> UI.Button.view
                                        ]
                                    ]
                                , case quotes.data of
                                    [] ->
                                        viewQuotesEmptyTable

                                    _ ->
                                        viewQuotesTable shared quotes.data
                                ]
                            ]

                        -- RIGHT COLUMN
                        , div [ class "flex-none w-1/4" ]
                            [ div [ class "border-b border-gray-300 font-semibold text-xl text-gray-950 pb-4 mb-6" ] [ text "Details" ]
                            , div [ class "grid grid-cols-1 gap-[1.3125rem]" ]
                                [ div []
                                    [ div [ class "font-semibold" ] [ text "ID" ]
                                    , div [] [ text clientId ]
                                    ]
                                , div []
                                    [ div [ class "font-semibold" ] [ text "Created" ]
                                    , div [] [ text created ]
                                    ]
                                , div []
                                    [ div [ class "font-semibold" ] [ text "Updated" ]
                                    , div [] [ text updated ]
                                    ]
                                ]
                            ]
                        ]
                    ]
                , case model.clientForm of
                    Just clientForm ->
                        ClientForm.view
                            { title = "Update client"
                            , buttonText = "Update client"
                            , model = clientForm
                            }
                            |> Html.map GotClientFormMsg

                    Nothing ->
                        viewNothing
                ]

            RemoteData.Failure (Server.WebrpcError Server.EntityNotFound _) ->
                [ UI.Alert.error "The client you're looking for could not be found."
                ]

            RemoteData.Failure _ ->
                [ UI.Alert.error "Whoops, an error occurred."
                ]
    }


viewQuotesEmptyTable : Html msg
viewQuotesEmptyTable =
    div [ class "px-10 py-6 text-gray-500 border border-gray-300 rounded-lg text-center" ]
        [ text "This client has no quotes."
        ]


viewQuotesTable : Shared.Model -> List Server.ShortQuote -> Html Msg
viewQuotesTable shared quotes =
    table [ class "w-full border-collapse border-y border-gray-300" ]
        [ thead []
            [ tr [ class "text-xs font-semibold" ]
                [ th [ class "text-left h-10 pl-2 pr-3" ] [ text "Quote number" ]
                , th [ class "text-right h-10 pl-3 pr-2 whitespace-nowrap" ] [ text "Created" ]
                ]
            ]
        , tbody []
            (List.map (viewQuotesTableRow shared) quotes)
        ]


viewQuotesTableRow : Shared.Model -> Server.ShortQuote -> Html Msg
viewQuotesTableRow shared quote =
    let
        quoteNumber =
            UI.Quote.quoteNumber quote.id

        created =
            UI.Time.posixToString shared.zone quote.createdAt
    in
    tr [ class "border-t border-gray-200 cursor-pointer hover:bg-gray-100", onClick (ClickedQuote quote.id) ]
        [ td [ class "text-left h-10 pl-2 pr-3 font-semibold tabular-nums" ] [ text quoteNumber ]
        , td [ class "text-right h-10 pl-3 pr-2 tabular-nums text-gray-500 whitespace-nowrap" ] [ text created ]
        ]


viewNothing : Html msg
viewNothing =
    text ""

================
File: frontend/src/Pages/Quotes/Id_/Edit.elm
================
module Pages.Quotes.Id_.Edit exposing (Model, Msg, page)

import Auth
import Date
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Layouts
import Modal.ClientForm as ClientForm
import Page exposing (Page)
import PagesExt.Quotes.New.ClientSearch as ClientSearch
import PagesExt.Quotes.New.Form as QuoteForm
import RemoteData exposing (RemoteData)
import Route exposing (Route)
import Route.Path
import Server
import Shared
import UI.Alert
import UI.Button
import UI.Icon
import UI.Quote
import View exposing (View)


page : Auth.User -> Shared.Model -> Route { id : String } -> Page Model Msg
page user shared route =
    Page.new
        { init = init route
        , update = update shared
        , subscriptions = subscriptions
        , view = view shared
        }
        |> Page.withLayout (toLayout user)


toLayout : Auth.User -> Model -> Layouts.Layout Msg
toLayout user model =
    Layouts.Default
        { agent = user
        }



-- INIT


type alias Model =
    { quote : RemoteData Server.Error Server.Quote
    , spouseQuote : RemoteData Server.Error (Maybe Server.Quote)
    , client : ClientStatus
    , spouse : Maybe ClientStatus
    , selectedTab : Tab
    , isSubmitting : Bool
    , redirectToQuoteReview : Bool
    }


type ClientStatus
    = Searching
        { search : ClientSearch.Model
        , newClientForm : Maybe ClientForm.Model
        }
    | Success
        { client : Server.Client
        , editClientForm : Maybe ClientForm.Model
        , quoteForm : QuoteForm.Model
        }


type Tab
    = TabClient
    | TabSpouse


init : Route { id : String } -> () -> ( Model, Effect Msg )
init route () =
    let
        id =
            route.params.id
                |> String.toInt
                |> Maybe.withDefault 0
    in
    ( { quote = RemoteData.Loading
      , spouseQuote = RemoteData.Loading
      , client = Searching { search = ClientSearch.new, newClientForm = Nothing }
      , spouse = Nothing
      , selectedTab = TabClient
      , isSubmitting = False
      , redirectToQuoteReview = False
      }
    , Effect.batch
        [ Server.dashboard.getQuote id
            |> Server.send CompletedGetQuote
            |> Effect.sendCmd
        , Server.dashboard.getSpouseQuote id
            |> Server.send CompletedGetSpouseQuote
            |> Effect.sendCmd
        ]
    )



-- UPDATE


type Msg
    = ClickedAddClient String
    | ClickedAddSpouse String
    | ClickedChangeClient
    | ClickedChangeSpouse
    | ClickedEditClient
    | ClickedEditSpouse
    | ClickedEnableSpouse
    | ClickedRedirectToPublicQuote
    | ClickedTab Tab
    | CompletedGetQuote (Result Server.Error Server.Quote)
    | CompletedGetSpouseQuote (Result Server.Error Server.Quote)
    | CompletedUpdateQuote (Result Server.Error Server.Quote)
    | GotClientQuoteFormMsg QuoteForm.Msg
    | GotClientSearchMsg ClientSearch.Msg
    | GotClientFormMsg ClientForm.Msg
    | GotEditClientFormMsg ClientForm.Msg
    | GotEditSpouseFormMsg ClientForm.Msg
    | GotNewSpouseFormMsg ClientForm.Msg
    | GotSpouseQuoteFormMsg QuoteForm.Msg
    | GotSpouseSearchMsg ClientSearch.Msg
    | SelectedClient Server.Client
    | SelectedSpouse Server.Client
    | SubmittedForm


update : Shared.Model -> Msg -> Model -> ( Model, Effect Msg )
update shared msg model =
    let
        noop =
            ( model, Effect.none )
    in
    case msg of
        ClickedAddClient fullName ->
            let
                firstName =
                    fullName
                        |> String.split " "
                        |> List.head
                        |> Maybe.withDefault ""

                lastName =
                    fullName
                        |> String.split " "
                        |> List.drop 1
                        |> String.join " "

                ( newClientForm, newClientFormEffect ) =
                    ClientForm.new shared
                        "new_client_modal"
                        { firstName = Just firstName
                        , lastName = Just lastName
                        , dateOfBirth = Nothing
                        , gender = Nothing
                        , zipCode = Nothing
                        , countyFipsCode = Nothing
                        , email = Nothing
                        , phone = Nothing
                        , isTobaccoUser = Nothing
                        }
            in
            case model.client of
                Searching searching ->
                    ( { model
                        | client =
                            Searching
                                { searching
                                    | search = ClientSearch.new
                                    , newClientForm = Just newClientForm
                                }
                      }
                    , Effect.map GotClientFormMsg newClientFormEffect
                    )

                Success _ ->
                    noop

        ClickedAddSpouse fullName ->
            let
                firstName =
                    fullName
                        |> String.split " "
                        |> List.head
                        |> Maybe.withDefault ""

                lastName =
                    fullName
                        |> String.split " "
                        |> List.drop 1
                        |> String.join " "

                ( newClientForm, newClientFormEffect ) =
                    ClientForm.new shared
                        "new_spouse_modal"
                        { firstName = Just firstName
                        , lastName = Just lastName
                        , dateOfBirth = Nothing
                        , gender = Nothing
                        , zipCode = Nothing
                        , countyFipsCode = Nothing
                        , email = Nothing
                        , phone = Nothing
                        , isTobaccoUser = Nothing
                        }
            in
            case model.spouse of
                Just (Searching searching) ->
                    ( { model
                        | spouse =
                            Just
                                (Searching
                                    { searching
                                        | search = ClientSearch.new
                                        , newClientForm = Just newClientForm
                                    }
                                )
                      }
                    , Effect.map GotClientFormMsg newClientFormEffect
                    )

                _ ->
                    noop

        ClickedChangeClient ->
            ( { model
                | client =
                    Searching
                        { search = ClientSearch.new
                        , newClientForm = Nothing
                        }
                , spouse = Nothing
              }
            , Effect.none
            )

        ClickedChangeSpouse ->
            ( { model
                | spouse = Just <| Searching { search = ClientSearch.new, newClientForm = Nothing }
                , selectedTab = TabClient
              }
            , Effect.none
            )

        ClickedEditClient ->
            case model.client of
                Success success ->
                    let
                        ( editClientForm, clientFormEffects ) =
                            ClientForm.new shared
                                "edit_client_form"
                                { firstName = Just success.client.firstName
                                , lastName = Just success.client.lastName
                                , dateOfBirth = Just success.client.dateOfBirth
                                , gender = Just success.client.gender
                                , zipCode = Just success.client.zipCode
                                , countyFipsCode = Just success.client.county.fipsCode
                                , email = success.client.email
                                , phone = success.client.phone
                                , isTobaccoUser = Just success.client.isTobaccoUser
                                }
                    in
                    ( { model | client = Success { success | editClientForm = Just editClientForm } }
                    , Effect.map GotEditClientFormMsg clientFormEffects
                    )

                Searching _ ->
                    noop

        ClickedEditSpouse ->
            case model.spouse of
                Just (Success success) ->
                    let
                        ( editClientForm, clientFormEffects ) =
                            ClientForm.new shared
                                "edit_spouse_form"
                                { firstName = Just success.client.firstName
                                , lastName = Just success.client.lastName
                                , dateOfBirth = Just success.client.dateOfBirth
                                , gender = Just success.client.gender
                                , zipCode = Just success.client.zipCode
                                , countyFipsCode = Just success.client.county.fipsCode
                                , email = success.client.email
                                , phone = success.client.phone
                                , isTobaccoUser = Just success.client.isTobaccoUser
                                }
                    in
                    ( { model | spouse = Just (Success { success | editClientForm = Just editClientForm }) }
                    , Effect.map GotEditSpouseFormMsg clientFormEffects
                    )

                _ ->
                    noop

        ClickedEnableSpouse ->
            ( { model | spouse = Just <| Searching { search = ClientSearch.new, newClientForm = Nothing } }
            , Effect.none
            )

        ClickedRedirectToPublicQuote ->
            ( { model | redirectToQuoteReview = not model.redirectToQuoteReview }
            , Effect.none
            )

        ClickedTab tab ->
            ( { model | selectedTab = tab }
            , Effect.none
            )

        CompletedGetQuote (Ok quote) ->
            let
                ( client, clientEffects ) =
                    let
                        ( quoteForm, quoteFormEffect ) =
                            QuoteForm.new shared quote
                    in
                    ( Success
                        { client = quote.client
                        , editClientForm = Nothing
                        , quoteForm = quoteForm
                        }
                    , Effect.map GotClientQuoteFormMsg quoteFormEffect
                    )
            in
            ( { model
                | quote = RemoteData.Success quote
                , client = client
              }
            , clientEffects
            )

        CompletedGetQuote (Err e) ->
            ( { model | quote = RemoteData.Failure e }
            , Effect.none
            )

        CompletedGetSpouseQuote (Ok quote) ->
            let
                ( spouse, spouseEffects ) =
                    let
                        ( quoteForm, quoteFormEffect ) =
                            QuoteForm.new shared quote
                    in
                    ( Just <|
                        Success
                            { client = quote.client
                            , editClientForm = Nothing
                            , quoteForm = quoteForm
                            }
                    , Effect.map GotSpouseQuoteFormMsg quoteFormEffect
                    )
            in
            ( { model
                | spouseQuote = RemoteData.Success (Just quote)
                , spouse = spouse
              }
            , spouseEffects
            )

        CompletedUpdateQuote (Ok quote) ->
            let
                openQuoteReview =
                    if model.redirectToQuoteReview then
                        Effect.windowOpen (Route.Path.toString (Route.Path.Quotes_UrlId__Review { urlId = quote.urlId }))

                    else
                        Effect.none
            in
            ( { model
                | isSubmitting = False
                , redirectToQuoteReview = False
              }
            , Effect.batch
                [ Effect.pushRoutePath (Route.Path.Quotes_Id_ { id = String.fromInt quote.id })
                , openQuoteReview
                ]
            )

        CompletedUpdateQuote (Err e) ->
            ( { model
                | isSubmitting = False
                , redirectToQuoteReview = False
              }
            , Effect.none
            )

        CompletedGetSpouseQuote (Err (Server.WebrpcError Server.EntityNotFound _)) ->
            ( { model | spouseQuote = RemoteData.Success Nothing }
            , Effect.none
            )

        CompletedGetSpouseQuote (Err e) ->
            ( { model | spouseQuote = RemoteData.Failure e }
            , Effect.none
            )

        GotClientQuoteFormMsg quoteFormMsg ->
            case model.client of
                Success success ->
                    let
                        ( quoteForm, quoteFormEffect ) =
                            QuoteForm.update success.client quoteFormMsg success.quoteForm
                    in
                    ( { model | client = Success { success | quoteForm = quoteForm } }
                    , Effect.map GotClientQuoteFormMsg quoteFormEffect
                    )

                Searching _ ->
                    noop

        GotClientSearchMsg searchMsg ->
            case model.client of
                Searching searching ->
                    let
                        ( search, searchEffect ) =
                            ClientSearch.update searchMsg searching.search
                    in
                    ( { model | client = Searching { searching | search = search } }
                    , Effect.map GotClientSearchMsg searchEffect
                    )

                Success _ ->
                    noop

        GotClientFormMsg newClientFormMsg ->
            case model.client of
                Searching searching ->
                    case searching.newClientForm of
                        Just newClientForm ->
                            let
                                ( updatedClientForm, newClientFormEffect, createdClient ) =
                                    ClientForm.update createClientFn isNewClientEmailTakenFn newClientFormMsg newClientForm

                                selectedClientEffect =
                                    case createdClient of
                                        Just client ->
                                            Effect.sendMsg (SelectedClient client)

                                        Nothing ->
                                            Effect.none
                            in
                            ( { model | client = Searching { searching | newClientForm = Just updatedClientForm } }
                            , Effect.batch
                                [ Effect.map GotClientFormMsg newClientFormEffect
                                , selectedClientEffect
                                ]
                            )

                        Nothing ->
                            noop

                Success _ ->
                    noop

        GotEditClientFormMsg clientFormMsg ->
            case model.client of
                Success success ->
                    case success.editClientForm of
                        Just clientForm ->
                            let
                                ( updatedClientForm, clientFormEffects, storedClient ) =
                                    ClientForm.update (updateClientFn success.client) (isExistingClientEmailTakenFn success.client) clientFormMsg clientForm

                                client =
                                    case storedClient of
                                        Just c ->
                                            c

                                        Nothing ->
                                            success.client

                                editClientForm =
                                    case storedClient of
                                        Just _ ->
                                            Nothing

                                        Nothing ->
                                            Just updatedClientForm
                            in
                            ( { model | client = Success { success | editClientForm = editClientForm, client = client } }
                            , Effect.map GotEditClientFormMsg clientFormEffects
                            )

                        Nothing ->
                            noop

                Searching _ ->
                    noop

        GotEditSpouseFormMsg clientFormMsg ->
            case model.spouse of
                Just (Success success) ->
                    case success.editClientForm of
                        Just clientForm ->
                            let
                                ( updatedClientForm, clientFormEffects, storedClient ) =
                                    ClientForm.update (updateClientFn success.client) (isExistingClientEmailTakenFn success.client) clientFormMsg clientForm

                                client =
                                    case storedClient of
                                        Just c ->
                                            c

                                        Nothing ->
                                            success.client

                                editClientForm =
                                    case storedClient of
                                        Just _ ->
                                            Nothing

                                        Nothing ->
                                            Just updatedClientForm
                            in
                            ( { model | spouse = Just (Success { success | editClientForm = editClientForm, client = client }) }
                            , Effect.map GotEditSpouseFormMsg clientFormEffects
                            )

                        Nothing ->
                            noop

                _ ->
                    noop

        GotNewSpouseFormMsg newClientFormMsg ->
            case model.spouse of
                Just (Searching searching) ->
                    case searching.newClientForm of
                        Just newClientForm ->
                            let
                                ( updatedClientForm, newClientFormEffect, createdClient ) =
                                    ClientForm.update createClientFn isNewClientEmailTakenFn newClientFormMsg newClientForm

                                selectedClientEffect =
                                    case createdClient of
                                        Just client ->
                                            Effect.sendMsg (SelectedSpouse client)

                                        Nothing ->
                                            Effect.none
                            in
                            ( { model | spouse = Just <| Searching { searching | newClientForm = Just updatedClientForm } }
                            , Effect.batch
                                [ Effect.map GotNewSpouseFormMsg newClientFormEffect
                                , selectedClientEffect
                                ]
                            )

                        Nothing ->
                            noop

                _ ->
                    noop

        GotSpouseQuoteFormMsg quoteFormMsg ->
            case model.spouse of
                Just (Success success) ->
                    let
                        ( quoteForm, quoteFormEffect ) =
                            QuoteForm.update success.client quoteFormMsg success.quoteForm
                    in
                    ( { model | spouse = Just <| Success { success | quoteForm = quoteForm } }
                    , Effect.map GotSpouseQuoteFormMsg quoteFormEffect
                    )

                _ ->
                    noop

        GotSpouseSearchMsg searchMsg ->
            case model.spouse of
                Just (Searching searching) ->
                    let
                        ( search, searchEffect ) =
                            ClientSearch.update searchMsg searching.search
                    in
                    ( { model | spouse = Just <| Searching { searching | search = search } }
                    , Effect.map GotSpouseSearchMsg searchEffect
                    )

                _ ->
                    noop

        SelectedClient client ->
            case model.client of
                Searching _ ->
                    ( { model
                        | client =
                            Success
                                { client = client
                                , editClientForm = Nothing
                                , quoteForm = QuoteForm.empty shared
                                }
                      }
                    , Effect.none
                    )

                Success _ ->
                    noop

        SelectedSpouse client ->
            case model.spouse of
                Just (Searching _) ->
                    ( { model
                        | spouse =
                            Just <|
                                Success
                                    { client = client
                                    , editClientForm = Nothing
                                    , quoteForm = QuoteForm.empty shared
                                    }
                      }
                    , Effect.none
                    )

                _ ->
                    noop

        SubmittedForm ->
            case updateQuote model of
                Just updateQuoteEffect ->
                    ( { model | isSubmitting = True }
                    , updateQuoteEffect
                    )

                Nothing ->
                    noop


updateQuote : Model -> Maybe (Effect Msg)
updateQuote model =
    case ( model.quote, model.client ) of
        ( RemoteData.Success quote, Success success ) ->
            case QuoteForm.export success.quoteForm of
                Just values ->
                    let
                        updateQuoteParams =
                            { id = quote.id
                            , clientId = success.client.id
                            , effectiveDate = Date.toIsoString values.effectiveDate
                            , irmaaBracketId = values.irmaaBracketId
                            , drugQuoteId = values.drugQuoteId
                            , supplementalCarrierPlanTypes = List.map (\( carrierNaic, planType ) -> Server.SupplementalCarrierPlanType carrierNaic planType) values.supplementalPlans
                            , dentalQuoteId = values.dentalQuoteId
                            , hasMultiInsuredDiscount = values.hasMultiInsuredDiscount
                            , hasLivingWithSomeoneDiscount = values.hasLivingWithSomeoneDiscount
                            }

                        updateSpouseQuoteParams =
                            case model.spouse of
                                Just (Success spouse) ->
                                    case QuoteForm.export spouse.quoteForm of
                                        Just spouseValues ->
                                            Just
                                                { clientId = spouse.client.id
                                                , effectiveDate = Date.toIsoString spouseValues.effectiveDate
                                                , irmaaBracketId = spouseValues.irmaaBracketId
                                                , drugQuoteId = spouseValues.drugQuoteId
                                                , supplementalCarrierPlanTypes = List.map (\( carrierNaic, planType ) -> Server.SupplementalCarrierPlanType carrierNaic planType) spouseValues.supplementalPlans
                                                , dentalQuoteId = spouseValues.dentalQuoteId
                                                , hasMultiInsuredDiscount = spouseValues.hasMultiInsuredDiscount
                                                , hasLivingWithSomeoneDiscount = spouseValues.hasLivingWithSomeoneDiscount
                                                }

                                        Nothing ->
                                            Nothing

                                _ ->
                                    Nothing
                    in
                    Server.dashboard.updateQuote updateQuoteParams updateSpouseQuoteParams
                        |> Server.send CompletedUpdateQuote
                        |> Effect.sendCmd
                        |> Just

                Nothing ->
                    Nothing

        _ ->
            Nothing


createClientFn : ClientForm.Values -> (Result Server.Error Server.Client -> ClientForm.Msg) -> Cmd ClientForm.Msg
createClientFn values toMsg =
    Server.dashboard.createClient values
        |> Server.send toMsg


isNewClientEmailTakenFn : String -> (Result Server.Error Bool -> ClientForm.Msg) -> Cmd ClientForm.Msg
isNewClientEmailTakenFn email toMsg =
    Server.dashboard.isClientEmailTaken email Nothing
        |> Server.send toMsg


updateClientFn : Server.Client -> ClientForm.Values -> (Result Server.Error Server.Client -> ClientForm.Msg) -> Cmd ClientForm.Msg
updateClientFn client values toMsg =
    Server.dashboard.updateClient
        { id = client.id
        , firstName = values.firstName
        , lastName = values.lastName
        , dateOfBirth = values.dateOfBirth
        , gender = values.gender
        , zipCode = values.zipCode
        , countyFipsCode = values.countyFipsCode
        , email = values.email
        , phone = values.phone
        , isTobaccoUser = values.isTobaccoUser
        }
        |> Server.send toMsg


isExistingClientEmailTakenFn : Server.Client -> String -> (Result Server.Error Bool -> ClientForm.Msg) -> Cmd ClientForm.Msg
isExistingClientEmailTakenFn client email toMsg =
    Server.dashboard.isClientEmailTaken email (Just client.id)
        |> Server.send toMsg



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        clientSearchSubs =
            case model.client of
                Searching searching ->
                    ClientSearch.subscriptions searching.search |> Sub.map GotClientSearchMsg

                Success _ ->
                    Sub.none

        newClientFormSubs =
            case model.client of
                Searching searching ->
                    case searching.newClientForm of
                        Just newClientForm ->
                            ClientForm.subscriptions newClientForm |> Sub.map GotClientFormMsg

                        Nothing ->
                            Sub.none

                Success _ ->
                    Sub.none

        editClientFormSubs =
            case model.client of
                Success success ->
                    case success.editClientForm of
                        Just clientForm ->
                            ClientForm.subscriptions clientForm |> Sub.map GotEditClientFormMsg

                        Nothing ->
                            Sub.none

                Searching _ ->
                    Sub.none

        clientQuoteFormSubscriptions =
            case model.client of
                Success success ->
                    QuoteForm.subscriptions success.quoteForm |> Sub.map GotClientQuoteFormMsg

                _ ->
                    Sub.none

        spouseSearchSubs =
            case model.spouse of
                Just (Searching searching) ->
                    ClientSearch.subscriptions searching.search |> Sub.map GotSpouseSearchMsg

                _ ->
                    Sub.none

        newSpouseFormSubs =
            case model.spouse of
                Just (Searching searching) ->
                    case searching.newClientForm of
                        Just newClientForm ->
                            ClientForm.subscriptions newClientForm |> Sub.map GotNewSpouseFormMsg

                        Nothing ->
                            Sub.none

                _ ->
                    Sub.none

        editSpouseFormSubs =
            case model.spouse of
                Just (Success success) ->
                    case success.editClientForm of
                        Just clientForm ->
                            ClientForm.subscriptions clientForm |> Sub.map GotEditSpouseFormMsg

                        Nothing ->
                            Sub.none

                _ ->
                    Sub.none

        spouseQuoteFormSubscriptions =
            case model.spouse of
                Just (Success success) ->
                    QuoteForm.subscriptions success.quoteForm |> Sub.map GotSpouseQuoteFormMsg

                _ ->
                    Sub.none
    in
    Sub.batch
        [ clientSearchSubs
        , spouseSearchSubs
        , newClientFormSubs
        , editClientFormSubs
        , newSpouseFormSubs
        , editSpouseFormSubs
        , clientQuoteFormSubscriptions
        , spouseQuoteFormSubscriptions
        ]



-- VIEW


view : Shared.Model -> Model -> View Msg
view shared model =
    let
        data =
            RemoteData.map2 Tuple.pair model.quote model.spouseQuote
    in
    { title = "Edit Quote"
    , body =
        case data of
            RemoteData.NotAsked ->
                []

            RemoteData.Loading ->
                [ div [ class "w-full text-gray-300 flex justify-center my-10" ]
                    [ UI.Icon.new UI.Icon.Loading4Animated
                        |> UI.Icon.withSize 24
                        |> UI.Icon.withStrokeWidth 2
                        |> UI.Icon.view
                    ]
                ]

            RemoteData.Success ( quote, spouseQuote ) ->
                [ -- HEADER
                  div [ class "mb-12" ]
                    [ a [ class "text-xs text-[var(--brand-color)] font-semibold", Route.Path.href Route.Path.Quotes ] [ text "Quotes" ]
                    , div [ class "text-3xl text-gray-950 font-bold" ] [ text ("Edit " ++ UI.Quote.quoteNumber quote.id) ]
                    ]

                -- CLIENT & SPOUSE
                , div [ class "flex gap-8 items-start mb-12" ]
                    [ div [ class "w-1/2" ]
                        [ div [ class "font-semibold text-xl text-gray-950 mb-[6px]" ] [ text "Client" ]

                        -- CLIENT CARD
                        , case model.client of
                            Searching searching ->
                                div []
                                    [ ClientSearch.input
                                        { model = searching.search
                                        , onClientClick = SelectedClient
                                        , onAddClientClick = ClickedAddClient
                                        , toMsg = GotClientSearchMsg
                                        }
                                    ]

                            Success success ->
                                div []
                                    [ viewClient success.client
                                    , div [ class "flex gap-6" ]
                                        [ div [ class "underline cursor-pointer text-[var(--brand-color)] text-xs leading-5", onClick ClickedChangeClient ] [ text "Change client" ]
                                        , div [ class "underline cursor-pointer text-[var(--brand-color)] text-xs leading-5", onClick ClickedEditClient ] [ text "Edit client" ]
                                        ]
                                    ]
                        ]
                    , div [ class "w-1/2" ]
                        (case ( model.client, model.spouse ) of
                            ( Success _, Nothing ) ->
                                [ UI.Button.new "Add a spouse"
                                    |> UI.Button.withStyle UI.Button.Secondary
                                    |> UI.Button.withType (UI.Button.Button ClickedEnableSpouse)
                                    |> UI.Button.withIcon UI.Icon.Plus
                                    |> UI.Button.withSize UI.Button.Small
                                    |> UI.Button.view
                                ]

                            ( Success _, Just (Searching searching) ) ->
                                [ div [ class "font-semibold text-gray-950 text-xl mb-[6px]" ] [ text "Spouse" ]
                                , ClientSearch.input
                                    { model = searching.search
                                    , onClientClick = SelectedSpouse
                                    , onAddClientClick = ClickedAddSpouse
                                    , toMsg = GotSpouseSearchMsg
                                    }
                                ]

                            ( Success _, Just (Success success) ) ->
                                [ div [ class "font-semibold text-gray-950 text-xl mb-[6px]" ] [ text "Spouse" ]
                                , div []
                                    [ viewClient success.client
                                    , div [ class "flex gap-6" ]
                                        [ div [ class "text-[var(--brand-color)] underline text-xs cursor-pointer leading-5", onClick ClickedChangeSpouse ] [ text "Change spouse" ]
                                        , div [ class "underline cursor-pointer text-[var(--brand-color)] text-xs leading-5", onClick ClickedEditSpouse ] [ text "Edit spouse" ]
                                        ]
                                    ]
                                ]

                            ( Searching _, _ ) ->
                                []
                        )
                    ]

                -- TABS
                , viewTabs model

                -- FORMS
                , case ( model.client, model.spouse, model.selectedTab ) of
                    ( Success success, _, TabClient ) ->
                        QuoteForm.view shared success.quoteForm
                            |> Html.map GotClientQuoteFormMsg

                    ( Success _, Just (Success success), TabSpouse ) ->
                        QuoteForm.view shared success.quoteForm
                            |> Html.map GotSpouseQuoteFormMsg

                    _ ->
                        viewNothing

                -- CLIENT FORM MODALS
                , case model.client of
                    Searching searching ->
                        case searching.newClientForm of
                            Just newClientForm ->
                                ClientForm.view
                                    { title = "New client"
                                    , buttonText = "Create client"
                                    , model = newClientForm
                                    }
                                    |> Html.map GotClientFormMsg

                            Nothing ->
                                viewNothing

                    Success success ->
                        case success.editClientForm of
                            Just editClientForm ->
                                ClientForm.view
                                    { title = "Update client"
                                    , buttonText = "Update client"
                                    , model = editClientForm
                                    }
                                    |> Html.map GotEditClientFormMsg

                            Nothing ->
                                viewNothing

                -- SPOUSE FORM MODALS
                , case ( model.client, model.spouse ) of
                    ( Success _, Just (Searching searching) ) ->
                        case searching.newClientForm of
                            Just newClientForm ->
                                ClientForm.view
                                    { title = "New client"
                                    , buttonText = "Create client"
                                    , model = newClientForm
                                    }
                                    |> Html.map GotNewSpouseFormMsg

                            Nothing ->
                                viewNothing

                    ( Success _, Just (Success success) ) ->
                        case success.editClientForm of
                            Just editClientForm ->
                                ClientForm.view
                                    { title = "Update client"
                                    , buttonText = "Update client"
                                    , model = editClientForm
                                    }
                                    |> Html.map GotEditSpouseFormMsg

                            Nothing ->
                                viewNothing

                    _ ->
                        viewNothing

                -- SUBMIT BUTTONS
                , viewSubmitButtons model
                ]

            RemoteData.Failure (Server.WebrpcError Server.EntityNotFound _) ->
                [ UI.Alert.error "The quote you're looking for could not be found."
                ]

            RemoteData.Failure _ ->
                [ UI.Alert.error "Whoops, an error occurred."
                ]
    }


viewClient : Server.Client -> Html Msg
viewClient client =
    let
        fullName =
            client.firstName ++ " " ++ client.lastName

        dateOfBirth =
            client.dateOfBirth
                |> Date.fromIsoString
                |> Result.map (Date.format "MMMM d, y")
                |> Result.withDefault ""

        dateAndAge =
            dateOfBirth ++ " " ++ "(Age " ++ String.fromInt client.age ++ ")"

        location =
            client.zipCode ++ ", " ++ client.county.name ++ ", " ++ client.county.stateAlphaCode

        tobacco =
            if client.isTobaccoUser then
                "Tobacco user"

            else
                "Non-tobacco user"
    in
    div [ class "text-gray-500" ]
        [ div [] [ text fullName ]
        , div [] [ text dateAndAge ]
        , div [] [ text location ]
        , div [] [ text tobacco ]
        ]


viewTabs : Model -> Html Msg
viewTabs model =
    let
        viewTabs_ children =
            div [ class "border-b border-gray-300 flex gap-7 items-center mb-12" ] children

        viewTab tab client =
            div
                [ classList
                    [ ( "py-2 cursor-pointer border-b-[3px] font-semibold", True )
                    , ( "border-[var(--brand-color)] text-[var(--brand-color)]", model.selectedTab == tab )
                    , ( "border-white text-gray-500", model.selectedTab /= tab )
                    ]
                , onClick (ClickedTab tab)
                ]
                [ text (client.firstName ++ " " ++ client.lastName) ]
    in
    case ( model.client, model.spouse ) of
        ( Success client, Just (Success spouse) ) ->
            viewTabs_
                [ viewTab TabClient client.client
                , viewTab TabSpouse spouse.client
                ]

        _ ->
            viewNothing


viewSubmitButtons : Model -> Html Msg
viewSubmitButtons model =
    let
        isEnabled =
            case ( model.client, model.spouse ) of
                ( Searching _, _ ) ->
                    False

                ( Success client, Nothing ) ->
                    QuoteForm.isValid client.quoteForm

                ( Success client, Just (Searching _) ) ->
                    True

                ( Success client, Just (Success spouse) ) ->
                    QuoteForm.isValid client.quoteForm && QuoteForm.isValid spouse.quoteForm

        isDisabled =
            not isEnabled

        buildErrorMessage client =
            div [ class "text-red-600 text-right" ] [ text (client.firstName ++ " " ++ client.lastName ++ " quote incomplete") ]

        errorMessage =
            case model.client of
                Searching _ ->
                    viewNothing

                Success client ->
                    if not <| QuoteForm.isValid client.quoteForm then
                        buildErrorMessage client.client

                    else
                        case model.spouse of
                            Just (Success spouse) ->
                                if not <| QuoteForm.isValid spouse.quoteForm then
                                    buildErrorMessage spouse.client

                                else
                                    viewNothing

                            Just (Searching _) ->
                                viewNothing

                            Nothing ->
                                viewNothing
    in
    div [ class "w-full space-y-2" ]
        [ errorMessage
        , div [ class "flex items-center justify-end space-x-3" ]
            [ label [ class "block" ]
                [ input [ type_ "checkbox", checked model.redirectToQuoteReview, onClick ClickedRedirectToPublicQuote ] []
                , span [ class "ml-1" ] [ text "Go to quote review" ]
                ]
            , UI.Button.new "Update quote"
                |> UI.Button.withType (UI.Button.Button SubmittedForm)
                |> UI.Button.withDisabled isDisabled
                |> UI.Button.withOptionalIcon UI.Icon.Loading4Animated model.isSubmitting
                |> UI.Button.view
            ]
        ]


viewNothing : Html msg
viewNothing =
    text ""



-- INTERNAL


areQuoteFormsValid : Model -> Bool
areQuoteFormsValid model =
    case ( model.client, model.spouse ) of
        ( Success client, Nothing ) ->
            QuoteForm.isValid client.quoteForm

        ( Success client, Just (Success spouse) ) ->
            QuoteForm.isValid client.quoteForm && QuoteForm.isValid spouse.quoteForm

        _ ->
            False

================
File: frontend/src/Pages/Quotes/UrlId_/Review.elm
================
module Pages.Quotes.UrlId_.Review exposing (Model, Msg, page)

import Date
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Page exposing (Page)
import RemoteData exposing (RemoteData)
import Route exposing (Route)
import Server
import Shared
import Time
import UI.Button
import UI.Cents
import UI.Icon
import View exposing (View)


page : Shared.Model -> Route { urlId : String } -> Page Model Msg
page shared route =
    Page.new
        { init = init route
        , update = update route
        , subscriptions = subscriptions
        , view = view shared
        }



-- INIT


type alias ServerData a =
    RemoteData Server.Error a


type alias Model =
    { clientQuote : ServerData Server.Quote
    , clientSupplementalQuotes : ServerData (List Server.SupplementalQuote)
    , spouseQuote : ServerData Server.Quote
    , spouseSupplementalQuotes : ServerData (List Server.SupplementalQuote)
    , selectedTab : Person
    }


type Person
    = Client
    | Spouse


init : Route { urlId : String } -> () -> ( Model, Effect Msg )
init route () =
    ( { clientQuote = RemoteData.Loading
      , clientSupplementalQuotes = RemoteData.Loading
      , spouseQuote = RemoteData.Loading
      , spouseSupplementalQuotes = RemoteData.Loading
      , selectedTab = Client
      }
    , Effect.batch
        [ Server.public.getQuote route.params.urlId
            |> Server.send CompletedGetClientQuote
            |> Effect.sendCmd
        , Server.public.getSpouseQuote route.params.urlId
            |> Server.send CompletedGetSpouseQuote
            |> Effect.sendCmd
        , Server.public.listSupplementalQuotesForQuote route.params.urlId
            |> Server.send CompletedListSupplementalQuotesForClientQuote
            |> Effect.sendCmd
        ]
    )



-- UPDATE


type Msg
    = ClickedTab Person
    | ClickedReloadSupplementalQuotes
    | CompletedGetClientQuote (Result Server.Error Server.Quote)
    | CompletedGetSpouseQuote (Result Server.Error Server.Quote)
    | CompletedListSupplementalQuotesForClientQuote (Result Server.Error (List Server.SupplementalQuote))
    | CompletedListSupplementalQuotesForSpouseQuote (Result Server.Error (List Server.SupplementalQuote))


update : Route { urlId : String } -> Msg -> Model -> ( Model, Effect Msg )
update route msg model =
    let
        noop =
            ( model, Effect.none )
    in
    case msg of
        ClickedTab tab ->
            ( { model | selectedTab = tab }
            , Effect.none
            )

        ClickedReloadSupplementalQuotes ->
            case ( model.selectedTab, model.spouseQuote ) of
                ( Client, _ ) ->
                    ( { model | clientSupplementalQuotes = RemoteData.Loading }
                    , Server.public.getQuote route.params.urlId
                        |> Server.send CompletedGetClientQuote
                        |> Effect.sendCmd
                    )

                ( Spouse, RemoteData.Success spouseQuote ) ->
                    ( { model | spouseSupplementalQuotes = RemoteData.Loading }
                    , Server.public.listSupplementalQuotesForQuote spouseQuote.urlId
                        |> Server.send CompletedListSupplementalQuotesForSpouseQuote
                        |> Effect.sendCmd
                    )

                ( Spouse, _ ) ->
                    ( model, Effect.none )

        CompletedGetClientQuote result ->
            ( { model | clientQuote = RemoteData.fromResult result }
            , Effect.none
            )

        CompletedGetSpouseQuote (Ok quote) ->
            ( { model | spouseQuote = RemoteData.Success quote }
            , Server.public.listSupplementalQuotesForQuote quote.urlId
                |> Server.send CompletedListSupplementalQuotesForSpouseQuote
                |> Effect.sendCmd
            )

        CompletedGetSpouseQuote (Err (Server.WebrpcError Server.EntityNotFound _)) ->
            ( { model
                | spouseQuote = RemoteData.NotAsked
                , spouseSupplementalQuotes = RemoteData.NotAsked
              }
            , Effect.none
            )

        CompletedGetSpouseQuote (Err e) ->
            ( { model
                | spouseQuote = RemoteData.Failure e
                , spouseSupplementalQuotes = RemoteData.NotAsked
              }
            , Effect.none
            )

        CompletedListSupplementalQuotesForClientQuote result ->
            ( { model | clientSupplementalQuotes = RemoteData.fromResult result }
            , Effect.none
            )

        CompletedListSupplementalQuotesForSpouseQuote result ->
            ( { model | spouseSupplementalQuotes = RemoteData.fromResult result }
            , Effect.none
            )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none



-- VIEW


type SupLineItemType
    = SupplementalPlan
    | PrescriptionPlan
    | DentalHearingVisionPlan
    | PartBPremium
    | PartBIrmaa
    | PartDIrmaa


type alias SupLineItem =
    { type_ : SupLineItemType
    , rateCents : Int
    }


view : Shared.Model -> Model -> View Msg
view shared model =
    { title = "Review"
    , body =
        [ div [ class "max-w-5xl mx-auto py-12 px-6 text-base" ]
            (case model.clientQuote of
                RemoteData.NotAsked ->
                    []

                RemoteData.Loading ->
                    [ div [ class "flex justify-center text-gray-300 " ]
                        [ UI.Icon.new UI.Icon.Loading4Animated
                            |> UI.Icon.withSize 60
                            |> UI.Icon.withStrokeWidth 1
                            |> UI.Icon.view
                        ]
                    ]

                RemoteData.Success clientQuote ->
                    [ -- HEADER
                      div [ class "flex items-start flex-col sm:flex-row gap-y-8 mb-8" ]
                        [ -- LOGO
                          img [ src "/medicare_school_com_logo.svg", class "w-48" ] []

                        -- AGENT CONTACT DETAILS
                        , viewAgent clientQuote
                        ]

                    -- TITLE
                    , div [ class "text-5xl font-bold mb-14" ] [ text "Quote" ]

                    -- TABS
                    , case model.spouseQuote of
                        RemoteData.Success spouseQuote ->
                            viewTabs clientQuote spouseQuote model.selectedTab

                        _ ->
                            viewNothing

                    -- QUOTE DETAILS
                    , case ( model.selectedTab, model.spouseQuote ) of
                        ( Spouse, RemoteData.Success spouseQuote ) ->
                            viewQuoteDetails shared.zone spouseQuote

                        _ ->
                            viewQuoteDetails shared.zone clientQuote

                    -- SUPPLEMENTAL QUOTES
                    , case ( model.selectedTab, model.spouseQuote ) of
                        ( Client, _ ) ->
                            viewSupplementalQuotes clientQuote model.clientSupplementalQuotes

                        ( Spouse, RemoteData.Success spouseQuote ) ->
                            viewSupplementalQuotes spouseQuote model.spouseSupplementalQuotes

                        _ ->
                            viewNothing
                    ]

                RemoteData.Failure (Server.WebrpcError Server.EntityNotFound _) ->
                    [ viewError "The quote you’re looking for could not be found." ]

                RemoteData.Failure _ ->
                    [ viewError "Whoops, an error occured." ]
            )
        ]
    }


viewAgent : Server.Quote -> Html Msg
viewAgent quote =
    let
        name =
            quote.agent.firstName ++ " " ++ quote.agent.lastName

        email =
            quote.agent.email

        phone =
            quote.agent.phone
                ++ (case quote.agent.phoneExt of
                        Just ext ->
                            String.fromChar noBreakSpace ++ " ext " ++ String.fromInt ext

                        Nothing ->
                            ""
                   )

        noBreakSpace : Char
        noBreakSpace =
            '\u{00A0}'
    in
    div [ class "sm:ml-auto text-gray-800" ]
        [ div [ class "whitespace-nowrap" ] [ text name ]
        , div [ class "whitespace-nowrap" ] [ text email ]
        , div [ class "whitespace-nowrap" ] [ text phone ]
        ]


viewTabs : Server.Quote -> Server.Quote -> Person -> Html Msg
viewTabs quote spouseQuote currentTab =
    let
        clientName =
            quote.client.firstName ++ " " ++ quote.client.lastName

        spouseName =
            spouseQuote.client.firstName ++ " " ++ spouseQuote.client.lastName

        viewTab tab label =
            div
                [ classList
                    [ ( "w-1/2 flex items-center justify-center border text-base font-medium relative cursor-pointer px-3", True )
                    , ( "text-[var(--brand-color)] border-[var(--brand-color)] pt-3 pb-[9px] border-b-4", tab == currentTab )
                    , ( "text-gray-800 border-gray-300 py-3", tab /= currentTab )
                    , ( "rounded-l-lg", tab == Client )
                    , ( "rounded-r-lg", tab == Spouse )
                    ]
                , onClick (ClickedTab tab)
                ]
                [ div [ class "truncate" ] [ text label ]
                , div
                    [ classList
                        [ ( "absolute inset-0 bg-[var(--brand-color)] opacity-5 z-10 pointer-events-none", True )
                        , ( "hidden", tab /= currentTab )
                        ]
                    ]
                    []
                ]
    in
    div [ class "flex mb-12" ]
        [ viewTab Client clientName
        , viewTab Spouse spouseName
        ]


viewQuoteDetails : Time.Zone -> Server.Quote -> Html Msg
viewQuoteDetails zone quote =
    let
        client =
            quote.client

        clientGender =
            case client.gender of
                Server.GenderMale ->
                    "M"

                Server.GenderFemale ->
                    "F"

        clientAge =
            String.fromInt client.age

        clientNameLine =
            client.firstName ++ " " ++ client.lastName ++ " (" ++ clientGender ++ ", " ++ clientAge ++ "yrs)"

        clientStateAndZipLine =
            client.county.stateAlphaCode ++ ", " ++ client.zipCode

        effectiveDate =
            Date.fromPosix zone quote.effectiveDate |> Date.format "MMMM y"

        dentalQuoteAnnualBenefits q =
            UI.Cents.toString q.annualBenefitCents ++ " annual benefit"

        heading text_ =
            div [ class "text-[13px] text-gray-500 leading-6" ] [ text text_ ]

        content text_ =
            div [ class "text-base text-gray-800 truncate" ] [ text text_ ]
    in
    div [ class "grid grid-cols-1 sm:grid-cols-2 gap-6 border border-gray-300 rounded-lg text-base text-gray-800 mb-12 p-5" ]
        [ -- LEFT COL
          div [ class "space-y-6" ]
            [ div []
                [ heading "Quote for"
                , content clientNameLine
                , content clientStateAndZipLine
                ]
            , div []
                [ heading "Effective date"
                , content effectiveDate
                ]
            , if quote.hasMultiInsuredDiscount || quote.hasLivingWithSomeoneDiscount then
                div []
                    [ heading "Discount"
                    , if quote.hasMultiInsuredDiscount then
                        content "Multi insured discount"

                      else
                        viewNothing
                    , if quote.hasLivingWithSomeoneDiscount then
                        content "Living with someone discount"

                      else
                        viewNothing
                    ]

              else
                viewNothing
            ]

        -- RIGHT COL
        , div [ class "space-y-6" ]
            [ case quote.drugQuote of
                Just drugQuote ->
                    div []
                        [ heading "Prescription drug plan"
                        , content drugQuote.companyName
                        , content drugQuote.planName
                        ]

                Nothing ->
                    viewNothing
            , case quote.dentalQuote of
                Just dentalQuote ->
                    div []
                        [ heading "Dental, vision & hearing plan"
                        , content dentalQuote.carrierName
                        , content (dentalQuoteAnnualBenefits dentalQuote)
                        ]

                Nothing ->
                    viewNothing
            ]
        ]


viewSupplementalQuotes : Server.Quote -> ServerData (List Server.SupplementalQuote) -> Html Msg
viewSupplementalQuotes quote supplementalQuotes =
    case supplementalQuotes of
        RemoteData.NotAsked ->
            viewNothing

        RemoteData.Loading ->
            div [ class "flex justify-center text-gray-300 py-10" ]
                [ UI.Icon.new UI.Icon.Loading4Animated
                    |> UI.Icon.withSize 80
                    |> UI.Icon.view
                ]

        --
        RemoteData.Success supplementalQuotes_ ->
            viewSupplementalQuoteGroups quote supplementalQuotes_

        RemoteData.Failure _ ->
            div [ class "flex items-center gap-3 rounded-lg border border-red-300 p-5" ]
                [ div [ class "flex-none text-red-700" ]
                    [ UI.Icon.new UI.Icon.AlertTriangle
                        |> UI.Icon.withSize 20
                        |> UI.Icon.view
                    ]
                , div [ class "grow text-red-700" ]
                    [ div [] [ text "Something went wrong while loading your supplemental quotes." ]
                    ]
                , UI.Button.new "Reload"
                    |> UI.Button.withStyle UI.Button.Secondary
                    |> UI.Button.withSize UI.Button.Small
                    |> UI.Button.withType (UI.Button.Button ClickedReloadSupplementalQuotes)
                    |> UI.Button.view
                ]


viewLoadingSupplementalQuotes : Html msg
viewLoadingSupplementalQuotes =
    let
        viewHeading =
            div [ class "rounded-full h-5 w-40 bg-gray-200" ] []

        viewQuote =
            div [ class "outline outline-offset-0 outline-1 outline-gray-200 rounded-lg bg-white min-w-72 px-5 py-5" ]
                [ div [ class "rounded-full h-4 w-full bg-gray-200 mb-[16px]" ] []
                , div [ class "space-y-4" ]
                    [ viewLineItem
                    , viewLineItem
                    , viewLineItem
                    , viewLineItem
                    , viewLineItem
                    , viewLineItem
                    ]
                ]

        viewLineItem =
            div [ class "flex items-center" ]
                [ div [ class "rounded-full h-2 w-1/2 bg-gray-200" ] []
                , div [ class "ml-auto rounded-full h-2 w-1/6 bg-gray-200" ] []
                ]

        viewQuoteGroup =
            div [ class "space-y-4" ]
                [ viewHeading
                , div [ class "grid grid-cols-supquote gap-4" ]
                    [ viewQuote
                    , viewQuote
                    , viewQuote
                    ]
                ]
    in
    div [ class "animate-pulse space-y-10" ]
        [ viewQuoteGroup
        , viewQuoteGroup
        , viewQuoteGroup
        ]


viewSupplementalQuoteGroups : Server.Quote -> List Server.SupplementalQuote -> Html Msg
viewSupplementalQuoteGroups quote supplementalQuotes =
    let
        quotesByPlanType planType =
            List.filter (\sq -> sq.planType == planType) supplementalQuotes

        viewQuoteGroup planType =
            if not (List.isEmpty (quotesByPlanType planType)) then
                div [ class "space-y-4" ]
                    [ div [ class "font-medium text-gray-950 text-xl" ] [ text ("Plan " ++ planTypeToString planType ++ " Monthly Premiums") ]
                    , div [ class "grid grid-cols-supquote gap-4" ]
                        (List.map (viewSupplementalQuote quote) (quotesByPlanType planType))
                    ]

            else
                viewNothing
    in
    div [ class "space-y-10" ]
        [ viewQuoteGroup Server.SupplementalPlanTypeG
        , viewQuoteGroup Server.SupplementalPlanTypeN
        , viewQuoteGroup Server.SupplementalPlanTypeF
        ]


viewSupplementalQuote : Server.Quote -> Server.SupplementalQuote -> Html Msg
viewSupplementalQuote quote supplementalQuote =
    let
        logoUrl =
            supplementalQuote.carrier.logoUrl

        carrierName =
            supplementalQuote.carrier.name

        planType =
            supplementalQuote.planType

        drugQuote =
            quote.drugQuote

        dentalQuote =
            quote.dentalQuote

        irmaaBracket =
            quote.irmaaBracket

        supplementalPlanRateCents =
            if quote.hasMultiInsuredDiscount && supplementalQuote.multiInsuredDiscountRateCents /= Nothing then
                supplementalQuote.multiInsuredDiscountRateCents
                    |> Maybe.withDefault 0

            else if quote.hasLivingWithSomeoneDiscount && supplementalQuote.livingWithSomeoneDiscountRateCents /= Nothing then
                supplementalQuote.livingWithSomeoneDiscountRateCents
                    |> Maybe.withDefault 0

            else
                supplementalQuote.monthlyRateCents

        byZeroCentsRule item =
            case item.type_ of
                SupplementalPlan ->
                    True

                PrescriptionPlan ->
                    True

                DentalHearingVisionPlan ->
                    True

                PartBPremium ->
                    True

                PartBIrmaa ->
                    item.rateCents > 0

                PartDIrmaa ->
                    item.rateCents > 0

        addItem item items_ =
            item :: items_

        addMaybeItem maybeItem items_ =
            case maybeItem of
                Just item ->
                    addItem item items_

                Nothing ->
                    items_

        items =
            ([]
                |> addItem (SupLineItem SupplementalPlan supplementalPlanRateCents)
                |> addMaybeItem (drugQuote |> Maybe.map .monthlyRateCents |> Maybe.map (SupLineItem PrescriptionPlan))
                |> addMaybeItem (dentalQuote |> Maybe.map .monthlyRateCents |> Maybe.map (SupLineItem DentalHearingVisionPlan))
                |> addItem (SupLineItem PartBPremium irmaaBracket.partBMonthlyPremiumCents)
                |> addItem (SupLineItem PartBIrmaa irmaaBracket.partBIrmaaCents)
                |> addItem (SupLineItem PartDIrmaa irmaaBracket.partDIrmaaCents)
            )
                |> List.filter byZeroCentsRule
                |> List.reverse

        totalcents =
            items
                |> List.map .rateCents
                |> List.sum

        viewItem item =
            let
                label =
                    case item.type_ of
                        SupplementalPlan ->
                            "Supplemental plan"

                        PrescriptionPlan ->
                            "Prescription plan"

                        DentalHearingVisionPlan ->
                            "Dental hearing vision plan"

                        PartBPremium ->
                            "Part B premium"

                        PartBIrmaa ->
                            "Part B IRMAA"

                        PartDIrmaa ->
                            "Part D IRMAA"
            in
            div [ class "flex items-center text-[13px] text-gray-500 leading-6" ]
                [ div [] [ text label ]
                , div [ class "ml-auto tabular-nums" ] [ text (UI.Cents.toString item.rateCents) ]
                ]

        viewTotal cents =
            div [ class "flex items-center font-medium text-[13px] text-800" ]
                [ div [ class "uppercase" ] [ text "Total" ]
                , div [ class "ml-auto tabular-nums" ] [ text (UI.Cents.toString cents) ]
                ]
    in
    div [ class "outline outline-offset-0 outline-1 outline-gray-300 rounded-lg bg-white min-w-72" ]
        [ -- PLAN TYPE TAG
          div [ class "px-3 pt-2" ]
            [ div [ class "relative inline-block" ]
                [ div [ class "px-2 py-px text-xs font-medium text-[var(--brand-color)] z-20" ] [ text ("Plan " ++ planTypeToString planType) ]
                , div [ class "absolute inset-0 z-10 bg-[var(--brand-color)] opacity-15 rounded-full" ] []
                ]
            ]

        -- CARRIER LOGO OR COMPANY NAME TEXT
        , case logoUrl of
            Just logoUrl_ ->
                img [ class "h-20 px-5 mb-4 w-full object-contain", src logoUrl_ ] []

            Nothing ->
                div [ class "flex items-center justify-center h-20 px-5 mb-4 w-full leading-6 text-center text-xl font-bold text-[var(--brand-dark-color)] overflow-hidden" ] [ text carrierName ]

        -- LINE ITEMS
        , div [ class "space-y-1 px-5 pb-3" ]
            (List.map viewItem items ++ [ viewTotal totalcents ])
        ]


viewError : String -> Html msg
viewError message =
    div [ class "fixed inset-0 p-5 flex items-center justify-center" ]
        [ div [ class "text-gray-800" ]
            [ div [ class "flex justify-center" ]
                [ UI.Icon.new UI.Icon.AlertTriangle
                    |> UI.Icon.withSize 30
                    |> UI.Icon.view
                ]
            , div [ class "font-semibold text-xl text-center" ] [ text message ]
            ]
        ]


viewNothing : Html msg
viewNothing =
    text ""



-- INTERNAL


planTypeToString : Server.SupplementalPlanType -> String
planTypeToString planType =
    case planType of
        Server.SupplementalPlanTypeF ->
            "F"

        Server.SupplementalPlanTypeG ->
            "G"

        Server.SupplementalPlanTypeN ->
            "N"

================
File: frontend/src/Pages/Quotes/Id_.elm
================
module Pages.Quotes.Id_ exposing (Model, Msg, page)

import Auth
import Date
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Layouts
import Page exposing (Page)
import PagesExt.Quotes.Id_.SendModal as SendModal
import RemoteData exposing (RemoteData)
import Route exposing (Route)
import Route.Path
import Server
import Shared
import Time
import UI.Alert
import UI.Button
import UI.Cents
import UI.Icon
import UI.Quote
import UI.Time
import Url
import View exposing (View)


page : Auth.User -> Shared.Model -> Route { id : String } -> Page Model Msg
page user shared route =
    Page.new
        { init = init route
        , update = update
        , subscriptions = subscriptions
        , view = view shared route
        }
        |> Page.withLayout (toLayout user)


toLayout : Auth.User -> Model -> Layouts.Layout Msg
toLayout user model =
    Layouts.Default
        { agent = user
        }



-- INIT


type alias Model =
    { quote : RemoteData Server.Error Server.Quote
    , spouseQuote : RemoteData Server.Error Server.Quote
    , dentalQuote : RemoteData Server.Error Server.DentalQuote
    , supplementalQuotes : RemoteData Server.Error (List Server.SupplementalQuote)
    , sendModal : SendModal.Model
    }


init : Route { id : String } -> () -> ( Model, Effect Msg )
init route () =
    let
        quoteId =
            route.params.id
                |> String.toInt
                |> Maybe.withDefault 0
    in
    ( { quote = RemoteData.Loading
      , spouseQuote = RemoteData.Loading
      , dentalQuote = RemoteData.Loading
      , supplementalQuotes = RemoteData.Loading
      , sendModal = SendModal.new
      }
    , Effect.batch
        [ Server.dashboard.getQuote quoteId
            |> Server.send CompletedGetQuote
            |> Effect.sendCmd
        , Server.dashboard.getSpouseQuote quoteId
            |> Server.send CompletedGetSpouseQuote
            |> Effect.sendCmd
        , Server.dashboard.listSupplementalQuotesForQuote quoteId
            |> Server.send CompletedListSupplementalQuotesForQuote
            |> Effect.sendCmd
        ]
    )



-- UPDATE


type Msg
    = ClickedSend
    | CompletedGetDentalQuoteForQuote (Result Server.Error Server.DentalQuote)
    | CompletedGetSpouseQuote (Result Server.Error Server.Quote)
    | CompletedGetQuote (Result Server.Error Server.Quote)
    | CompletedListSupplementalQuotesForQuote (Result Server.Error (List Server.SupplementalQuote))
    | GotSendModalMsg SendModal.Msg


update : Msg -> Model -> ( Model, Effect Msg )
update msg model =
    case msg of
        ClickedSend ->
            let
                ( sendModal, sendModalEffect ) =
                    SendModal.show
            in
            ( { model | sendModal = sendModal }
            , Effect.map GotSendModalMsg sendModalEffect
            )

        CompletedGetDentalQuoteForQuote result ->
            ( { model | dentalQuote = RemoteData.fromResult result }
            , Effect.none
            )

        CompletedGetSpouseQuote result ->
            ( { model | spouseQuote = RemoteData.fromResult result }
            , Effect.none
            )

        CompletedGetQuote result ->
            ( { model | quote = RemoteData.fromResult result }
            , Effect.none
            )

        CompletedListSupplementalQuotesForQuote result ->
            ( { model | supplementalQuotes = RemoteData.fromResult result }
            , Effect.none
            )

        GotSendModalMsg sendModalMsg ->
            case model.quote of
                RemoteData.Success quote ->
                    let
                        ( sendModal, sendModalEffect ) =
                            SendModal.update quote sendModalMsg model.sendModal
                    in
                    ( { model | sendModal = sendModal }
                    , Effect.map GotSendModalMsg sendModalEffect
                    )

                _ ->
                    ( model
                    , Effect.none
                    )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none



-- VIEW


view : Shared.Model -> Route { id : String } -> Model -> View Msg
view shared route model =
    { title = "Quote"
    , body =
        case model.quote of
            RemoteData.NotAsked ->
                []

            RemoteData.Loading ->
                [ div [ class "w-full text-gray-300 flex justify-center my-10" ]
                    [ UI.Icon.new UI.Icon.Loading4Animated
                        |> UI.Icon.withSize 24
                        |> UI.Icon.withStrokeWidth 2
                        |> UI.Icon.view
                    ]
                ]

            RemoteData.Success quote ->
                let
                    clientName =
                        quote.client.firstName ++ " " ++ quote.client.lastName

                    clientId =
                        quote.client.id |> String.fromInt

                    clientEmailOrName =
                        case quote.client.email of
                            Just email ->
                                email

                            Nothing ->
                                clientName

                    spouseName =
                        model.spouseQuote
                            |> RemoteData.map (\q -> q.client.firstName ++ " " ++ q.client.lastName)
                            |> RemoteData.withDefault "--"

                    effectiveDate =
                        quote.effectiveDate
                            |> Date.fromPosix Time.utc
                            |> Date.format "MMMM y"

                    publicQuotePath =
                        Route.Path.toString (Route.Path.Quotes_UrlId__Review { urlId = quote.urlId })

                    publicQuoteURL =
                        let
                            protocol =
                                case route.url.protocol of
                                    Url.Http ->
                                        "http://"

                                    Url.Https ->
                                        "https://"

                            port_ =
                                case route.url.port_ of
                                    Just p ->
                                        ":" ++ String.fromInt p

                                    Nothing ->
                                        ""
                        in
                        protocol ++ route.url.host ++ port_ ++ Route.Path.toString (Route.Path.Quotes_UrlId__Review { urlId = quote.urlId })

                    created =
                        UI.Time.posixToString shared.zone quote.createdAt

                    updated =
                        UI.Time.posixToString shared.zone quote.updatedAt
                in
                [ -- HEADER
                  div [ class "flex items-center space-x-3 pb-8" ]
                    [ -- TITLE
                      div [ class "grow" ]
                        [ a [ class "text-[var(--brand-color)] font-semibold", Route.Path.href Route.Path.Quotes ] [ text "Quotes" ]
                        , div [ class "text-3xl font-bold" ] [ text (UI.Quote.quoteNumber quote.id) ]
                        , div []
                            [ span [ class "text-gray-500" ] [ text "Created for " ]
                            , a [ class "text-[var(--brand-color)]", Route.Path.href (Route.Path.Clients_Id_ { id = clientId }) ] [ text clientEmailOrName ]
                            ]
                        ]

                    -- ACTION BUTTONS
                    , UI.Button.new "Send"
                        |> UI.Button.withIcon UI.Icon.Send1
                        |> UI.Button.withStyle UI.Button.Secondary
                        |> UI.Button.withType (UI.Button.Button ClickedSend)
                        |> UI.Button.view
                    , UI.Button.new "Edit"
                        |> UI.Button.withIcon UI.Icon.Edit2
                        |> UI.Button.withStyle UI.Button.Secondary
                        |> UI.Button.withType (UI.Button.Link (Route.Path.toString (Route.Path.Quotes_Id__Edit { id = route.params.id })))
                        |> UI.Button.view
                    ]
                , div [ class "flex gap-8" ]
                    [ -- LEFT COLUMN
                      div [ class "grow space-y-8" ]
                        [ -- SUMMARY
                          div []
                            [ div [ class "border-b border-gray-300 font-semibold text-xl pb-4 mb-6" ] [ text "Summary" ]
                            , div [ class "grid grid-cols-2 gap-[1.3125rem]" ]
                                [ div []
                                    [ div [ class "font-semibold" ] [ text "Quote for" ]
                                    , a
                                        [ class "text-[var(--brand-color)]"
                                        , Route.Path.href (Route.Path.Clients_Id_ { id = clientId })
                                        ]
                                        [ text clientEmailOrName ]
                                    ]
                                , div []
                                    [ div [ class "font-semibold" ] [ text "Spouse" ]
                                    , div [] [ text spouseName ]
                                    ]
                                , div []
                                    [ div [ class "font-semibold" ] [ text "Quote number" ]
                                    , div [] [ text (UI.Quote.quoteNumber quote.id) ]
                                    ]
                                , div []
                                    [ div [ class "font-semibold" ] [ text "Effective date" ]
                                    , div [] [ text effectiveDate ]
                                    ]
                                ]
                            ]

                        -- PLANS
                        , div []
                            [ div [ class "border-b border-gray-300 font-semibold text-xl pb-4 mb-6" ] [ text "Plans" ]
                            , div [ class "grid grid-cols-2 gap-[1.3125rem]" ]
                                [ div []
                                    [ div [ class "font-semibold" ] [ text "Supplemental plan comparison" ]
                                    , case model.supplementalQuotes of
                                        RemoteData.NotAsked ->
                                            viewNothing

                                        RemoteData.Loading ->
                                            div [] [ UI.Icon.default UI.Icon.Loading4Animated ]

                                        RemoteData.Success supQuotes ->
                                            if List.isEmpty supQuotes then
                                                div [] [ text "None" ]

                                            else
                                                ol [ class "list-decimal list-inside space-y-[1.3125rem]" ] (viewSupplementalQuotes supQuotes)

                                        RemoteData.Failure _ ->
                                            viewNothing
                                    ]
                                , div [ class "space-y-[1.3125rem]" ]
                                    [ -- DRUG PLAN
                                      div []
                                        [ div [ class "font-semibold" ] [ text "Prescription drug plan" ]
                                        , case quote.drugQuote of
                                            Just drugQuote ->
                                                div []
                                                    [ div [] [ text drugQuote.companyName ]
                                                    , div [] [ text drugQuote.planName ]
                                                    , div [] [ text (UI.Cents.toString drugQuote.monthlyRateCents) ]
                                                    ]

                                            Nothing ->
                                                div [] [ text "None" ]
                                        ]

                                    -- DENTAL PLAN
                                    , div []
                                        [ div [ class "font-semibold" ] [ text "Dental, vision & hearing plan" ]
                                        , case quote.dentalQuote of
                                            Just dentalQuote ->
                                                div []
                                                    [ div [] [ text dentalQuote.carrierName ]
                                                    , div [] [ text (UI.Cents.toString dentalQuote.annualBenefitCents ++ " annual benefit") ]
                                                    , div [] [ text (UI.Cents.toString dentalQuote.monthlyRateCents) ]
                                                    ]

                                            Nothing ->
                                                div [] [ text "None" ]
                                        ]
                                    ]
                                ]
                            ]
                        ]

                    -- RIGHT COLUMN
                    , div [ class "flex-none w-1/4" ]
                        [ div [ class "border-b border-gray-300 font-semibold text-xl pb-4 mb-6" ] [ text "Details" ]
                        , div [ class "grid grid-cols-1 gap-[1.3125rem]" ]
                            [ div []
                                [ div [ class "font-semibold" ] [ text "Review page" ]
                                , a [ class "block truncate text-[var(--brand-color)]", href publicQuotePath, target "_blank" ] [ text publicQuoteURL ]
                                ]
                            , div []
                                [ div [ class "font-semibold" ] [ text "Created" ]
                                , div [] [ text created ]
                                ]
                            , div []
                                [ div [ class "font-semibold" ] [ text "Updated" ]
                                , div [] [ text updated ]
                                ]
                            ]
                        ]
                    ]
                , SendModal.view quote model.sendModal |> Html.map GotSendModalMsg
                ]

            RemoteData.Failure (Server.WebrpcError Server.EntityNotFound _) ->
                [ UI.Alert.error "The quote you're looking for could not be found."
                ]

            RemoteData.Failure _ ->
                [ UI.Alert.error "Whoops, an error occurred."
                ]
    }


viewSupplementalQuotes : List Server.SupplementalQuote -> List (Html Msg)
viewSupplementalQuotes quotes =
    let
        planTypeToString planType =
            case planType of
                Server.SupplementalPlanTypeF ->
                    "F"

                Server.SupplementalPlanTypeG ->
                    "G"

                Server.SupplementalPlanTypeN ->
                    "N"

        carrierQuotes =
            let
                step : Server.SupplementalQuote -> List ( Server.SupplementalQuote, List Server.SupplementalQuote ) -> List ( Server.SupplementalQuote, List Server.SupplementalQuote )
                step quote groups =
                    case groups of
                        [] ->
                            [ ( quote, [] ) ]

                        ( first, firstRest ) :: rest ->
                            if quote.carrier.naic == first.carrier.naic then
                                ( quote, first :: firstRest ) :: rest

                            else
                                ( quote, [] ) :: ( first, firstRest ) :: rest
            in
            List.foldr step [] quotes

        viewCarrierQuote ( q, xq ) =
            let
                planTypeString =
                    q
                        :: xq
                        |> List.map .planType
                        |> List.map planTypeToString
                        |> String.join ", "
            in
            li []
                [ span [] [ text q.carrier.name ]
                , br [] []
                , span [] [ text ("Plan types: " ++ planTypeString) ]
                ]
    in
    List.map viewCarrierQuote carrierQuotes


viewNothing : Html msg
viewNothing =
    text ""

================
File: frontend/src/Pages/Quotes/New.elm
================
module Pages.Quotes.New exposing (Model, Msg, page)

import Auth
import Date
import Dict
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Layouts
import Modal.ClientForm as ClientForm
import Page exposing (Page)
import PagesExt.Quotes.New.ClientSearch as Search
import PagesExt.Quotes.New.Form as Form
import Route exposing (Route)
import Route.Path
import Server
import Shared
import UI.Button
import UI.Icon
import View exposing (View)


page : Auth.User -> Shared.Model -> Route () -> Page Model Msg
page agent shared route =
    Page.new
        { init = init route
        , update = update shared
        , subscriptions = subscriptions
        , view = view shared
        }
        |> Page.withLayout (toLayout agent)


toLayout : Auth.User -> Model -> Layouts.Layout Msg
toLayout agent model =
    Layouts.Default
        { agent = agent
        }



-- INIT


type alias Model =
    { client : ClientStatus
    , spouse : Maybe ClientStatus
    , selectedTab : Tab
    , isSubmitting : Bool
    , redirectToQuoteReview : Bool
    }


type ClientStatus
    = Searching
        { search : Search.Model
        , clientForm : Maybe ClientForm.Model
        }
    | Success
        { client : Server.Client
        , editClientForm : Maybe ClientForm.Model
        , form : Form.Model
        }


type Tab
    = TabClient
    | TabSpouse


init : Route () -> () -> ( Model, Effect Msg )
init route () =
    let
        clientId =
            Dict.get "clientId" route.query
                |> Maybe.andThen String.toInt

        getClient =
            case clientId of
                Just id ->
                    Server.dashboard.getClient id
                        |> Server.send CompletedPreloadClient
                        |> Effect.sendCmd

                Nothing ->
                    Effect.none
    in
    ( { client = Searching { search = Search.new, clientForm = Nothing }
      , spouse = Nothing
      , selectedTab = TabClient
      , isSubmitting = False
      , redirectToQuoteReview = False
      }
    , getClient
    )



-- UPDATE


type Msg
    = ClickedAddSpouse
    | ClickedChangeClient
    | ClickedChangeSpouse
    | ClickedRedirectToPublicQuote
    | ClickedTab Tab
    | CompletedCreateQuote (Result Server.Error Server.Quote)
    | CompletedPreloadClient (Result Server.Error Server.Client)
    | GotClientMsg ClientStatusMsg
    | GotSpouseMsg ClientStatusMsg
    | SubmittedForm


update : Shared.Model -> Msg -> Model -> ( Model, Effect Msg )
update shared msg model =
    let
        noop =
            ( model, Effect.none )
    in
    case msg of
        ClickedAddSpouse ->
            case model.client of
                Success detail ->
                    ( { model | spouse = Just (Searching { search = Search.new, clientForm = Nothing }) }
                    , Effect.none
                    )

                Searching _ ->
                    noop

        ClickedChangeClient ->
            case model.client of
                Success _ ->
                    ( { model
                        | client = Searching { search = Search.new, clientForm = Nothing }
                        , spouse = Nothing
                      }
                    , Effect.none
                    )

                Searching _ ->
                    noop

        ClickedChangeSpouse ->
            case model.spouse of
                Just (Success _) ->
                    ( { model
                        | spouse = Just (Searching { search = Search.new, clientForm = Nothing })
                        , selectedTab = TabClient
                      }
                    , Effect.none
                    )

                _ ->
                    noop

        ClickedRedirectToPublicQuote ->
            ( { model | redirectToQuoteReview = not model.redirectToQuoteReview }
            , Effect.none
            )

        ClickedTab tab ->
            ( { model | selectedTab = tab }
            , Effect.none
            )

        CompletedCreateQuote (Ok quote) ->
            let
                openQuoteReview =
                    if model.redirectToQuoteReview then
                        Effect.windowOpen (Route.Path.toString (Route.Path.Quotes_UrlId__Review { urlId = quote.urlId }))

                    else
                        Effect.none
            in
            ( { model
                | isSubmitting = False
                , redirectToQuoteReview = False
              }
            , Effect.batch
                [ openQuoteReview
                , Effect.pushRoutePath (Route.Path.Quotes_Id_ { id = String.fromInt quote.id })
                ]
            )

        CompletedCreateQuote (Err e) ->
            ( { model
                | isSubmitting = False
                , redirectToQuoteReview = False
              }
            , Effect.none
            )

        CompletedPreloadClient (Ok client) ->
            ( model, Effect.sendMsg (GotClientMsg (SelectedClient client)) )

        CompletedPreloadClient (Err e) ->
            noop

        GotClientMsg clientMsg ->
            let
                ( updatedClient, clientEffect ) =
                    updateClientStatus shared True clientMsg model.client
            in
            ( { model | client = updatedClient }
            , Effect.map GotClientMsg clientEffect
            )

        GotSpouseMsg spouseMsg ->
            case model.spouse of
                Just spouse ->
                    let
                        ( updatedSpouse, spouseEffect ) =
                            updateClientStatus shared False spouseMsg spouse
                    in
                    ( { model | spouse = Just updatedSpouse }
                    , Effect.map GotSpouseMsg spouseEffect
                    )

                Nothing ->
                    ( model, Effect.none )

        SubmittedForm ->
            case createQuote model of
                Just effect ->
                    ( { model | isSubmitting = True }
                    , effect
                    )

                Nothing ->
                    noop


createQuote : Model -> Maybe (Effect Msg)
createQuote model =
    let
        toQuoteSupplementalPlanType ( naic, planType ) =
            { carrierNaic = naic
            , planType = planType
            }

        valuesToClientParams client values =
            { clientId = client.id
            , effectiveDate = Date.toIsoString values.effectiveDate
            , irmaaBracketId = values.irmaaBracketId
            , drugQuoteId = values.drugQuoteId
            , supplementalCarrierPlanTypes = List.map toQuoteSupplementalPlanType values.supplementalPlans
            , dentalQuoteId = values.dentalQuoteId
            , hasMultiInsuredDiscount = values.hasMultiInsuredDiscount
            , hasLivingWithSomeoneDiscount = values.hasLivingWithSomeoneDiscount
            }

        clientParams =
            case model.client of
                Success success ->
                    case Form.export success.form of
                        Just values ->
                            Just (valuesToClientParams success.client values)

                        Nothing ->
                            Nothing

                Searching _ ->
                    Nothing

        spouseParams =
            case model.spouse of
                Just (Success success) ->
                    Form.export success.form
                        |> Maybe.map (valuesToClientParams success.client)

                _ ->
                    Nothing

        toEffect params =
            Server.dashboard.createQuote params spouseParams
                |> Server.send CompletedCreateQuote
                |> Effect.sendCmd
    in
    clientParams |> Maybe.map toEffect


type ClientStatusMsg
    = ClickedAddClient String
    | ClickedEditClient
    | GotFormMsg Form.Msg
    | GotClientFormMsg ClientForm.Msg
    | GotEditClientFormMsg ClientForm.Msg
    | GotSearchMsg Search.Msg
    | SelectedClient Server.Client


updateClientStatus : Shared.Model -> Bool -> ClientStatusMsg -> ClientStatus -> ( ClientStatus, Effect ClientStatusMsg )
updateClientStatus shared isClientPath msg clientStatus =
    let
        noop =
            ( clientStatus, Effect.none )

        newClientFormModalId =
            if isClientPath then
                "new_client_modal"

            else
                "new_spouse_modal"

        editClientFormModalId =
            if isClientPath then
                "edit_client_modal"

            else
                "edit_spouse_modal"
    in
    case ( msg, clientStatus ) of
        ( ClickedAddClient searchTerm, Searching details ) ->
            let
                clientFirstName =
                    searchTerm
                        |> String.split " "
                        |> List.head
                        |> Maybe.withDefault ""

                clientLastName =
                    searchTerm
                        |> String.split " "
                        |> List.drop 1
                        |> String.join " "

                ( clientForm, clientFormEffect ) =
                    ClientForm.new shared
                        newClientFormModalId
                        { firstName = Just clientFirstName
                        , lastName = Just clientLastName
                        , dateOfBirth = Nothing
                        , gender = Nothing
                        , zipCode = Nothing
                        , countyFipsCode = Nothing
                        , email = Nothing
                        , phone = Nothing
                        , isTobaccoUser = Nothing
                        }
            in
            ( Searching { details | clientForm = Just clientForm }
            , Effect.map GotClientFormMsg clientFormEffect
            )

        ( ClickedAddClient _, _ ) ->
            noop

        ( ClickedEditClient, Success details ) ->
            let
                ( clientForm, clientFormEffect ) =
                    ClientForm.new
                        shared
                        editClientFormModalId
                        { firstName = Just details.client.firstName
                        , lastName = Just details.client.lastName
                        , dateOfBirth = Just details.client.dateOfBirth
                        , gender = Just details.client.gender
                        , zipCode = Just details.client.zipCode
                        , countyFipsCode = Just details.client.county.fipsCode
                        , email = details.client.email
                        , phone = details.client.phone
                        , isTobaccoUser = Just details.client.isTobaccoUser
                        }
            in
            ( Success { details | editClientForm = Just clientForm }
            , Effect.map GotEditClientFormMsg clientFormEffect
            )

        ( ClickedEditClient, _ ) ->
            noop

        ( GotFormMsg formMsg, Success details ) ->
            let
                ( updatedForm, formEffect ) =
                    Form.update details.client formMsg details.form
            in
            ( Success { details | form = updatedForm }
            , Effect.map GotFormMsg formEffect
            )

        ( GotFormMsg _, _ ) ->
            noop

        ( GotClientFormMsg newClientFormMsg, Searching details ) ->
            case details.clientForm of
                Just clientForm ->
                    let
                        ( updatedNewClientForm, newClientFormEffect, createdClient ) =
                            ClientForm.update createClientFn isNewClientEmailTakenFn newClientFormMsg clientForm

                        selectedClientEffect =
                            case createdClient of
                                Just client ->
                                    Effect.sendMsg (SelectedClient client)

                                Nothing ->
                                    Effect.none
                    in
                    ( Searching { details | clientForm = Just updatedNewClientForm }
                    , Effect.batch
                        [ Effect.map GotClientFormMsg newClientFormEffect
                        , selectedClientEffect
                        ]
                    )

                Nothing ->
                    noop

        ( GotClientFormMsg _, _ ) ->
            noop

        ( GotEditClientFormMsg clientFormMsg, Success success ) ->
            case success.editClientForm of
                Just clientForm ->
                    let
                        ( updatedClientForm, clientFormEffects, storedClient ) =
                            ClientForm.update (updateClientFn success.client) (isExistingClientEmailTakenFn success.client) clientFormMsg clientForm

                        updatedClient =
                            case storedClient of
                                Just client ->
                                    client

                                Nothing ->
                                    success.client

                        editClientForm =
                            case storedClient of
                                Just client ->
                                    Nothing

                                Nothing ->
                                    Just updatedClientForm
                    in
                    ( Success
                        { success
                            | editClientForm = editClientForm
                            , client = updatedClient
                        }
                    , Effect.map GotEditClientFormMsg clientFormEffects
                    )

                Nothing ->
                    noop

        ( GotEditClientFormMsg _, _ ) ->
            noop

        ( GotSearchMsg searchMsg, Searching details ) ->
            let
                ( updatedSearch, searchEffect ) =
                    Search.update searchMsg details.search
            in
            ( Searching { details | search = updatedSearch }
            , Effect.map GotSearchMsg searchEffect
            )

        ( GotSearchMsg _, _ ) ->
            noop

        ( SelectedClient client, Searching details ) ->
            ( Success
                { client = client
                , editClientForm = Nothing
                , form = Form.empty shared
                }
            , Effect.none
            )

        ( SelectedClient _, _ ) ->
            noop


createClientFn : ClientForm.Values -> (Result Server.Error Server.Client -> ClientForm.Msg) -> Cmd ClientForm.Msg
createClientFn values toMsg =
    Server.dashboard.createClient values
        |> Server.send toMsg


isNewClientEmailTakenFn : String -> (Result Server.Error Bool -> ClientForm.Msg) -> Cmd ClientForm.Msg
isNewClientEmailTakenFn email toMsg =
    Server.dashboard.isClientEmailTaken email Nothing
        |> Server.send toMsg


updateClientFn : Server.Client -> ClientForm.Values -> (Result Server.Error Server.Client -> ClientForm.Msg) -> Cmd ClientForm.Msg
updateClientFn client values toMsg =
    Server.dashboard.updateClient
        { id = client.id
        , firstName = values.firstName
        , lastName = values.lastName
        , dateOfBirth = values.dateOfBirth
        , gender = values.gender
        , zipCode = values.zipCode
        , countyFipsCode = values.countyFipsCode
        , email = values.email
        , phone = values.phone
        , isTobaccoUser = values.isTobaccoUser
        }
        |> Server.send toMsg


isExistingClientEmailTakenFn : Server.Client -> String -> (Result Server.Error Bool -> ClientForm.Msg) -> Cmd ClientForm.Msg
isExistingClientEmailTakenFn client email toMsg =
    Server.dashboard.isClientEmailTaken email (Just client.id)
        |> Server.send toMsg



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    let
        newClientFormSubscriptions =
            case model.client of
                Searching detail ->
                    case detail.clientForm of
                        Just clientForm ->
                            ClientForm.subscriptions clientForm |> Sub.map (GotClientMsg << GotClientFormMsg)

                        Nothing ->
                            Sub.none

                _ ->
                    Sub.none

        editClientFormSubscriptions =
            case model.client of
                Success success ->
                    case success.editClientForm of
                        Just clientForm ->
                            ClientForm.subscriptions clientForm |> Sub.map (GotClientMsg << GotEditClientFormMsg)

                        Nothing ->
                            Sub.none

                Searching _ ->
                    Sub.none

        clientSearchSubscriptions =
            case model.client of
                Searching detail ->
                    Search.subscriptions detail.search |> Sub.map (GotClientMsg << GotSearchMsg)

                _ ->
                    Sub.none

        clientQuoteFormSubscritions =
            case model.client of
                Success success ->
                    Form.subscriptions success.form |> Sub.map (GotClientMsg << GotFormMsg)

                _ ->
                    Sub.none

        newSpouseFormSubscriptions =
            case model.spouse of
                Just (Searching detail) ->
                    case detail.clientForm of
                        Just clientForm ->
                            ClientForm.subscriptions clientForm |> Sub.map (GotSpouseMsg << GotClientFormMsg)

                        Nothing ->
                            Sub.none

                _ ->
                    Sub.none

        editSpouseFormSubscriptions =
            case model.spouse of
                Just (Success success) ->
                    case success.editClientForm of
                        Just clientForm ->
                            ClientForm.subscriptions clientForm |> Sub.map (GotSpouseMsg << GotEditClientFormMsg)

                        Nothing ->
                            Sub.none

                _ ->
                    Sub.none

        spouseSearchSubscriptions =
            case model.spouse of
                Just (Searching detail) ->
                    Search.subscriptions detail.search |> Sub.map (GotSpouseMsg << GotSearchMsg)

                _ ->
                    Sub.none

        spouseQuoteFormSubscritions =
            case model.spouse of
                Just (Success success) ->
                    Form.subscriptions success.form |> Sub.map (GotSpouseMsg << GotFormMsg)

                _ ->
                    Sub.none
    in
    Sub.batch
        [ newClientFormSubscriptions
        , editClientFormSubscriptions
        , clientSearchSubscriptions
        , clientQuoteFormSubscritions
        , newSpouseFormSubscriptions
        , editSpouseFormSubscriptions
        , spouseSearchSubscriptions
        , spouseQuoteFormSubscritions
        ]


view : Shared.Model -> Model -> View Msg
view shared model =
    { title = "New Quote"
    , body =
        [ -- TITLE
          div [ class "mb-12" ]
            [ a [ class "text-xs text-[var(--brand-color)] font-semibold", Route.Path.href Route.Path.Quotes ] [ text "Quotes" ]
            , div [ class "text-3xl text-gray-950 font-bold" ] [ text "New Quote" ]
            ]

        -- Client & Spouse
        , div [ class "flex gap-8 items-start mb-12" ]
            [ -- Client
              div [ class "w-1/2" ]
                [ div [ class "font-semibold text-xl text-gray-950 mb-[6px]" ] [ text "Client" ]
                , case model.client of
                    Searching details ->
                        Search.input
                            { model = details.search
                            , onClientClick = SelectedClient
                            , onAddClientClick = ClickedAddClient
                            , toMsg = GotSearchMsg
                            }
                            |> Html.map GotClientMsg

                    Success details ->
                        div []
                            [ viewClient details.client
                            , div [ class "flex gap-6" ]
                                [ div [ class "underline cursor-pointer text-[var(--brand-color)] text-xs leading-5", onClick ClickedChangeClient ] [ text "Change client" ]
                                , div [ class "underline cursor-pointer text-[var(--brand-color)] text-xs leading-5", onClick (GotClientMsg ClickedEditClient) ] [ text "Edit client" ]
                                ]
                            ]
                ]

            -- Spouse
            , div [ class "w-1/2" ]
                (case ( model.client, model.spouse ) of
                    ( Success _, Nothing ) ->
                        [ UI.Button.new "Add a spouse"
                            |> UI.Button.withStyle UI.Button.Secondary
                            |> UI.Button.withType (UI.Button.Button ClickedAddSpouse)
                            |> UI.Button.withIcon UI.Icon.Plus
                            |> UI.Button.withSize UI.Button.Small
                            |> UI.Button.view
                        ]

                    ( Success _, Just (Searching details) ) ->
                        [ div [ class "font-semibold text-gray-950 text-xl mb-[6px]" ] [ text "Spouse" ]
                        , Search.input
                            { model = details.search
                            , onClientClick = SelectedClient
                            , onAddClientClick = ClickedAddClient
                            , toMsg = GotSearchMsg
                            }
                            |> Html.map GotSpouseMsg
                        ]

                    ( Success _, Just (Success details) ) ->
                        [ div [ class "font-semibold text-gray-950 text-xl mb-[6px]" ] [ text "Spouse" ]
                        , viewClient details.client
                        , div [ class "flex gap-6" ]
                            [ div [ class "text-[var(--brand-color)] underline text-xs cursor-pointer leading-5", onClick ClickedChangeSpouse ] [ text "Change spouse" ]
                            , div [ class "underline cursor-pointer text-[var(--brand-color)] text-xs leading-5", onClick (GotSpouseMsg ClickedEditClient) ] [ text "Edit spouse" ]
                            ]
                        ]

                    ( Searching _, _ ) ->
                        []
                )
            ]

        -- TABS
        , viewTabs model

        -- FORM
        , case ( model.client, model.spouse, model.selectedTab ) of
            ( Success details, Just (Success _), TabClient ) ->
                Form.view shared details.form
                    |> Html.map GotFormMsg
                    |> Html.map GotClientMsg

            ( Success _, Just (Success details), TabSpouse ) ->
                Form.view shared details.form
                    |> Html.map GotFormMsg
                    |> Html.map GotSpouseMsg

            ( Success details, _, _ ) ->
                Form.view shared details.form
                    |> Html.map GotFormMsg
                    |> Html.map GotClientMsg

            ( Searching _, _, _ ) ->
                viewNothing

        -- Submit Buttons
        , viewSubmitButtons model

        -- New Client Modal
        , case ( model.client, model.spouse ) of
            ( Searching detail, _ ) ->
                case detail.clientForm of
                    Just clientForm ->
                        ClientForm.view
                            { title = "New client"
                            , buttonText = "Create client"
                            , model = clientForm
                            }
                            |> Html.map GotClientFormMsg
                            |> Html.map GotClientMsg

                    Nothing ->
                        viewNothing

            ( Success _, Just (Searching detail) ) ->
                case detail.clientForm of
                    Just clientForm ->
                        ClientForm.view
                            { title = "New client"
                            , buttonText = "Create client"
                            , model = clientForm
                            }
                            |> Html.map GotClientFormMsg
                            |> Html.map GotSpouseMsg

                    Nothing ->
                        viewNothing

            _ ->
                viewNothing

        -- Edit Client Modal
        , case model.client of
            Success success ->
                case success.editClientForm of
                    Just clientForm ->
                        ClientForm.view
                            { title = "Update client"
                            , buttonText = "Update client"
                            , model = clientForm
                            }
                            |> Html.map GotEditClientFormMsg
                            |> Html.map GotClientMsg

                    Nothing ->
                        viewNothing

            Searching _ ->
                viewNothing
        , case model.spouse of
            Just (Success success) ->
                case success.editClientForm of
                    Just clientForm ->
                        ClientForm.view
                            { title = "Update client"
                            , buttonText = "Update client"
                            , model = clientForm
                            }
                            |> Html.map GotEditClientFormMsg
                            |> Html.map GotSpouseMsg

                    Nothing ->
                        viewNothing

            _ ->
                viewNothing
        ]
    }


viewTabs : Model -> Html Msg
viewTabs model =
    let
        viewTabs_ children =
            div [ class "border-b border-gray-300 flex gap-7 items-center mb-12" ] children

        viewTab tab client =
            div
                [ classList
                    [ ( "py-2 cursor-pointer border-b-[3px] font-semibold", True )
                    , ( "border-[var(--brand-color)] text-[var(--brand-color)]", model.selectedTab == tab )
                    , ( "border-white text-gray-500", model.selectedTab /= tab )
                    ]
                , onClick (ClickedTab tab)
                ]
                [ text (client.firstName ++ " " ++ client.lastName) ]
    in
    case ( model.client, model.spouse ) of
        ( Success client, Just (Success spouse) ) ->
            viewTabs_
                [ viewTab TabClient client.client
                , viewTab TabSpouse spouse.client
                ]

        _ ->
            viewNothing


viewClient : Server.Client -> Html Msg
viewClient client =
    let
        fullName =
            client.firstName ++ " " ++ client.lastName

        dateOfBirth =
            client.dateOfBirth
                |> Date.fromIsoString
                |> Result.map (Date.format "MMMM d, y")
                |> Result.withDefault ""

        dateAndAge =
            dateOfBirth ++ " " ++ "(Age " ++ String.fromInt client.age ++ ")"

        location =
            client.zipCode ++ ", " ++ client.county.name ++ ", " ++ client.county.stateAlphaCode

        tobacco =
            if client.isTobaccoUser then
                "Tobacco user"

            else
                "Non-tobacco user"
    in
    div [ class "text-gray-500" ]
        [ div [] [ text fullName ]
        , div [] [ text dateAndAge ]
        , div [] [ text location ]
        , div [] [ text tobacco ]
        ]


viewSubmitButtons : Model -> Html Msg
viewSubmitButtons model =
    let
        isDisabled =
            case model.client of
                Success details ->
                    if Form.isValid details.form then
                        False

                    else
                        True

                Searching _ ->
                    True
    in
    case model.client of
        Success details ->
            div [ class "w-full space-x-3 flex items-center justify-end" ]
                [ label []
                    [ input [ type_ "checkbox", checked model.redirectToQuoteReview, onClick ClickedRedirectToPublicQuote ] []
                    , span [ class "ml-1" ] [ text "Go to quote review" ]
                    ]
                , UI.Button.new "Create quote"
                    |> UI.Button.withType (UI.Button.Button SubmittedForm)
                    |> UI.Button.withDisabled isDisabled
                    |> UI.Button.withOptionalIcon UI.Icon.Loading4Animated model.isSubmitting
                    |> UI.Button.view
                ]

        Searching _ ->
            viewNothing


viewNothing : Html msg
viewNothing =
    text ""

================
File: frontend/src/Pages/Home_.elm
================
module Pages.Home_ exposing (Model, Msg, page)

import Auth
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Layouts
import Page exposing (Page)
import Route exposing (Route)
import Route.Path
import Shared
import View exposing (View)


page : Auth.User -> Shared.Model -> Route () -> Page Model Msg
page user shared route =
    Page.new
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }
        |> Page.withLayout (toLayout user)


toLayout : Auth.User -> Model -> Layouts.Layout Msg
toLayout user model =
    Layouts.Default
        { agent = user
        }



-- INIT


type alias Model =
    {}


init : () -> ( Model, Effect Msg )
init () =
    ( {}
    , Effect.replaceRoutePath Route.Path.Quotes
    )



-- UPDATE


type Msg
    = NoOp


update : Msg -> Model -> ( Model, Effect Msg )
update msg model =
    case msg of
        NoOp ->
            ( model
            , Effect.none
            )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none



-- VIEW


view : Model -> View Msg
view model =
    { title = ""
    , body =
        [ text "home" ]
    }

================
File: frontend/src/Pages/NotFound_.elm
================
module Pages.NotFound_ exposing (Model, Msg, page)

import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Page exposing (Page)
import Route exposing (Route)
import Shared
import UI.Icon
import View exposing (View)


page : Shared.Model -> Route () -> Page Model Msg
page shared route =
    Page.new
        { init = init
        , update = update
        , subscriptions = subscriptions
        , view = view
        }



-- INIT


type alias Model =
    {}


init : () -> ( Model, Effect Msg )
init () =
    ( {}
    , Effect.none
    )



-- UPDATE


type Msg
    = NoOp


update : Msg -> Model -> ( Model, Effect Msg )
update msg model =
    case msg of
        NoOp ->
            ( model
            , Effect.none
            )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none



-- VIEW


view : Model -> View Msg
view model =
    { title = "Page not found"
    , body =
        [ div [ class "fixed inset-0 p-5 flex items-center justify-center" ]
            [ div [ class "text-gray-800" ]
                [ div [ class "flex justify-center" ]
                    [ UI.Icon.new UI.Icon.AlertTriangle
                        |> UI.Icon.withSize 30
                        |> UI.Icon.view
                    ]
                , div [ class "font-semibold text-xl text-center" ] [ text "404 - Page not found." ]
                ]
            ]
        ]
    }

================
File: frontend/src/Pages/Quotes.elm
================
module Pages.Quotes exposing (Model, Msg, page)

import Auth
import Dict
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Layouts
import Page exposing (Page)
import RemoteData exposing (RemoteData)
import Route exposing (Route)
import Route.Path
import Server
import Shared
import UI.Button
import UI.Icon
import UI.Quote
import UI.Time
import View exposing (View)



-- CONST


quoteLimit : Int
quoteLimit =
    20


page : Auth.User -> Shared.Model -> Route () -> Page Model Msg
page agent shared route =
    Page.new
        { init = init route
        , update = update
        , subscriptions = subscriptions
        , view = view shared route
        }
        |> Page.withLayout (toLayout agent)
        |> Page.withOnUrlChanged UrlChanged


{-| Use the sidebar layout on this page
-}
toLayout : Server.Agent -> Model -> Layouts.Layout Msg
toLayout agent model =
    Layouts.Default
        { agent = agent
        }



-- INIT


type alias Model =
    { quotes : RemoteData Server.Error Server.ListQuotesResponse
    , showPagination : Bool
    }


init : Route () -> () -> ( Model, Effect Msg )
init route () =
    let
        listQuotesParams =
            case ( Dict.get "starting_after" route.query, Dict.get "ending_before" route.query ) of
                ( Just startingAfterId, _ ) ->
                    { limit = quoteLimit
                    , startingAfter = Just startingAfterId |> Maybe.andThen String.toInt
                    , endingBefore = Nothing
                    , clientId = Nothing
                    }

                ( _, Just endingBeforeId ) ->
                    { limit = quoteLimit
                    , startingAfter = Nothing
                    , endingBefore = Just endingBeforeId |> Maybe.andThen String.toInt
                    , clientId = Nothing
                    }

                _ ->
                    { limit = quoteLimit
                    , startingAfter = Nothing
                    , endingBefore = Nothing
                    , clientId = Nothing
                    }
    in
    ( { quotes = RemoteData.Loading
      , showPagination = True
      }
    , Server.dashboard.listQuotes listQuotesParams
        |> Server.send CompletedListQuotes
        |> Effect.sendCmd
    )



-- UPDATE


type Msg
    = ClickedNext
    | ClickedPrevious
    | ClickedQuote Int
    | CompletedListQuotes (Result Server.Error Server.ListQuotesResponse)
    | UrlChanged { from : Route (), to : Route () }


update : Msg -> Model -> ( Model, Effect Msg )
update msg model =
    let
        noop =
            ( model, Effect.none )
    in
    case msg of
        ClickedNext ->
            case model.quotes of
                RemoteData.Success resp ->
                    case resp.data |> List.reverse |> List.head of
                        Just lastQuote ->
                            ( { model | showPagination = False }
                            , Effect.batch
                                [ Server.dashboard.listQuotes
                                    { limit = quoteLimit
                                    , startingAfter = Just lastQuote.id
                                    , endingBefore = Nothing
                                    , clientId = Nothing
                                    }
                                    |> Server.send CompletedListQuotes
                                    |> Effect.sendCmd
                                , Effect.pushRoute
                                    { path = Route.Path.Quotes
                                    , query = Dict.singleton "starting_after" (String.fromInt lastQuote.id)
                                    , hash = Nothing
                                    }
                                ]
                            )

                        Nothing ->
                            noop

                _ ->
                    noop

        ClickedPrevious ->
            case model.quotes of
                RemoteData.Success resp ->
                    case resp.data |> List.head of
                        Just firstQuote ->
                            ( { model | showPagination = False }
                            , Effect.batch
                                [ Server.dashboard.listQuotes
                                    { limit = quoteLimit
                                    , startingAfter = Nothing
                                    , endingBefore = Just firstQuote.id
                                    , clientId = Nothing
                                    }
                                    |> Server.send CompletedListQuotes
                                    |> Effect.sendCmd
                                , Effect.pushRoute
                                    { path = Route.Path.Quotes
                                    , query = Dict.singleton "ending_before" (String.fromInt firstQuote.id)
                                    , hash = Nothing
                                    }
                                ]
                            )

                        Nothing ->
                            noop

                _ ->
                    noop

        ClickedQuote id ->
            ( model
            , Effect.pushRoutePath (Route.Path.Quotes_Id_ { id = String.fromInt id })
            )

        CompletedListQuotes (Ok response) ->
            ( { model | quotes = RemoteData.Success response, showPagination = True }
            , Effect.none
            )

        CompletedListQuotes (Err e) ->
            ( { model | quotes = RemoteData.Failure e, showPagination = True }
            , Effect.none
            )

        UrlChanged { from, to } ->
            let
                listQuotesParams =
                    case ( Dict.get "starting_after" to.query, Dict.get "ending_before" to.query ) of
                        ( Just startingAfterId, _ ) ->
                            { limit = quoteLimit
                            , startingAfter = Just startingAfterId |> Maybe.andThen String.toInt
                            , endingBefore = Nothing
                            , clientId = Nothing
                            }

                        ( _, Just endingBeforeId ) ->
                            { limit = quoteLimit
                            , startingAfter = Nothing
                            , endingBefore = Just endingBeforeId |> Maybe.andThen String.toInt
                            , clientId = Nothing
                            }

                        _ ->
                            { limit = quoteLimit
                            , startingAfter = Nothing
                            , endingBefore = Nothing
                            , clientId = Nothing
                            }
            in
            ( model
            , Server.dashboard.listQuotes listQuotesParams
                |> Server.send CompletedListQuotes
                |> Effect.sendCmd
            )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none



-- VIEW


view : Shared.Model -> Route () -> Model -> View Msg
view shared route model =
    { title = "Quotes"
    , body =
        [ div [ class "space-y-8" ]
            [ -- HEADER
              div [ class "flex items-center " ]
                [ div [ class "text-gray-950 text-3xl font-bold grow" ] [ text "Quotes" ]
                , UI.Button.new "New quote"
                    |> UI.Button.withIcon UI.Icon.Plus
                    |> UI.Button.withType (UI.Button.Link (Route.Path.toString Route.Path.Quotes_New))
                    |> UI.Button.view
                ]
            , case model.quotes of
                RemoteData.NotAsked ->
                    viewNothing

                RemoteData.Loading ->
                    div [ class "w-full text-gray-300 flex justify-center" ]
                        [ UI.Icon.new UI.Icon.Loading4Animated
                            |> UI.Icon.withSize 24
                            |> UI.Icon.withStrokeWidth 2
                            |> UI.Icon.view
                        ]

                RemoteData.Success resp ->
                    case resp.data of
                        [] ->
                            div [ class "px-10 py-6 text-gray-500 border border-gray-300 rounded-lg text-center" ]
                                [ text "You have no quotes."
                                ]

                        _ ->
                            viewQuotesTable shared route model resp

                RemoteData.Failure e ->
                    div [ class "border border-red-700 bg-red-50 text-red-700 py-3 px-4 space-x-3 flex items-center rounded-lg" ]
                        [ UI.Icon.default UI.Icon.AlertTriangle
                        , span [] [ text "Something went wrong." ]
                        ]
            ]
        ]
    }


viewQuotesTable : Shared.Model -> Route () -> Model -> Server.ListQuotesResponse -> Html Msg
viewQuotesTable shared route model resp =
    div [ class "space-y-2" ]
        [ table [ class "w-full border-collapse border-y border-gray-300" ]
            [ thead []
                [ tr [ class "text-xs font-semibold" ]
                    [ th [ class "text-left h-10 pl-2 pr-3 whitespace-nowrap  " ] [ text "Client" ]
                    , th [ class "text-center h-10 px-3 whitespace-nowrap" ] [ text "Quote number" ]
                    , th [ class "text-left h-10 px-3 whitespace-nowrap" ] [ text "County" ]
                    , th [ class "text-center h-10 px-3 whitespace-nowrap" ] [ text "State" ]
                    , th [ class "text-right h-10 pl-3 pr-2 whitespace-nowrap" ] [ text "Created" ]
                    ]
                ]
            , tbody [] (List.map (viewQuotesTableRow shared) resp.data)
            ]
        , -- Pagination
          if model.showPagination then
            viewQuotesTablePagination route resp

          else
            viewNothing
        ]


viewQuotesTableRow : Shared.Model -> Server.ShortQuote -> Html Msg
viewQuotesTableRow shared quote =
    let
        clientName =
            quote.client.firstName ++ " " ++ quote.client.lastName

        quoteId =
            UI.Quote.quoteNumber quote.id

        created =
            UI.Time.posixToString shared.zone quote.createdAt
    in
    tr [ class "border-t border-[#EBEBEB] cursor-pointer hover:bg-gray-100", onClick (ClickedQuote quote.id) ]
        [ td [ class "text-left h-10 pl-2 pr-3 font-semibold" ] [ text clientName ]
        , td [ class "text-center h-10 px-3 tabular-nums text-gray-500" ] [ text quoteId ]
        , td [ class "text-left h-10 px-3 text-gray-500" ] [ text quote.client.county.name ]
        , td [ class "text-center h-10 px-3 text-gray-500" ] [ text quote.client.county.stateAlphaCode ]
        , td [ class "text-right h-10 pl-3 pr-2 tabular-nums  text-gray-500 whitespace-nowrap" ] [ text created ]
        ]


viewQuotesTablePagination : Route () -> Server.ListQuotesResponse -> Html Msg
viewQuotesTablePagination route resp =
    let
        ( isPrevDisabled, isNextDisabled ) =
            if Dict.member "starting_after" route.query then
                if resp.hasMore then
                    ( False, False )

                else
                    ( False, True )

            else if Dict.member "ending_before" route.query then
                if resp.hasMore then
                    ( False, False )

                else
                    ( True, False )

            else if resp.hasMore then
                ( True, False )

            else
                ( True, True )
    in
    div [ class "flex items-center space-x-3" ]
        [ div [ class "text-gray-500 grow" ] [ text (String.fromInt resp.totalCount ++ " results") ]
        , UI.Button.new "Previous"
            |> UI.Button.withDisabled isPrevDisabled
            |> UI.Button.withType (UI.Button.Button ClickedPrevious)
            |> UI.Button.withStyle UI.Button.Secondary
            |> UI.Button.withSize UI.Button.Small
            |> UI.Button.view
        , UI.Button.new "Next"
            |> UI.Button.withDisabled isNextDisabled
            |> UI.Button.withType (UI.Button.Button ClickedNext)
            |> UI.Button.withStyle UI.Button.Secondary
            |> UI.Button.withSize UI.Button.Small
            |> UI.Button.view
        ]


viewEmptyQuotesTable : Html Msg
viewEmptyQuotesTable =
    div [ class "px-10 py-6 text-gray-500 border border-gray-300 rounded-lg text-center" ]
        [ text "You have no quotes."
        ]


viewNothing : Html msg
viewNothing =
    text ""

================
File: frontend/src/Pages/SignIn.elm
================
module Pages.SignIn exposing (Model, Msg, page)

import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Page exposing (Page)
import Route exposing (Route)
import Route.Path
import Shared
import Shared.Model
import UI.Icon.GoogleG
import View exposing (View)


page : Shared.Model -> Route () -> Page Model Msg
page shared route =
    Page.new
        { init = init shared
        , update = update shared route
        , subscriptions = subscriptions
        , view = view shared route
        }



-- INIT


type alias Model =
    {}


init : Shared.Model -> () -> ( Model, Effect Msg )
init shared () =
    let
        redirectSignedInAgent =
            case shared.agent of
                Shared.Model.SignedOut _ ->
                    Effect.none

                _ ->
                    Effect.replaceRoutePath Route.Path.Quotes
    in
    ( {}
    , redirectSignedInAgent
    )



-- UPDATE


type Msg
    = ClickedSignIn


update : Shared.Model -> Route () -> Msg -> Model -> ( Model, Effect Msg )
update shared route msg model =
    case msg of
        ClickedSignIn ->
            ( model
            , Effect.loadExternalUrl (shared.oauthGoogleLoginUrl ++ "?" ++ Maybe.withDefault "" route.url.query)
            )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Sub.none



-- VIEW


view : Shared.Model -> Route () -> Model -> View Msg
view shared route model =
    { title = "Sign-in"
    , body =
        [ div [ class "flex items-center justify-center bg-gray-100 h-dvh w-full" ]
            [ div [ class "bg-white rounded-xl w-[22rem] p-8 space-y-8" ]
                [ div [ class "font-medium text-xl text-center" ] [ text "Agent Login" ]
                , div [ class "text-center" ]
                    [ button
                        [ class "flex items-center justify-center py-3.5 space-x-6 w-full bg-[var(--brand-color)] text-white font-medium text-base rounded-lg"
                        , onClick ClickedSignIn
                        ]
                        [ UI.Icon.GoogleG.view 22
                        , span [] [ text "Sign-in with Google" ]
                        ]
                    ]
                ]
            ]
        ]
    }

================
File: frontend/src/PagesExt/Quotes/Id_/SendModal.elm
================
module PagesExt.Quotes.Id_.SendModal exposing (Model, Msg, close, new, show, update, view)

import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Html.Extra exposing (..)
import Server
import UI.Button
import UI.Icon
import Validate


type Model
    = Model
        { emailOrPhone : String
        , isValidating : Bool
        , isSubmitting : Bool
        , result : Maybe (Result Server.Error ())
        }


modalId : String
modalId =
    "modal/sendquote"


show : ( Model, Effect Msg )
show =
    ( new, Effect.showDialog modalId )


close : Cmd Msg
close =
    Cmd.none


new : Model
new =
    Model
        { emailOrPhone = ""
        , isValidating = False
        , isSubmitting = False
        , result = Nothing
        }


type Msg
    = ChangedEmailOrPhone String
    | ClickedClose
    | ClickedClientEmail String
    | ClickedClientPhone String
    | CompletedSendQuote (Result Server.Error ())
    | SubmittedForm


update : Server.Quote -> Msg -> Model -> ( Model, Effect Msg )
update quote msg (Model model) =
    case msg of
        ChangedEmailOrPhone emailOrPhone ->
            ( Model
                { model
                    | emailOrPhone = emailOrPhone
                    , result = Nothing
                }
            , Effect.none
            )

        ClickedClose ->
            ( Model model
            , Effect.closeDialog modalId
            )

        ClickedClientEmail email ->
            ( Model { model | emailOrPhone = email }
            , Effect.none
            )

        ClickedClientPhone phone ->
            ( Model { model | emailOrPhone = phone }
            , Effect.none
            )

        CompletedSendQuote (Ok ()) ->
            ( Model
                { model
                    | isSubmitting = False
                    , isValidating = False
                    , emailOrPhone = ""
                    , result = Just (Ok ())
                }
            , Effect.none
            )

        CompletedSendQuote (Err e) ->
            ( Model { model | result = Just (Err e) }
            , Effect.none
            )

        SubmittedForm ->
            if isValid (Model model) then
                ( Model { model | isSubmitting = True }
                , Server.dashboard.sendQuote quote.id model.emailOrPhone
                    |> Server.send CompletedSendQuote
                    |> Effect.sendCmd
                )

            else
                ( Model { model | isValidating = True }
                , Effect.none
                )


view : Server.Quote -> Model -> Html Msg
view quote (Model model) =
    let
        clientName =
            [ quote.client.firstName, quote.client.lastName ]
                |> List.filter (not << String.isEmpty)
                |> String.join " "

        emailSuggestion =
            case quote.client.email of
                Just email ->
                    div [ class "text-xs text-[var(--brand-color)] underline cursor-pointer", onClick (ClickedClientEmail email) ] [ text ("Email to " ++ clientName ++ " (" ++ email ++ ")") ]

                Nothing ->
                    viewNothing

        textMessageSuggestion =
            case quote.client.phone of
                Just phone ->
                    div [ class "text-xs text-[var(--brand-color)] underline cursor-pointer", onClick (ClickedClientPhone phone) ] [ text ("Text to " ++ clientName ++ " (" ++ phone ++ ")") ]

                Nothing ->
                    viewNothing

        validationError =
            case ( model.isValidating, validate (Model model) ) of
                ( True, Just msg ) ->
                    div [ class "text-red-600" ] [ text msg ]

                _ ->
                    viewNothing

        hasError =
            case ( model.isValidating, validate (Model model) ) of
                ( True, Just msg ) ->
                    True

                _ ->
                    False
    in
    dialog [ id modalId, class "rounded-lg shadow-md px-6 py-5 w-[30rem]" ]
        [ Html.form [ class "space-y-6", onSubmit SubmittedForm ]
            [ div [ class "text-xl font-semibold" ] [ text "Send quote" ]
            , div [ class "space-y-[6px] mb-2" ]
                [ label [ for "emailOrPhone", class "block" ] [ text "Email or phone number" ]
                , input [ classList [ ( "w-full", True ), ( "input-error", hasError ) ], id "emailOrPhone", type_ "text", value model.emailOrPhone, onInput ChangedEmailOrPhone ] []
                , validationError
                , emailSuggestion
                , textMessageSuggestion
                ]
            , viewResultMessage model.result
            , div [ class "flex items-center justify-between gap-4" ]
                [ UI.Button.new "Close"
                    |> UI.Button.withStyle UI.Button.Secondary
                    |> UI.Button.withType (UI.Button.Button ClickedClose)
                    |> UI.Button.view
                , UI.Button.new "Send quote"
                    |> (if model.isSubmitting then
                            UI.Button.withIcon UI.Icon.Loading4Animated

                        else
                            identity
                       )
                    |> UI.Button.view
                ]
            ]
        ]


viewResultMessage : Maybe (Result Server.Error ()) -> Html Msg
viewResultMessage maybeResult =
    case maybeResult of
        Just (Ok ()) ->
            div [ class "text-green-700 text-right" ] [ text "Quote sent successfully." ]

        Just (Err e) ->
            div [ class "text-red-600 text-right" ] [ text "Unable to send quote." ]

        Nothing ->
            viewNothing


viewNothing : Html msg
viewNothing =
    text ""



-- VALIDATION


validate : Model -> Maybe String
validate (Model model) =
    if Validate.isBlank model.emailOrPhone then
        Just "Required"

    else if not (Validate.isEmail model.emailOrPhone) && not (Validate.isPhoneNumber model.emailOrPhone) then
        Just "Invalid email or phone number"

    else
        Nothing


isValid : Model -> Bool
isValid model =
    validate model == Nothing

================
File: frontend/src/PagesExt/Quotes/New/ClientSearch.elm
================
module PagesExt.Quotes.New.ClientSearch exposing (Model, Msg, input, new, subscriptions, update)

import Browser.Events
import Debounce exposing (Debounce)
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import Html.Events.Extra exposing (..)
import Json.Decode
import RemoteData
import Server
import UI.Icon


type Model
    = Model
        { searchTerm : String
        , isFocussed : Bool
        , debounce : Debounce String
        , clients : RemoteData.RemoteData Server.Error (List Server.Client)
        }


new : Model
new =
    Model
        { searchTerm = ""
        , isFocussed = False
        , debounce = Debounce.init
        , clients = RemoteData.NotAsked
        }


type Msg
    = ChangedSearch String
    | ClickedDocument
    | CompletedSearchForClients (Result Server.Error (List Server.Client))
    | DebounceMsg Debounce.Msg
    | FocussedSearch
    | NoOp


update : Msg -> Model -> ( Model, Effect Msg )
update msg (Model model) =
    case msg of
        ChangedSearch searchTerm ->
            let
                ( debounce, debouceCmd ) =
                    Debounce.push debounceConfig searchTerm model.debounce
            in
            ( Model { model | searchTerm = searchTerm, debounce = debounce }
            , Effect.sendCmd debouceCmd
            )

        ClickedDocument ->
            ( Model { model | isFocussed = False }
            , Effect.none
            )

        CompletedSearchForClients results ->
            ( Model { model | clients = RemoteData.fromResult results }
            , Effect.none
            )

        DebounceMsg debouncedMsg ->
            let
                searchClientsCmd searchTerm =
                    Server.dashboard.searchClients searchTerm
                        |> Server.send CompletedSearchForClients

                ( debounce, cmd ) =
                    Debounce.update debounceConfig (Debounce.takeLast searchClientsCmd) debouncedMsg model.debounce
            in
            ( Model { model | debounce = debounce }
            , Effect.sendCmd cmd
            )

        FocussedSearch ->
            ( Model { model | isFocussed = True }, Effect.none )

        NoOp ->
            ( Model model, Effect.none )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Browser.Events.onClick (Json.Decode.succeed ClickedDocument)



-- VIEW


input :
    { model : Model
    , toMsg : Msg -> msg
    , onClientClick : Server.Client -> msg
    , onAddClientClick : String -> msg
    }
    -> Html msg
input { model, toMsg, onClientClick, onAddClientClick } =
    let
        (Model model_) =
            model
    in
    div [ class "relative w-96 ", alwaysStopPropagationOn "click" (toMsg NoOp) ]
        [ -- Search input
          Html.input [ class "w-full pr-10", type_ "text", placeholder "Find or add a client...", value model_.searchTerm, onInput (toMsg << ChangedSearch), onFocus (toMsg FocussedSearch) ] []
        , div [ class "absolute right-0 top-0 bottom-0 w-10 flex items-center justify-center" ] [ UI.Icon.default UI.Icon.SearchMd ]

        -- Search results drop down
        , if model_.isFocussed then
            div [ class "absolute w-full top-full mt-1 rounded-lg bg-white border border-gray-300 shadow-md p-1 space-y-1" ]
                (viewAddClient model onAddClientClick :: viewSearchResults model onClientClick)

          else
            viewNothing
        ]


viewAddClient : Model -> (String -> msg) -> Html msg
viewAddClient (Model model) onAddClientClick =
    let
        addClientText =
            if model.searchTerm == "" then
                "Add new client"

            else
                "Add " ++ model.searchTerm
    in
    div [ class "flex items-center gap-[4px] py-1 px-2 hover:bg-gray-100 cursor-pointer", onClick (onAddClientClick model.searchTerm) ]
        [ UI.Icon.new UI.Icon.Plus |> UI.Icon.withSize 16 |> UI.Icon.view
        , span [] [ text addClientText ]
        ]


viewSearchResults : Model -> (Server.Client -> msg) -> List (Html msg)
viewSearchResults (Model model) onClientClick =
    case model.clients of
        RemoteData.Success [] ->
            []

        RemoteData.Success clients ->
            List.map (viewClient onClientClick) clients

        _ ->
            []


viewClient : (Server.Client -> msg) -> Server.Client -> Html msg
viewClient onClientClick client =
    let
        name =
            client.firstName ++ " " ++ client.lastName
    in
    div
        [ class "py-1 px-3 hover:bg-gray-100 cursor-pointer space-x-2 whitespace-nowrap text-ellipsis overflow-hidden"
        , onClick (onClientClick client)
        ]
        [ span [ class "" ] [ text name ]
        , case client.email of
            Just email ->
                span [ class "text-gray-500" ] [ text email ]

            Nothing ->
                viewNothing
        ]


viewNothing : Html msg
viewNothing =
    text ""



-- INTERNAL


debounceConfig : Debounce.Config Msg
debounceConfig =
    { strategy = Debounce.later 300
    , transform = DebounceMsg
    }

================
File: frontend/src/PagesExt/Quotes/New/Form.elm
================
module PagesExt.Quotes.New.Form exposing (Model, Msg, Values, empty, export, isValid, new, subscriptions, update, view)

import Browser.Events
import Date exposing (Date)
import Dict.Any as AnyDict exposing (AnyDict)
import Effect exposing (Effect)
import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Attributes.Extra as AttrExt
import Html.Events exposing (..)
import Html.Events.Extra exposing (..)
import Json.Decode
import PagesExt.Quotes.New.SupplementalPlanSet as SupplementalPlanSet
import RemoteData
import Server
import Set.Any as AnySet exposing (AnySet)
import Shared
import Table exposing (defaultCustomizations)
import Time
import UI.Button
import UI.Cents as Cents
import UI.Icon
import UI.Select


type Model
    = Model
        { effectiveDate : Maybe Date
        , effectiveDates : ( Date, List Date )
        , irmaaFilingAmount : ( Server.FilingType, Int )
        , irmaaBrackets : RemoteData.RemoteData Server.Error (List Server.IrmaaBracket)
        , drugPlanKey : Maybe DrugPlanKey
        , drugQuotes : RemoteData.RemoteData Server.Error (List Server.DrugQuote)
        , supplementalPlans : SupplementalPlanSet.Set
        , supplementalQuotes : RemoteData.RemoteData Server.Error (List Server.SupplementalQuote)
        , supplementalTable : Table.State
        , carrierGroup : CarrierGroup
        , dentalPlanKey : Maybe DentalPlanKey
        , dentalQuotes : RemoteData.RemoteData Server.Error (List Server.DentalQuote)
        , dentalTable : Table.State
        , hasMultiInsuredDiscount : Bool
        , hasLivingWithSomeoneDiscount : Bool
        , showCarrierGroupMenu : Bool
        , showDiscountsMenu : Bool
        , showPlansMenu : Bool
        , selectedSupplementalPlanTypes : AnySet Int Server.SupplementalPlanType
        }


type CarrierGroup
    = Preferred
    | Supported
    | All


type alias DrugPlanKey =
    ( String, Int )


type alias DentalPlanKey =
    ( String, Int )


new : Shared.Model -> Server.Quote -> ( Model, Effect Msg )
new shared quote =
    let
        (Model model) =
            empty shared

        quoteEffectiveDate =
            Date.fromPosix Time.utc quote.effectiveDate

        effectiveDate =
            model.effectiveDates
                |> effectiveDatesToList
                |> List.filter (\date -> date == quoteEffectiveDate)
                |> List.head
                |> Maybe.withDefault (Tuple.first model.effectiveDates)

        irmaaFilingAmount =
            ( quote.irmaaBracket.filingType, irmaaBracketFilingAmount quote.irmaaBracket )

        drugPlanKey =
            quote.drugQuote
                |> Maybe.map (\dq -> ( dq.contractId, dq.planId ))

        dentalQuoteKey =
            quote.dentalQuote
                |> Maybe.map (\dq -> ( dq.carrierNaic, dq.annualBenefitCents ))

        changedEffectiveDate =
            Effect.sendMsg (ChangedEffectiveDate (Just effectiveDate))

        changedIrmaaFilingAmount =
            Effect.sendMsg (ChangedIrmaaFilingAmount irmaaFilingAmount)

        changedDrugPlan =
            Effect.sendMsg (ChangedDrugPlan drugPlanKey)

        changedDentalPlan =
            Effect.sendMsg (ChangedDentalPlan dentalQuoteKey)

        changedSupplementalPlans =
            let
                step1 supplementalCarrierPlanType effects =
                    Effect.sendMsg (ClickedSupplementalPlan supplementalCarrierPlanType.carrierNaic supplementalCarrierPlanType.planType) :: effects
            in
            List.foldl step1 [] quote.supplementalCarrierPlanTypes
                |> Effect.batch

        clickedMultiInsuredDiscount =
            if quote.hasMultiInsuredDiscount then
                Effect.sendMsg ClickedMultiInsuredDiscount

            else
                Effect.none

        clickedLivingWithSomeoneDiscount =
            if quote.hasLivingWithSomeoneDiscount then
                Effect.sendMsg ClickedLivingWithSomeoneDiscount

            else
                Effect.none
    in
    ( Model model
    , Effect.batch
        [ changedEffectiveDate
        , changedIrmaaFilingAmount
        , changedDrugPlan
        , changedSupplementalPlans
        , changedDentalPlan
        , clickedMultiInsuredDiscount
        , clickedLivingWithSomeoneDiscount
        ]
    )


empty : Shared.Model -> Model
empty shared =
    let
        selectedSupplementalPlanTypes =
            AnySet.empty supplementalPlanTypeComparable
                |> AnySet.insert Server.SupplementalPlanTypeG
                |> AnySet.insert Server.SupplementalPlanTypeN
    in
    Model
        { effectiveDate = Nothing
        , effectiveDates = buildEffectiveDates shared
        , irmaaFilingAmount = ( Server.FilingTypeIndividual, 0 )
        , irmaaBrackets = RemoteData.NotAsked
        , drugPlanKey = Nothing
        , drugQuotes = RemoteData.NotAsked
        , supplementalPlans = SupplementalPlanSet.empty 3
        , supplementalQuotes = RemoteData.NotAsked
        , supplementalTable = Table.initialSort "Company"
        , carrierGroup = Preferred
        , dentalPlanKey = Nothing
        , dentalQuotes = RemoteData.NotAsked
        , dentalTable = Table.initialSort "Company"
        , hasMultiInsuredDiscount = False
        , hasLivingWithSomeoneDiscount = False
        , showCarrierGroupMenu = False
        , showDiscountsMenu = False
        , showPlansMenu = False
        , selectedSupplementalPlanTypes = selectedSupplementalPlanTypes
        }


type Msg
    = ChangedDentalPlan (Maybe DentalPlanKey)
    | ChangedDrugPlan (Maybe DrugPlanKey)
    | ChangedEffectiveDate (Maybe Date)
    | ChangedIrmaaFilingAmount ( Server.FilingType, Int )
    | ChangedCarrierGroup CarrierGroup
    | ClickedCarriers
    | ClickedDeselectAllSupRates
    | ClickedDiscounts
    | ClickedDocument
    | ClickedLivingWithSomeoneDiscount
    | ClickedMultiInsuredDiscount
    | ClickedPlans
    | ClickedSupplementalPlanType Server.SupplementalPlanType
    | ClickedSupplementalCarrier String
    | ClickedSupplementalPlan String Server.SupplementalPlanType
    | CompletedListDentalQuotesByClientId (Result Server.Error (List Server.DentalQuote))
    | CompletedListIrmaaBracketsByEffectiveDate (Result Server.Error (List Server.IrmaaBracket))
    | CompletedListDrugQuotesByClientIdAndEffectiveDate (Result Server.Error (List Server.DrugQuote))
    | CompletedListSupplementalQuotesByClientIdAndEffectiveDate (Result Server.Error (List Server.SupplementalQuote))
    | GotDentalTableMsg Table.State
    | GotSupTableMsg Table.State
    | NoOp


update : Server.Client -> Msg -> Model -> ( Model, Effect Msg )
update client msg (Model model) =
    let
        noop =
            ( Model model, Effect.none )
    in
    case msg of
        ChangedDentalPlan dentalPlanKey ->
            ( Model { model | dentalPlanKey = dentalPlanKey }
            , Effect.none
            )

        ChangedEffectiveDate (Just effectiveDate) ->
            let
                effectiveIsoDate =
                    Date.toIsoString effectiveDate

                supPlanTypes =
                    AnySet.toList model.selectedSupplementalPlanTypes

                serverCarrierGroup =
                    carrierGroupToServerCarrierGroup model.carrierGroup
            in
            ( Model
                { model
                    | effectiveDate = Just effectiveDate
                    , irmaaBrackets = RemoteData.Loading
                    , drugQuotes = RemoteData.Loading
                    , supplementalQuotes = RemoteData.Loading
                    , dentalQuotes = RemoteData.Loading
                }
            , Effect.batch
                [ Server.dashboard.listIrmaaBracketsByEffectiveDate effectiveIsoDate
                    |> Server.send CompletedListIrmaaBracketsByEffectiveDate
                    |> Effect.sendCmd
                , Server.dashboard.listDrugQuotesByClientIdAndEffectiveDate client.id effectiveIsoDate
                    |> Server.send CompletedListDrugQuotesByClientIdAndEffectiveDate
                    |> Effect.sendCmd
                , Server.dashboard.listSupplementalQuotesByClientIdAndEffectiveDate client.id effectiveIsoDate supPlanTypes serverCarrierGroup
                    |> Server.send CompletedListSupplementalQuotesByClientIdAndEffectiveDate
                    |> Effect.sendCmd
                , Server.dashboard.listDentalQuotesByClientId client.id
                    |> Server.send CompletedListDentalQuotesByClientId
                    |> Effect.sendCmd
                ]
            )

        ChangedEffectiveDate Nothing ->
            ( Model
                { model
                    | effectiveDate = Nothing
                    , irmaaBrackets = RemoteData.NotAsked
                    , drugQuotes = RemoteData.NotAsked
                    , supplementalQuotes = RemoteData.NotAsked
                    , dentalQuotes = RemoteData.NotAsked
                }
            , Effect.none
            )

        ChangedIrmaaFilingAmount irmaaFilingAmount ->
            ( Model { model | irmaaFilingAmount = irmaaFilingAmount }
            , Effect.none
            )

        ChangedCarrierGroup nextCarrierGroup ->
            let
                serverCarrierGroup =
                    carrierGroupToServerCarrierGroup nextCarrierGroup

                effectiveIsoDate =
                    Maybe.map Date.toIsoString model.effectiveDate
                        |> Maybe.withDefault ""

                supPlanTypes =
                    AnySet.toList model.selectedSupplementalPlanTypes

                prevCarrierGroup =
                    model.carrierGroup

                isReloadingSupplementalQuotes =
                    case ( prevCarrierGroup, nextCarrierGroup ) of
                        ( Preferred, All ) ->
                            True

                        ( Supported, All ) ->
                            True

                        ( All, Preferred ) ->
                            True

                        ( All, Supported ) ->
                            True

                        _ ->
                            False

                supplementalQuotes =
                    if isReloadingSupplementalQuotes then
                        RemoteData.Loading

                    else
                        model.supplementalQuotes

                reloadSupplementalQuotes =
                    if isReloadingSupplementalQuotes then
                        Server.dashboard.listSupplementalQuotesByClientIdAndEffectiveDate client.id effectiveIsoDate supPlanTypes serverCarrierGroup
                            |> Server.send CompletedListSupplementalQuotesByClientIdAndEffectiveDate
                            |> Effect.sendCmd

                    else
                        Effect.none
            in
            ( Model
                { model
                    | carrierGroup = nextCarrierGroup
                    , supplementalQuotes = supplementalQuotes
                    , showCarrierGroupMenu = False
                }
            , reloadSupplementalQuotes
            )

        ClickedCarriers ->
            ( Model
                { model
                    | showCarrierGroupMenu = not model.showCarrierGroupMenu
                    , showDiscountsMenu = False
                    , showPlansMenu = False
                }
            , Effect.none
            )

        ClickedDeselectAllSupRates ->
            ( Model { model | supplementalPlans = SupplementalPlanSet.empty 3 }, Effect.none )

        ClickedDiscounts ->
            ( Model
                { model
                    | showDiscountsMenu = not model.showDiscountsMenu
                    , showCarrierGroupMenu = False
                    , showPlansMenu = False
                }
            , Effect.none
            )

        ClickedDocument ->
            ( Model
                { model
                    | showCarrierGroupMenu = False
                    , showDiscountsMenu = False
                    , showPlansMenu = False
                }
            , Effect.none
            )

        ClickedLivingWithSomeoneDiscount ->
            ( Model { model | hasLivingWithSomeoneDiscount = not model.hasLivingWithSomeoneDiscount }
            , Effect.none
            )

        ClickedMultiInsuredDiscount ->
            ( Model { model | hasMultiInsuredDiscount = not model.hasMultiInsuredDiscount }
            , Effect.none
            )

        ClickedPlans ->
            ( Model
                { model
                    | showPlansMenu = not model.showPlansMenu
                    , showCarrierGroupMenu = False
                    , showDiscountsMenu = False
                }
            , Effect.none
            )

        ChangedDrugPlan drugPlanKey ->
            ( Model { model | drugPlanKey = drugPlanKey }
            , Effect.none
            )

        ClickedSupplementalPlanType planType ->
            case model.effectiveDate of
                Just effectiveDate ->
                    let
                        toggle v set =
                            if AnySet.member v set then
                                AnySet.remove v set

                            else
                                AnySet.insert v set

                        selectedSupplementalPlanTypes =
                            toggle planType model.selectedSupplementalPlanTypes

                        effectiveDateIso =
                            Date.toIsoString effectiveDate

                        supplementalPlanTypeList =
                            AnySet.toList selectedSupplementalPlanTypes

                        serverCarrierGroup =
                            carrierGroupToServerCarrierGroup model.carrierGroup

                        -- When reducing the types of supplemental plans that are displayed via the "plans" pop-up menu, make sure to
                        -- also remove the selected plans from the supplemental plans list for plan types are no longer displayed.
                        supplementalPlans =
                            SupplementalPlanSet.filterPlanTypes (AnySet.toList selectedSupplementalPlanTypes) model.supplementalPlans
                    in
                    ( Model
                        { model
                            | selectedSupplementalPlanTypes = selectedSupplementalPlanTypes
                            , supplementalPlans = supplementalPlans
                            , supplementalQuotes = RemoteData.Loading
                            , showPlansMenu = False
                        }
                    , Server.dashboard.listSupplementalQuotesByClientIdAndEffectiveDate client.id effectiveDateIso supplementalPlanTypeList serverCarrierGroup
                        |> Server.send CompletedListSupplementalQuotesByClientIdAndEffectiveDate
                        |> Effect.sendCmd
                    )

                Nothing ->
                    ( Model model, Effect.none )

        ClickedSupplementalCarrier naic ->
            ( Model { model | supplementalPlans = SupplementalPlanSet.toggleCarrier naic model.supplementalPlans }
            , Effect.none
            )

        ClickedSupplementalPlan naic planType ->
            ( Model { model | supplementalPlans = SupplementalPlanSet.toggle naic planType model.supplementalPlans }
            , Effect.none
            )

        CompletedListDentalQuotesByClientId result ->
            ( Model { model | dentalQuotes = RemoteData.fromResult result }
            , Effect.none
            )

        CompletedListIrmaaBracketsByEffectiveDate result ->
            ( Model { model | irmaaBrackets = RemoteData.fromResult result }
            , Effect.none
            )

        CompletedListDrugQuotesByClientIdAndEffectiveDate result ->
            ( Model { model | drugQuotes = RemoteData.fromResult result }
            , Effect.none
            )

        CompletedListSupplementalQuotesByClientIdAndEffectiveDate (Ok supplementalQuotes) ->
            let
                supplementalPlans =
                    supplementalQuotes
                        |> supplementalQuotesToSet
                        |> SupplementalPlanSet.intersect 3 model.supplementalPlans
            in
            ( Model
                { model
                    | supplementalPlans = supplementalPlans
                    , supplementalQuotes = RemoteData.Success supplementalQuotes
                }
            , Effect.none
            )

        CompletedListSupplementalQuotesByClientIdAndEffectiveDate result ->
            ( Model { model | supplementalQuotes = RemoteData.fromResult result }
            , Effect.none
            )

        GotDentalTableMsg dentalTable ->
            ( Model { model | dentalTable = dentalTable }
            , Effect.none
            )

        GotSupTableMsg supTable ->
            ( Model { model | supplementalTable = supTable }
            , Effect.none
            )

        NoOp ->
            ( Model model, Effect.none )



-- SUBSCRIPTIONS


subscriptions : Model -> Sub Msg
subscriptions model =
    Browser.Events.onClick (Json.Decode.succeed ClickedDocument)



--VIEW


view : Shared.Model -> Model -> Html Msg
view shared (Model model) =
    let
        supplementalQuotes =
            let
                isFilterMember supplementalQuote =
                    case model.carrierGroup of
                        Preferred ->
                            supplementalQuote.carrier.isPreferred

                        Supported ->
                            True

                        All ->
                            True
            in
            RemoteData.map (List.filter isFilterMember) model.supplementalQuotes
    in
    Html.form [ class "space-y-6 mb-12" ]
        [ -- EFFECTIVE DATE
          div []
            [ label [ for "effectiveDate", class "text-xl text-gray-950 font-semibold block mb-[6px]" ] [ text "Effective date" ]
            , viewEffectiveDateSelect (Model model)
            ]

        -- IRMAA BRACKETS
        , case model.irmaaBrackets of
            RemoteData.NotAsked ->
                viewNothing

            RemoteData.Loading ->
                div [ class "space-y-[6px]" ]
                    [ label [ class "text-xl text-gray-950 font-semibold block mb-[6px]" ] [ text "IRMAA bracket" ]
                    , div [ class "text-gray-400" ] [ UI.Icon.default UI.Icon.Loading4Animated ]
                    ]

            RemoteData.Success irmaaBrackets ->
                div [ class "space-y-[6px]" ]
                    [ label [ class "text-xl text-gray-950 font-semibold block" ] [ text "IRMAA bracket" ]
                    , viewIrmaaBracketSelect (Model model) irmaaBrackets
                    , viewIrmaaBracketYearDescription irmaaBrackets
                    ]

            RemoteData.Failure _ ->
                div [ class "space-y-[6px]" ]
                    [ label [ class "text-xl text-gray-950 font-semibold block" ] [ text "IRMAA bracket" ]
                    , div [ class "text-red-600" ] [ text "Unable to load irmaa brackets. Please try again." ]
                    ]

        -- DRUG PLAN
        , case model.drugQuotes of
            RemoteData.NotAsked ->
                viewNothing

            RemoteData.Loading ->
                div [ class "space-y-[6px]" ]
                    [ label [ class "text-xl text-gray-950 font-semibold block" ] [ text "Drug plan" ]
                    , div [ class "text-gray-400" ] [ UI.Icon.default UI.Icon.Loading4Animated ]
                    ]

            RemoteData.Success drugQuotes ->
                div [ class "space-y-[6px]" ]
                    [ label [ class "text-xl text-gray-950 font-semibold block" ] [ text "Drug plan" ]
                    , viewDrugQuoteSelect (Model model) drugQuotes
                    , viewDrugQuoteYearDescription drugQuotes
                    ]

            RemoteData.Failure _ ->
                div [ class "space-y-[6px]" ]
                    [ label [ class "text-xl text-gray-950 font-semibold block" ] [ text "Drug plan" ]
                    , div [ class "text-red-600" ] [ text "Unable to load prescription drug plans. Please try again." ]
                    ]

        -- SUPPLEMENTAL PLANS
        , case supplementalQuotes of
            RemoteData.NotAsked ->
                viewNothing

            RemoteData.Loading ->
                div [ class "space-y-[6px]" ]
                    [ viewSupTableHeader (Model model)
                    , div [ class "text-gray-400" ] [ UI.Icon.default UI.Icon.Loading4Animated ]
                    ]

            RemoteData.Success [] ->
                div [ class "space-y-[6px]" ]
                    [ viewSupTableHeader (Model model)
                    , div [ class "px-10 py-6 text-gray-500 border border-gray-300 rounded-lg text-center" ]
                        [ text "No supplemental quotes available."
                        ]
                    ]

            RemoteData.Success supQuotes_ ->
                div [ class "space-y-[6px]" ]
                    [ viewSupTableHeader (Model model)
                    , div [ class "border-y border-gray-300" ]
                        [ Table.view (viewSupTable (Model model)) model.supplementalTable (supQuotesToSupTableRows supQuotes_) ]
                    ]

            RemoteData.Failure _ ->
                div [ class "space-y-[6px]" ]
                    [ viewSupTableHeader (Model model)
                    , div [ class "text-red-600" ] [ text "Unable to load supplemental plan. Please try again." ]
                    ]

        -- DENTAL HEARING AND VISION PLANS
        , case model.dentalQuotes of
            RemoteData.NotAsked ->
                viewNothing

            RemoteData.Loading ->
                div [ class "space-y-[6px]" ]
                    [ div [ class "text-xl text-gray-950 font-semibold" ] [ text "Dental, hearing & vision plans" ]
                    , div [ class "text-gray-400" ] [ UI.Icon.default UI.Icon.Loading4Animated ]
                    ]

            RemoteData.Success [] ->
                div [ class "space-y-[6px]" ]
                    [ div [ class "text-xl text-gray-950 font-semibold " ] [ text "Dental, hearing & vision plans" ]
                    , div [ class "px-10 py-6 text-gray-500 border border-gray-300 rounded-lg text-center" ]
                        [ text "No dental, hearing & vision plans available."
                        ]
                    ]

            RemoteData.Success quotes ->
                div [ class "space-y-[6px]" ]
                    [ div [ class "text-xl text-gray-950 font-semibold " ] [ text "Dental, hearing & vision plans" ]
                    , div [ class "border-y border-gray-300 mb-2" ]
                        [ Table.view (viewDentalTable (Model model) quotes) model.dentalTable (dentalQuotesToDentalTableRows quotes)
                        ]
                    ]

            RemoteData.Failure _ ->
                div [ class "space-y-[6px]" ]
                    [ label [ class "text-xl text-gray-950 font-semibold block" ] [ text "Dental, hearing & vision plans" ]
                    , div [ class "text-red-600" ] [ text "Unable to load dental, vision & hearing plans. Please try again." ]
                    ]
        ]


viewEffectiveDateSelect : Model -> Html Msg
viewEffectiveDateSelect (Model model) =
    let
        dateToPair date =
            ( Just date, Date.format "MMMM y" date )

        emptyOption =
            ( Nothing, "" )

        options =
            model.effectiveDates
                |> effectiveDatesToList
                |> List.map dateToPair
    in
    UI.Select.fromValuesWithLabels model.effectiveDate ChangedEffectiveDate [ id "effectiveDate" ] (emptyOption :: options)


viewIrmaaBracketSelect : Model -> List Server.IrmaaBracket -> Html Msg
viewIrmaaBracketSelect (Model model) irmaaBrackets =
    let
        toOptionConfig irmaaBracket =
            let
                filingAmount =
                    irmaaBracketFilingAmount irmaaBracket

                isSelected =
                    if Tuple.first model.irmaaFilingAmount == irmaaBracket.filingType then
                        case ( irmaaBracket.fromCents, irmaaBracket.toCents ) of
                            ( 0, Just toCents ) ->
                                Tuple.second model.irmaaFilingAmount < toCents

                            ( fromCents, Just toCents ) ->
                                Tuple.second model.irmaaFilingAmount >= irmaaBracket.fromCents && Tuple.second model.irmaaFilingAmount < toCents

                            ( fromCents, Nothing ) ->
                                Tuple.second model.irmaaFilingAmount >= irmaaBracket.fromCents

                    else
                        False

                label =
                    case ( irmaaBracket.fromCents, irmaaBracket.toCents ) of
                        ( 0, Just toCents ) ->
                            "< " ++ Cents.toString toCents

                        ( fromCents, Just toCents ) ->
                            Cents.toString fromCents ++ " to " ++ Cents.toString toCents

                        ( fromCents, Nothing ) ->
                            "> " ++ Cents.toString fromCents

                value =
                    String.fromInt irmaaBracket.id
            in
            { filingType = irmaaBracket.filingType
            , filingAmount = filingAmount
            , isSelected = isSelected
            , value = value
            , label = label
            }

        optionConfigs =
            List.map toOptionConfig irmaaBrackets

        withFilingType filingType irmaaBracket =
            irmaaBracket.filingType == filingType

        filingAmountFromValue value =
            optionConfigs
                |> List.filter (\cfg -> cfg.value == value)
                |> List.map (\cfg -> ( cfg.filingType, cfg.filingAmount ))
                |> List.head
                |> Maybe.withDefault model.irmaaFilingAmount

        individualBrackets =
            List.filter (withFilingType Server.FilingTypeIndividual) optionConfigs

        marriedFilingJointlyBrackets =
            List.filter (withFilingType Server.FilingTypeMarriedFilingJointly) optionConfigs

        marriedFilingSeparatelyBrackets =
            List.filter (withFilingType Server.FilingTypeMarriedFilingSeparately) optionConfigs

        toOption config =
            option [ value config.value, selected config.isSelected ] [ text config.label ]
    in
    select [ onInput (filingAmountFromValue >> ChangedIrmaaFilingAmount) ]
        [ optgroup [ AttrExt.label "Individual" ] (List.map toOption individualBrackets)
        , optgroup [ AttrExt.label "Married filing jointly" ] (List.map toOption marriedFilingJointlyBrackets)
        , optgroup [ AttrExt.label "Married filing separately" ] (List.map toOption marriedFilingSeparatelyBrackets)
        ]


viewIrmaaBracketYearDescription : List Server.IrmaaBracket -> Html Msg
viewIrmaaBracketYearDescription irmaaBrackets =
    case List.head irmaaBrackets of
        Just first ->
            div [ class "text-xs text-gray-500" ] [ text (String.fromInt first.year ++ " IRMAA brackets.") ]

        Nothing ->
            viewNothing


viewDrugQuoteSelect : Model -> List Server.DrugQuote -> Html Msg
viewDrugQuoteSelect (Model model) drugQuotes =
    let
        toOptionConfig drugQuote =
            let
                label =
                    drugQuote.companyName ++ " / " ++ drugQuote.planName ++ " - " ++ Cents.toString drugQuote.monthlyRateCents

                value =
                    String.fromInt drugQuote.id

                isSelected =
                    model.drugPlanKey == Just ( drugQuote.contractId, drugQuote.planId )

                drugPlanKey =
                    ( drugQuote.contractId, drugQuote.planId )
            in
            { label = label
            , value = value
            , isSelected = isSelected
            , drugPlanKey = drugPlanKey
            }

        optionConfigs =
            List.map toOptionConfig drugQuotes

        drugPlanKeyFromValue value =
            optionConfigs
                |> List.filter (\cfg -> cfg.value == value)
                |> List.map .drugPlanKey
                |> List.head

        toOption config =
            option [ value config.value, selected config.isSelected ] [ text config.label ]

        emptyOption =
            option [ value "", selected (model.drugPlanKey == Nothing) ] [ text "None" ]
    in
    select [ id "drugPlan", onInput (drugPlanKeyFromValue >> ChangedDrugPlan) ]
        (emptyOption :: List.map toOption optionConfigs)


viewDrugQuoteYearDescription : List Server.DrugQuote -> Html Msg
viewDrugQuoteYearDescription drugQuotes =
    case List.head drugQuotes of
        Just first ->
            div [ class "text-xs text-gray-500" ] [ text (String.fromInt first.contractYear ++ " prescription drug plans.") ]

        Nothing ->
            viewNothing


viewSupTableHeader : Model -> Html Msg
viewSupTableHeader (Model model) =
    let
        showDeselectAll =
            not <| SupplementalPlanSet.isEmpty model.supplementalPlans
    in
    div [ class "flex items-center gap-2" ]
        [ div [ class "grow text-xl text-gray-950 font-semibold" ] [ text "Supplemental plans" ]

        -- DESELECT ALL
        , if showDeselectAll then
            UI.Button.new "Deselect all"
                |> UI.Button.withSize UI.Button.ExtraSmall
                |> UI.Button.withIcon UI.Icon.XClose
                |> UI.Button.withIconPosition UI.Button.Left
                |> UI.Button.withStyle UI.Button.Secondary
                |> UI.Button.withDestructive True
                |> UI.Button.withType (UI.Button.Button ClickedDeselectAllSupRates)
                |> UI.Button.view

          else
            viewNothing

        -- APPLY DISCOUNTS
        , div [ class "relative", alwaysStopPropagationOn "click" NoOp ]
            [ UI.Button.new "Apply discounts"
                |> UI.Button.withSize UI.Button.ExtraSmall
                |> UI.Button.withIcon UI.Icon.ChevronDown
                |> UI.Button.withIconPosition UI.Button.Right
                |> UI.Button.withStyle UI.Button.Secondary
                |> UI.Button.withType (UI.Button.Button ClickedDiscounts)
                |> UI.Button.view
            , div [ classList [ ( "absolute bg-white right-0 top-full mt-1 rounded-lg border border-300 shadow-md p-4 space-y-4", True ), ( "hidden", not model.showDiscountsMenu ) ] ]
                [ div [ class "font-semibold text-gray-950 whitespace-nowrap" ] [ text "Apply discounts" ]
                , label [ class "flex items-center gap-1 whitespace-nowrap" ]
                    [ input [ type_ "checkbox", checked model.hasMultiInsuredDiscount, onClick ClickedMultiInsuredDiscount ] []
                    , span [] [ text "Multi insured" ]
                    ]
                , label [ class "flex items-center gap-1 whitespace-nowrap" ]
                    [ input [ type_ "checkbox", checked model.hasLivingWithSomeoneDiscount, onClick ClickedLivingWithSomeoneDiscount ] []
                    , span [] [ text "Living with someone" ]
                    ]
                ]
            ]

        -- PLANS
        , div [ class "relative", alwaysStopPropagationOn "click" NoOp ]
            [ UI.Button.new "Plans"
                |> UI.Button.withSize UI.Button.ExtraSmall
                |> UI.Button.withIcon UI.Icon.ChevronDown
                |> UI.Button.withIconPosition UI.Button.Right
                |> UI.Button.withStyle UI.Button.Secondary
                |> UI.Button.withType (UI.Button.Button ClickedPlans)
                |> UI.Button.view
            , div [ classList [ ( "absolute bg-white right-0 top-full mt-1 rounded-lg border border-300 shadow-md p-4 space-y-4", True ), ( "hidden", not model.showPlansMenu ) ] ]
                [ div [ class "font-semibold text-gray-950 whitespace-nowrap" ] [ text "Plans" ]
                , div [ class "flex items-center flex-nowrap gap-4" ]
                    [ label [ class "flex items-center gap-1 whitespace-nowrap" ]
                        [ input [ type_ "checkbox", checked (AnySet.member Server.SupplementalPlanTypeG model.selectedSupplementalPlanTypes), onClick (ClickedSupplementalPlanType Server.SupplementalPlanTypeG) ] []
                        , span [] [ text "G" ]
                        ]
                    , label [ class "flex items-center gap-1 whitespace-nowrap" ]
                        [ input [ type_ "checkbox", checked (AnySet.member Server.SupplementalPlanTypeN model.selectedSupplementalPlanTypes), onClick (ClickedSupplementalPlanType Server.SupplementalPlanTypeN) ] []
                        , span [] [ text "N" ]
                        ]
                    , label [ class "flex items-center gap-1 whitespace-nowrap" ]
                        [ input [ type_ "checkbox", checked (AnySet.member Server.SupplementalPlanTypeF model.selectedSupplementalPlanTypes), onClick (ClickedSupplementalPlanType Server.SupplementalPlanTypeF) ] []
                        , span [] [ text "F" ]
                        ]
                    ]
                ]
            ]

        -- CATEGORIES
        , div [ class "relative", alwaysStopPropagationOn "click" NoOp ]
            [ UI.Button.new "Carriers"
                |> UI.Button.withSize UI.Button.ExtraSmall
                |> UI.Button.withIcon UI.Icon.ChevronDown
                |> UI.Button.withIconPosition UI.Button.Right
                |> UI.Button.withStyle UI.Button.Secondary
                |> UI.Button.withType (UI.Button.Button ClickedCarriers)
                |> UI.Button.view
            , div [ classList [ ( "absolute bg-white right-0 top-full mt-1 rounded-lg border border-300 shadow-md p-4 space-y-4", True ), ( "hidden", not model.showCarrierGroupMenu ) ] ]
                [ label [ class "font-semibold text-gray-950 whitespace-nowrap" ] [ text "Carriers" ]
                , UI.Select.fromValuesWithLabels model.carrierGroup
                    ChangedCarrierGroup
                    []
                    [ ( Preferred, "Preferred" )
                    , ( Supported, "Supported" )
                    , ( All, "All" )
                    ]
                ]
            ]
        ]


type alias SupTableRow =
    { carrier : Server.Carrier
    , planG : Maybe Server.SupplementalQuote
    , planN : Maybe Server.SupplementalQuote
    , planF : Maybe Server.SupplementalQuote
    }


viewSupTable : Model -> Table.Config SupTableRow Msg
viewSupTable (Model model) =
    let
        planTypeSelected planType =
            AnySet.member planType model.selectedSupplementalPlanTypes

        gPlanTypeSelected =
            planTypeSelected Server.SupplementalPlanTypeG

        nPlanTypeSelected =
            planTypeSelected Server.SupplementalPlanTypeN

        fPlanTypeSelected =
            planTypeSelected Server.SupplementalPlanTypeF

        isCarrierChecked quote =
            SupplementalPlanSet.carrierMember quote.carrier.naic model.supplementalPlans

        isPlanChecked quote planType =
            SupplementalPlanSet.member quote.carrier.naic planType model.supplementalPlans

        onClickPlan quote planType =
            onClick (ClickedSupplementalPlan quote.carrier.naic planType)

        monthlyRate quote =
            if model.hasMultiInsuredDiscount && quote.multiInsuredDiscountRateCents /= Nothing then
                Maybe.withDefault 0 quote.multiInsuredDiscountRateCents

            else if model.hasLivingWithSomeoneDiscount && quote.livingWithSomeoneDiscountRateCents /= Nothing then
                Maybe.withDefault 0 quote.livingWithSomeoneDiscountRateCents

            else
                quote.monthlyRateCents

        thead headers =
            Table.HtmlDetails [ class "text-xs font-semibold" ] (List.map theadCell headers)

        theadSortIcon status =
            case status of
                Table.Unsortable ->
                    text ""

                Table.Sortable selected ->
                    if selected then
                        span [ class "text-black cursor-pointer" ] [ text " ↓" ]

                    else
                        span [ class "text-gray-300 cursor-pointer" ] [ text " ↓" ]

                Table.Reversible Nothing ->
                    span [ class "text-gray-300 cursor-pointer" ] [ text " ↕" ]

                Table.Reversible (Just isReversed) ->
                    if isReversed then
                        span [ class "text-black cursor-pointer" ] [ text " ↑" ]

                    else
                        span [ class "text-black cursor-pointer" ] [ text " ↓" ]

        theadCell ( name, status, click ) =
            case name of
                "Company" ->
                    th [ class "text-left ", click ]
                        [ span [ class "cursor-pointer" ] [ text name ]
                        , theadSortIcon status
                        ]

                "G Rate" ->
                    th [ classList [ ( "text-right py-3 pl-3", True ), ( "hidden", not gPlanTypeSelected ) ], click ]
                        [ span [ class "cursor-pointer" ] [ text name ]
                        , theadSortIcon status
                        ]

                "N Rate" ->
                    th [ classList [ ( "text-right py-3 pl-3", True ), ( "hidden", not nPlanTypeSelected ) ], click ]
                        [ span [ class "cursor-pointer" ] [ text name ]
                        , theadSortIcon status
                        ]

                "F Rate" ->
                    th [ classList [ ( "text-right py-3 pl-3", True ), ( "hidden", not fPlanTypeSelected ) ], click ]
                        [ span [ class "cursor-pointer" ] [ text name ]
                        , theadSortIcon status
                        ]

                _ ->
                    th [] []

        companyCol row =
            Table.HtmlDetails [ class "" ]
                [ div [ class "flex items-center gap-2" ]
                    [ input [ type_ "checkbox", checked (isCarrierChecked row), onClick (ClickedSupplementalCarrier row.carrier.naic) ] []
                    , div [ class "font-semibold" ] [ text row.carrier.name ]
                    ]
                ]

        gRateCol row =
            Table.HtmlDetails [ classList [ ( "py-3 pl-3", True ), ( "hidden", not gPlanTypeSelected ) ] ]
                [ case row.planG of
                    Just quote ->
                        div [ class "flex gap-2 items-center justify-end" ]
                            [ div [ class "text-gray-500 tabular-nums" ] [ text (Cents.toString (monthlyRate quote)) ]
                            , input
                                [ type_ "checkbox"
                                , checked (isPlanChecked row Server.SupplementalPlanTypeG)
                                , onClickPlan row Server.SupplementalPlanTypeG
                                ]
                                []
                            ]

                    Nothing ->
                        text ""
                ]

        nRateCol row =
            Table.HtmlDetails [ classList [ ( "py-3 pl-3", True ), ( "hidden", not nPlanTypeSelected ) ] ]
                [ case row.planN of
                    Just quote ->
                        div [ class "flex gap-2 items-center justify-end " ]
                            [ div [ class "text-gray-500 tabular-nums" ] [ text (Cents.toString (monthlyRate quote)) ]
                            , input
                                [ type_ "checkbox"
                                , checked (isPlanChecked row Server.SupplementalPlanTypeN)
                                , onClickPlan row Server.SupplementalPlanTypeN
                                ]
                                []
                            ]

                    Nothing ->
                        text ""
                ]

        fRateCol row =
            Table.HtmlDetails [ classList [ ( "py-3 pl-3", True ), ( "hidden", not fPlanTypeSelected ) ] ]
                [ case row.planF of
                    Just quote ->
                        div [ class "flex gap-2 items-center justify-end" ]
                            [ div [ class "text-gray-500 tabular-nums" ] [ text (Cents.toString (monthlyRate quote)) ]
                            , input
                                [ type_ "checkbox"
                                , checked (isPlanChecked row Server.SupplementalPlanTypeF)
                                , onClickPlan row Server.SupplementalPlanTypeF
                                ]
                                []
                            ]

                    Nothing ->
                        text ""
                ]
    in
    Table.customConfig
        { toId = \row -> row.carrier.naic
        , toMsg = GotSupTableMsg
        , columns =
            [ Table.veryCustomColumn
                { name = "Company"
                , viewData = companyCol
                , sorter = Table.increasingOrDecreasingBy (\row -> row.carrier.name)
                }
            , Table.veryCustomColumn
                { name = "G Rate"
                , viewData = gRateCol
                , sorter = Table.increasingOrDecreasingBy (\row -> row.planG |> Maybe.map monthlyRate |> Maybe.withDefault 0)
                }
            , Table.veryCustomColumn
                { name = "N Rate"
                , viewData = nRateCol
                , sorter = Table.increasingOrDecreasingBy (\row -> row.planN |> Maybe.map monthlyRate |> Maybe.withDefault 0)
                }
            , Table.veryCustomColumn
                { name = "F Rate"
                , viewData = fRateCol
                , sorter = Table.increasingOrDecreasingBy (\row -> row.planF |> Maybe.map monthlyRate |> Maybe.withDefault 0)
                }
            ]
        , customizations =
            { defaultCustomizations
                | tableAttrs = [ class "w-full border-collapse" ]
                , rowAttrs = \_ -> [ class "border-t border-gray-[#EBEBEB]" ]
                , thead = thead
            }
        }


type alias DentalTableRow =
    Maybe Server.DentalQuote


dentalQuotesToDentalTableRows : List Server.DentalQuote -> List DentalTableRow
dentalQuotesToDentalTableRows quotes =
    Nothing :: List.map Just quotes


viewDentalTable : Model -> List Server.DentalQuote -> Table.Config DentalTableRow Msg
viewDentalTable (Model model) dentalQuotes =
    let
        isQuoteSelected : Server.DentalQuote -> Bool
        isQuoteSelected quote =
            case model.dentalPlanKey of
                Just dentalPlanKey ->
                    dentalPlanKey == ( quote.carrierNaic, quote.annualBenefitCents )

                Nothing ->
                    False

        isNoneSelected =
            case model.dentalPlanKey of
                Nothing ->
                    True

                Just key ->
                    dentalQuotes
                        |> List.map (\dq -> ( dq.carrierNaic, dq.annualBenefitCents ))
                        |> List.member key
                        |> not

        thead headers =
            Table.HtmlDetails [ class "text-xs font-semibold" ] (List.map theadCell headers)

        theadSortIcon status =
            case status of
                Table.Unsortable ->
                    text ""

                Table.Sortable selected ->
                    if selected then
                        span [ class "text-black cursor-pointer" ] [ text " ↓" ]

                    else
                        span [ class "text-gray-300 cursor-pointer" ] [ text " ↓" ]

                Table.Reversible Nothing ->
                    span [ class "text-gray-300 cursor-pointer" ] [ text " ↕" ]

                Table.Reversible (Just isReversed) ->
                    if isReversed then
                        span [ class "text-black cursor-pointer" ] [ text " ↑" ]

                    else
                        span [ class "text-black cursor-pointer" ] [ text " ↓" ]

        theadCell ( name, status, click ) =
            case name of
                "Company" ->
                    th [ class "py-3 text-left whitespace-nowrap text-xs font-semibold", click ]
                        [ span [ class "cursor-pointer" ] [ text name ]
                        , theadSortIcon status
                        ]

                "Max annual benefit" ->
                    th [ class "py-3 pl-2 text-right whitespace-nowrap text-xs font-semibold", click ]
                        [ span [ class "cursor-pointer" ] [ text name ]
                        , theadSortIcon status
                        ]

                "Monthly premium" ->
                    th [ class "py-3 pl-2 text-right whitespace-nowrap text-xs font-semibold", click ]
                        [ span [ class "cursor-pointer" ] [ text name ]
                        , theadSortIcon status
                        ]

                _ ->
                    th [] []

        companyCol row =
            case row of
                Just quote ->
                    Table.HtmlDetails [ class "py-3" ]
                        [ div [ class "flex items-center gap-2" ]
                            [ input [ type_ "radio", name "dental_plan", checked (isQuoteSelected quote), onClick (ChangedDentalPlan (Just ( quote.carrierNaic, quote.annualBenefitCents ))) ] []
                            , div [ class "font-medium" ] [ text quote.carrierName ]
                            ]
                        ]

                Nothing ->
                    Table.HtmlDetails [ class "py-3" ]
                        [ div [ class "flex items-center gap-2 " ]
                            [ input [ type_ "radio", name "dental_plan", checked isNoneSelected, onClick (ChangedDentalPlan Nothing) ] []
                            , div [ class "font-medium" ] [ text "None" ]
                            ]
                        ]

        companySort row =
            case row of
                Just quote ->
                    quote.carrierName

                Nothing ->
                    case Table.getSortState model.dentalTable of
                        ( "Company", False ) ->
                            ""

                        ( "Company", True ) ->
                            "zzzzzzzzzzzzzzzz"

                        _ ->
                            ""

        annualBenefitCol row =
            case row of
                Just quote ->
                    Table.HtmlDetails [ class "py-3 pl-2 text-gray-500 tabular-nums text-right" ]
                        [ text (Cents.toString quote.annualBenefitCents)
                        ]

                Nothing ->
                    Table.HtmlDetails [] []

        annualBenefitSort row =
            case row of
                Just quote ->
                    quote.annualBenefitCents

                Nothing ->
                    case Table.getSortState model.dentalTable of
                        ( "Max annual benefit", False ) ->
                            0

                        ( "Max annual benefit", True ) ->
                            999999999999

                        _ ->
                            0

        monthlyRateCol row =
            case row of
                Just quote ->
                    Table.HtmlDetails [ class "py-3 pl-2 text-gray-500 tabular-nums text-right" ]
                        [ text (Cents.toString quote.monthlyRateCents)
                        ]

                Nothing ->
                    Table.HtmlDetails [] []

        monthlyRateSort row =
            case row of
                Just quote ->
                    quote.monthlyRateCents

                Nothing ->
                    case Table.getSortState model.dentalTable of
                        ( "Monthly premium", False ) ->
                            0

                        ( "Monthly premium", True ) ->
                            999999999999

                        _ ->
                            0

        toId row =
            Maybe.map (\dq -> dq.carrierNaic ++ String.fromInt dq.annualBenefitCents) row
                |> Maybe.withDefault "no-dental-plan"
    in
    Table.customConfig
        { toId = toId
        , toMsg = GotDentalTableMsg
        , columns =
            [ Table.veryCustomColumn
                { name = "Company"
                , viewData = companyCol
                , sorter = Table.increasingOrDecreasingBy companySort
                }
            , Table.veryCustomColumn
                { name = "Max annual benefit"
                , viewData = annualBenefitCol
                , sorter = Table.increasingOrDecreasingBy annualBenefitSort
                }
            , Table.veryCustomColumn
                { name = "Monthly premium"
                , viewData = monthlyRateCol
                , sorter = Table.increasingOrDecreasingBy monthlyRateSort
                }
            ]
        , customizations =
            { defaultCustomizations
                | tableAttrs = [ class "w-full border-collapse" ]
                , rowAttrs = \_ -> [ class "border-t border-[#EBEBEB]" ]
                , thead = thead
            }
        }


viewNothing : Html Msg
viewNothing =
    text ""



-- VALIDATION


type Field
    = EffectiveDate
    | IrmaaBracket
    | DrugPlan
    | SupplementalPlans
    | DentalPlan


fieldToInt : Field -> Int
fieldToInt field =
    case field of
        EffectiveDate ->
            0

        IrmaaBracket ->
            1

        DrugPlan ->
            2

        SupplementalPlans ->
            3

        DentalPlan ->
            4


type alias Errors =
    AnyDict Int Field String


validate : Model -> Errors
validate (Model model) =
    let
        validateEffectiveDate errors =
            case model.effectiveDate of
                Nothing ->
                    AnyDict.insert EffectiveDate "Required" errors

                Just _ ->
                    errors
    in
    AnyDict.empty fieldToInt
        |> validateEffectiveDate



-- EXPORT


type alias Values =
    { effectiveDate : Date
    , irmaaBracketId : Int
    , drugQuoteId : Maybe Int
    , supplementalPlans : List ( String, Server.SupplementalPlanType )
    , dentalQuoteId : Maybe Int
    , hasMultiInsuredDiscount : Bool
    , hasLivingWithSomeoneDiscount : Bool
    }


export : Model -> Maybe Values
export (Model model) =
    let
        toData irmaaBrackets drugQuotes supplementalQuotes dentalQuotes =
            { irmaaBrackets = irmaaBrackets
            , drugQuotes = drugQuotes
            , supplementalQuotes = supplementalQuotes
            , dentalQuotes = dentalQuotes
            }

        data =
            RemoteData.map toData model.irmaaBrackets
                |> RemoteData.andMap model.drugQuotes
                |> RemoteData.andMap model.supplementalQuotes
                |> RemoteData.andMap model.dentalQuotes
    in
    case data of
        RemoteData.Success { irmaaBrackets, drugQuotes, supplementalQuotes, dentalQuotes } ->
            let
                effectiveDate =
                    model.effectiveDate |> Maybe.withDefault (Tuple.first model.effectiveDates)

                irmaaBracketId =
                    let
                        ( filingType, filingAmount ) =
                            model.irmaaFilingAmount

                        isBracketForFilingAmount irmaaBracket =
                            if filingType == irmaaBracket.filingType then
                                case ( irmaaBracket.fromCents, irmaaBracket.toCents ) of
                                    ( 0, Just toCents ) ->
                                        filingAmount < toCents

                                    ( fromCents, Just toCents ) ->
                                        filingAmount >= fromCents && filingAmount < toCents

                                    ( fromCents, Nothing ) ->
                                        filingAmount >= fromCents

                            else
                                False
                    in
                    List.filter isBracketForFilingAmount irmaaBrackets
                        |> List.map .id
                        |> List.head
                        |> Maybe.withDefault 0

                drugQuoteId =
                    case model.drugPlanKey of
                        Just ( contractId, planId ) ->
                            let
                                isQuoteForKey drugQuote =
                                    contractId == drugQuote.contractId && planId == drugQuote.planId
                            in
                            List.filter isQuoteForKey drugQuotes
                                |> List.map .id
                                |> List.head

                        Nothing ->
                            Nothing

                supplementalPlans =
                    SupplementalPlanSet.toList model.supplementalPlans

                dentalQuoteId =
                    case model.dentalPlanKey of
                        Just ( carrierNaic, annualBenefitCents ) ->
                            let
                                isQuoteForKey dentalQuote =
                                    carrierNaic == dentalQuote.carrierNaic && annualBenefitCents == dentalQuote.annualBenefitCents
                            in
                            List.filter isQuoteForKey dentalQuotes
                                |> List.map .id
                                |> List.head

                        Nothing ->
                            Nothing

                hasMultiInsuredDiscount =
                    model.hasMultiInsuredDiscount

                hasLivingWithSomeoneDiscount =
                    model.hasLivingWithSomeoneDiscount
            in
            Just
                { effectiveDate = effectiveDate
                , irmaaBracketId = irmaaBracketId
                , drugQuoteId = drugQuoteId
                , supplementalPlans = supplementalPlans
                , dentalQuoteId = dentalQuoteId
                , hasMultiInsuredDiscount = hasMultiInsuredDiscount
                , hasLivingWithSomeoneDiscount = hasLivingWithSomeoneDiscount
                }

        _ ->
            Nothing


isValid : Model -> Bool
isValid (Model model) =
    RemoteData.map (\_ _ _ _ -> ()) model.irmaaBrackets
        |> RemoteData.andMap model.drugQuotes
        |> RemoteData.andMap model.supplementalQuotes
        |> RemoteData.andMap model.dentalQuotes
        |> RemoteData.isSuccess



-- INTERNAL


irmaaBracketFilingAmount : Server.IrmaaBracket -> Int
irmaaBracketFilingAmount irmaaBracket =
    case irmaaBracket.toCents of
        Just toCents ->
            (irmaaBracket.fromCents + toCents) // 2

        Nothing ->
            irmaaBracket.fromCents + 100


supplementalQuotesToSet : List Server.SupplementalQuote -> SupplementalPlanSet.Set
supplementalQuotesToSet quotes =
    let
        step quote set =
            SupplementalPlanSet.insert quote.carrier.naic quote.planType set
    in
    List.foldl step (SupplementalPlanSet.empty 999999) quotes


supplementalPlansToSet : List Server.SupplementalCarrierPlanType -> SupplementalPlanSet.Set
supplementalPlansToSet plans =
    let
        step supplementalPlan set =
            SupplementalPlanSet.insert supplementalPlan.carrierNaic supplementalPlan.planType set
    in
    List.foldl step (SupplementalPlanSet.empty 3) plans


buildEffectiveDates : Shared.Model -> ( Date, List Date )
buildEffectiveDates shared =
    let
        thisMonth =
            Time.toMonth shared.zone shared.time

        thisYear =
            Time.toYear shared.zone shared.time

        thisMonthDate =
            Date.fromCalendarDate thisYear thisMonth 1

        toDate n =
            Date.add Date.Months n thisMonthDate
    in
    ( toDate 1, List.range 2 12 |> List.map toDate )


effectiveDatesToList : ( Date, List Date ) -> List Date
effectiveDatesToList ( date, dates ) =
    date :: dates


supQuotesToSupTableRows : List Server.SupplementalQuote -> List SupTableRow
supQuotesToSupTableRows quotes =
    let
        newSupTableRow quote =
            case quote.planType of
                Server.SupplementalPlanTypeF ->
                    { carrier = quote.carrier
                    , planF = Just quote
                    , planG = Nothing
                    , planN = Nothing
                    }

                Server.SupplementalPlanTypeG ->
                    { carrier = quote.carrier
                    , planF = Nothing
                    , planG = Just quote
                    , planN = Nothing
                    }

                Server.SupplementalPlanTypeN ->
                    { carrier = quote.carrier
                    , planF = Nothing
                    , planG = Nothing
                    , planN = Just quote
                    }

        step quote rows =
            case rows of
                [] ->
                    [ newSupTableRow quote ]

                first :: rest ->
                    if first.carrier.naic == quote.carrier.naic then
                        case quote.planType of
                            Server.SupplementalPlanTypeF ->
                                { first | planF = Just quote } :: rest

                            Server.SupplementalPlanTypeG ->
                                { first | planG = Just quote } :: rest

                            Server.SupplementalPlanTypeN ->
                                { first | planN = Just quote } :: rest

                    else
                        newSupTableRow quote :: first :: rest
    in
    List.foldr step [] quotes


supplementalPlanTypeComparable : Server.SupplementalPlanType -> Int
supplementalPlanTypeComparable supPlanType =
    case supPlanType of
        Server.SupplementalPlanTypeF ->
            0

        Server.SupplementalPlanTypeG ->
            1

        Server.SupplementalPlanTypeN ->
            2


carrierGroupToServerCarrierGroup : CarrierGroup -> Server.CarrierGroup
carrierGroupToServerCarrierGroup carrierGroup =
    case carrierGroup of
        Preferred ->
            Server.CarrierGroupSupported

        Supported ->
            Server.CarrierGroupSupported

        All ->
            Server.CarrierGroupAll

================
File: frontend/src/PagesExt/Quotes/New/SupplementalPlanSet.elm
================
module PagesExt.Quotes.New.SupplementalPlanSet exposing
    ( Key
    , Set
    , carrierMember
    , empty
    , filterPlanTypes
    , fromList
    , insert
    , insertCarrier
    , intersect
    , isEmpty
    , member
    , memberInAllCarriers
    , remove
    , removeCarrier
    , toList
    , toggle
    , toggleCarrier
    )

import Server
import Set.Any as AnySet exposing (AnySet)


type Set
    = Set
        { set : AnySet String Key
        , maxCarriers : Int
        }


type alias Key =
    ( String, Server.SupplementalPlanType )


empty : Int -> Set
empty maxCarriers =
    Set
        { set = AnySet.empty keyToString
        , maxCarriers = maxCarriers
        }


intersect : Int -> Set -> Set -> Set
intersect maxCarriers (Set a) (Set b) =
    Set
        { set = AnySet.intersect a.set b.set
        , maxCarriers = maxCarriers
        }


isEmpty : Set -> Bool
isEmpty (Set set) =
    AnySet.isEmpty set.set


fromList : Int -> List Key -> Set
fromList maxCarriers keys =
    let
        insertKey ( naic, planType ) set =
            insert naic planType set
    in
    List.foldl insertKey (empty maxCarriers) keys


insert : String -> Server.SupplementalPlanType -> Set -> Set
insert naic planType (Set details) =
    let
        nextDetails =
            { details | set = AnySet.insert ( naic, planType ) details.set }

        nextCarriersNum =
            nextDetails.set
                |> AnySet.filter (\key -> Tuple.second key == planType)
                |> AnySet.size
    in
    if nextCarriersNum <= details.maxCarriers then
        Set nextDetails

    else
        Set details


remove : String -> Server.SupplementalPlanType -> Set -> Set
remove naic planType (Set details) =
    Set { details | set = AnySet.remove ( naic, planType ) details.set }


filterPlanTypes : List Server.SupplementalPlanType -> Set -> Set
filterPlanTypes planTypes (Set details) =
    let
        doFilter ( naic, planType ) =
            List.member planType planTypes
    in
    Set { details | set = AnySet.filter doFilter details.set }


member : String -> Server.SupplementalPlanType -> Set -> Bool
member naic planType (Set details) =
    AnySet.member ( naic, planType ) details.set


toggle : String -> Server.SupplementalPlanType -> Set -> Set
toggle naic planType set =
    if member naic planType set then
        remove naic planType set

    else
        insert naic planType set


insertCarrier : String -> Set -> Set
insertCarrier naic set =
    set
        |> insert naic Server.SupplementalPlanTypeG
        |> insert naic Server.SupplementalPlanTypeN


removeCarrier : String -> Set -> Set
removeCarrier naic set =
    set
        |> remove naic Server.SupplementalPlanTypeF
        |> remove naic Server.SupplementalPlanTypeG
        |> remove naic Server.SupplementalPlanTypeN


carrierMember : String -> Set -> Bool
carrierMember naic set =
    member naic Server.SupplementalPlanTypeF set || member naic Server.SupplementalPlanTypeG set || member naic Server.SupplementalPlanTypeN set


toggleCarrier : String -> Set -> Set
toggleCarrier naic set =
    if carrierMember naic set then
        removeCarrier naic set

    else
        insertCarrier naic set


memberInAllCarriers : Server.SupplementalPlanType -> List String -> Set -> Bool
memberInAllCarriers planType naics set =
    case naics of
        [] ->
            False

        naic :: [] ->
            member naic planType set

        naic :: rest ->
            if member naic planType set then
                memberInAllCarriers planType rest set

            else
                False


toList : Set -> List Key
toList (Set details) =
    AnySet.toList details.set


keyToString : Key -> String
keyToString ( naic, planType ) =
    let
        planTypeStr =
            case planType of
                Server.SupplementalPlanTypeF ->
                    "F"

                Server.SupplementalPlanTypeG ->
                    "G"

                Server.SupplementalPlanTypeN ->
                    "N"
    in
    naic ++ "/" ++ planTypeStr

================
File: frontend/src/Shared/Model.elm
================
module Shared.Model exposing (AgentStatus(..), Model)

{-| -}

import Server
import Time


{-| Normally, this value would live in "Shared.elm"
but that would lead to a circular dependency import cycle.

For that reason, both `Shared.Model` and `Shared.Msg` are in their
own file, so they can be imported by `Effect.elm`

-}
type alias Model =
    { agent : AgentStatus
    , time : Time.Posix
    , zone : Time.Zone
    , oauthGoogleLoginUrl : String
    }


type AgentStatus
    = SignedOut (Maybe Server.Error)
    | SignedIn Server.Agent
    | Loading

================
File: frontend/src/Shared/Msg.elm
================
module Shared.Msg exposing (Msg(..))

{-| -}

import Server
import Time


{-| Normally, this value would live in "Shared.elm"
but that would lead to a circular dependency import cycle.

For that reason, both `Shared.Model` and `Shared.Msg` are in their
own file, so they can be imported by `Effect.elm`

-}
type Msg
    = GotCurrentTime Time.Posix
    | GotCurrentTimeZone Time.Zone
    | CompletedSignOut (Result Server.Error ())
    | CompletedWhoAmI (Result Server.Error Server.Agent)
    | SignOutRequested

================
File: frontend/src/UI/Icon/GoogleG.elm
================
module UI.Icon.GoogleG exposing (view)

import Svg exposing (..)
import Svg.Attributes exposing (..)


view : Int -> Svg msg
view size =
    let
        sizeStr =
            String.fromInt size
    in
    svg [ width sizeStr, height sizeStr, viewBox "0 0 24 24", fill "currentColor" ]
        [ Svg.path [ fillRule "evenodd", clipRule "evenodd", d "M12.1927 5.98182C13.612 5.98182 14.8736 6.49091 15.8811 7.47273L18.6409 4.60909C16.9675 2.99091 14.7948 2 12.1927 2C8.42547 2 5.17511 4.24546 3.58935 7.51818C2.93227 8.86364 2.55554 10.3818 2.55554 12C2.55554 13.6182 2.93227 15.1364 3.58935 16.4818V16.4909C5.17511 19.7545 8.42547 22 12.1927 22C14.7948 22 16.9763 21.1091 18.5708 19.5818C20.3931 17.8364 21.4444 15.2727 21.4444 12.2273C21.4444 11.5182 21.3831 10.8364 21.2692 10.1818H12.1927V14.0545H17.3793C17.1515 15.3 16.4681 16.3545 15.4431 17.0636C14.5845 17.6636 13.4894 18.0273 12.1927 18.0273C9.68706 18.0273 7.55812 16.2727 6.79591 13.9091H6.78446L6.79591 13.9C6.60316 13.3 6.48927 12.6636 6.48927 12C6.48927 11.3364 6.60316 10.7 6.79591 10.1C7.55812 7.73636 9.68706 5.98182 12.1927 5.98182Z" ] []
        ]

================
File: frontend/src/UI/Alert.elm
================
module UI.Alert exposing (..)

import Html exposing (..)
import Html.Attributes exposing (..)
import UI.Icon


error : String -> Html msg
error message =
    div [ class "border border-red-700 bg-red-50 text-red-700 py-3 px-4 space-x-3 flex items-center rounded-lg" ]
        [ UI.Icon.default UI.Icon.AlertTriangle
        , span [] [ text message ]
        ]

================
File: frontend/src/UI/Button.elm
================
module UI.Button exposing
    ( Config
    , IconPosition(..)
    , Size(..)
    , Style(..)
    , Type(..)
    , new
    , view
    , withDestructive
    , withDisabled
    , withIcon
    , withIconPosition
    , withOptionalIcon
    , withSize
    , withStyle
    , withType
    )

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import UI.Icon


type Style
    = Primary
    | Secondary


type IconPosition
    = Left
    | Right


type Size
    = Medium
    | Small
    | ExtraSmall


type Type msg
    = Button msg
    | Submit
    | Link String


type Config msg
    = Config
        { label : String
        , style : Style
        , icon : Maybe UI.Icon.Icon
        , iconPosition : IconPosition
        , size : Size
        , type_ : Type msg
        , isDisabled : Bool
        , isDestructive : Bool
        }


new : String -> Config msg
new label =
    Config
        { label = label
        , style = Primary
        , icon = Nothing
        , iconPosition = Left
        , size = Medium
        , type_ = Submit
        , isDisabled = False
        , isDestructive = False
        }


withStyle : Style -> Config msg -> Config msg
withStyle style (Config config) =
    Config { config | style = style }


withIcon : UI.Icon.Icon -> Config msg -> Config msg
withIcon icon (Config config) =
    Config { config | icon = Just icon }


withOptionalIcon : UI.Icon.Icon -> Bool -> Config msg -> Config msg
withOptionalIcon icon isActive (Config config) =
    let
        maybeIcon =
            if isActive then
                Just icon

            else
                Nothing
    in
    Config { config | icon = maybeIcon }


withIconPosition : IconPosition -> Config msg -> Config msg
withIconPosition iconPosition (Config config) =
    Config { config | iconPosition = iconPosition }


withSize : Size -> Config msg -> Config msg
withSize size (Config config) =
    Config { config | size = size }


withType : Type msg -> Config msg -> Config msg
withType type_ (Config config) =
    Config { config | type_ = type_ }


withDisabled : Bool -> Config msg -> Config msg
withDisabled isDisabled (Config config) =
    Config { config | isDisabled = isDisabled }


withDestructive : Bool -> Config msg -> Config msg
withDestructive isDestructive (Config config) =
    Config { config | isDestructive = isDestructive }


view : Config msg -> Html msg
view (Config config) =
    let
        addGlobalClasses classes =
            "rounded-lg flex items-center transition-colors whitespace-nowrap" :: classes

        addFontWeight classes =
            case config.size of
                Medium ->
                    "font-medium" :: classes

                Small ->
                    "font-medium" :: classes

                ExtraSmall ->
                    classes

        addBackgroundColorClasses classes =
            case ( config.style, config.isDestructive ) of
                ( Primary, False ) ->
                    "bg-[var(--brand-color)]" :: classes

                ( Primary, True ) ->
                    "bg-red-600" :: classes

                ( Secondary, _ ) ->
                    "bg-white" :: classes

        addOpacityClasses classes =
            if config.isDisabled then
                "opacity-50" :: classes

            else
                classes

        addTextColorClasses classes =
            case ( config.style, config.isDestructive ) of
                ( Primary, _ ) ->
                    "text-white" :: classes

                ( Secondary, False ) ->
                    "text-gray-950" :: classes

                ( Secondary, True ) ->
                    "text-red-700" :: classes

        addBorderClasses classes =
            case ( config.style, config.isDestructive ) of
                ( Primary, _ ) ->
                    classes

                ( Secondary, False ) ->
                    "border border-gray-300 hover:border-gray-400" :: classes

                ( Secondary, True ) ->
                    "border border-red-300 hover:border-red-600" :: classes

        addPaddingYClasses classes =
            case config.size of
                Medium ->
                    "py-2" :: classes

                Small ->
                    "py-1" :: classes

                ExtraSmall ->
                    "py-0.5" :: classes

        addPaddingXClasses classes =
            case ( config.size, config.icon, config.iconPosition ) of
                ( Medium, Nothing, _ ) ->
                    "px-[18px]" :: classes

                ( Medium, Just _, Left ) ->
                    "pl-[14px] pr-[18px]" :: classes

                ( Medium, Just _, Right ) ->
                    "pl-[18px] pr-[14px]" :: classes

                ( Small, Nothing, _ ) ->
                    "px-[18px]" :: classes

                ( Small, Just _, Left ) ->
                    "pl-[14px] pr-[18px]" :: classes

                ( Small, Just _, Right ) ->
                    "pl-[18px] pr-[14px]" :: classes

                ( ExtraSmall, Nothing, _ ) ->
                    "px-[12px]" :: classes

                ( ExtraSmall, Just _, Left ) ->
                    "pl-[8px] pr-[12px]" :: classes

                ( ExtraSmall, Just _, Right ) ->
                    "pl-[12px] pr-[8px]" :: classes

        addSpacingClasses classes =
            "space-x-1" :: classes

        addClassAttribute attributes =
            (addGlobalClasses []
                |> addBackgroundColorClasses
                |> addFontWeight
                |> addOpacityClasses
                |> addTextColorClasses
                |> addBorderClasses
                |> addPaddingYClasses
                |> addPaddingXClasses
                |> addSpacingClasses
                |> String.join " "
                |> class
            )
                :: attributes

        addTypeAttribute attributes =
            case config.type_ of
                Button _ ->
                    type_ "button" :: attributes

                Submit ->
                    type_ "submit" :: attributes

                Link _ ->
                    attributes

        addHrefAttribute attributes =
            case config.type_ of
                Button _ ->
                    attributes

                Submit ->
                    attributes

                Link href_ ->
                    href href_ :: attributes

        addOnClickEvent attributes =
            case config.type_ of
                Button onClick_ ->
                    onClick onClick_ :: attributes

                Submit ->
                    attributes

                Link _ ->
                    attributes

        addDisabledAttribute attributes =
            case config.type_ of
                Button _ ->
                    disabled config.isDisabled :: attributes

                Submit ->
                    disabled config.isDisabled :: attributes

                Link _ ->
                    attributes

        buttonAttributes =
            addClassAttribute []
                |> addTypeAttribute
                |> addHrefAttribute
                |> addDisabledAttribute
                |> addOnClickEvent

        buttonChildren =
            addRightIcon []
                |> addLabel
                |> addLeftIcon

        addLeftIcon children =
            case ( config.icon, config.iconPosition ) of
                ( Just icon, Left ) ->
                    (UI.Icon.new icon |> UI.Icon.withSize 16 |> UI.Icon.view) :: children

                _ ->
                    children

        addLabel children =
            span [] [ text config.label ] :: children

        addRightIcon children =
            case ( config.icon, config.iconPosition ) of
                ( Just icon, Right ) ->
                    (UI.Icon.new icon |> UI.Icon.withSize 16 |> UI.Icon.view) :: children

                _ ->
                    children

        buttonNode attributes_ children_ =
            case ( config.type_, config.isDisabled ) of
                ( Button _, _ ) ->
                    button attributes_ children_

                ( Submit, _ ) ->
                    button attributes_ children_

                ( Link _, False ) ->
                    a attributes_ children_

                ( Link _, True ) ->
                    span attributes_ children_
    in
    buttonNode buttonAttributes buttonChildren

================
File: frontend/src/UI/Cents.elm
================
module UI.Cents exposing (toString)


toString : Int -> String
toString cents =
    let
        centsStr =
            cents
                |> String.fromInt
                |> String.right 2
                |> String.padLeft 2 '0'

        dollarStr =
            cents
                |> String.fromInt
                |> String.dropRight 2
                |> centsToDollarStringHelp
                |> String.padLeft 1 '0'
    in
    "$" ++ dollarStr ++ "." ++ centsStr


centsToDollarStringHelp : String -> String
centsToDollarStringHelp dollars =
    let
        last3 =
            String.right 3 dollars

        rest =
            String.dropRight 3 dollars
    in
    case rest of
        "" ->
            last3

        _ ->
            centsToDollarStringHelp rest ++ "," ++ last3

================
File: frontend/src/UI/ErrorPage.elm
================
module UI.ErrorPage exposing (..)

import Html exposing (..)
import Html.Attributes exposing (..)
import Html.Events exposing (..)
import UI.Icon


view : String -> Html msg
view message =
    div [ class "fixed inset-0 p-5 flex items-center justify-center" ]
        [ div [ class "text-gray-800" ]
            [ div [ class "flex justify-center" ]
                [ UI.Icon.new UI.Icon.AlertTriangle
                    |> UI.Icon.withSize 30
                    |> UI.Icon.view
                ]
            , div [ class "font-semibold text-xl text-center" ] [ text message ]
            ]
        ]

================
File: frontend/src/UI/Icon.elm
================
module UI.Icon exposing (Config, Icon(..), default, new, view, withFill, withSize, withStroke, withStrokeWidth)

import Svg exposing (..)
import Svg.Attributes exposing (..)


type Config
    = Config
        { icon : Icon
        , size : String
        , strokeWidth : String
        , stroke : String
        , fill : String
        }


type Icon
    = AlertCircle
    | AlertTriangle
    | ArrowNarrowLeft
    | Browser
    | Brush3
    | Camera1
    | CheckCircle
    | ChevronDown
    | ChevronRight
    | Cube2
    | Edit2
    | Eye
    | EyeOff
    | File2
    | File6
    | FlexAlignBottom
    | Grid1
    | HelpCircle
    | Image3
    | LifeBuoy1
    | Link2
    | LinkExternal1
    | Loading4Animated
    | LogOut1
    | MessageTextSquare2
    | Monitor1
    | Placeholder
    | Phone1
    | Plus
    | SearchMd
    | Send1
    | Settings1
    | SlashDivider
    | Trash1
    | Upload1
    | Upload2
    | Upload3
    | UploadCloud2
    | User1
    | UserCircle
    | XClose


default : Icon -> Svg msg
default icon =
    new icon |> view


new : Icon -> Config
new icon =
    Config
        { icon = icon
        , strokeWidth = "1.5"
        , size = "20"
        , stroke = "currentColor"
        , fill = "none"
        }


withSize : Int -> Config -> Config
withSize size (Config config) =
    Config { config | size = String.fromInt size }


withStrokeWidth : Float -> Config -> Config
withStrokeWidth strokeWidth (Config config) =
    Config { config | strokeWidth = String.fromFloat strokeWidth }


withStroke : String -> Config -> Config
withStroke color (Config config) =
    Config { config | stroke = color }


withFill : String -> Config -> Config
withFill color (Config config) =
    Config { config | fill = color }


view : Config -> Svg msg
view (Config config) =
    case config.icon of
        AlertCircle ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M12 8V12M12 16H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" ] []
                ]

        AlertTriangle ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M11.9998 8.99999V13M11.9998 17H12.0098M10.6151 3.89171L2.39019 18.0983C1.93398 18.8863 1.70588 19.2803 1.73959 19.6037C1.769 19.8857 1.91677 20.142 2.14613 20.3088C2.40908 20.5 2.86435 20.5 3.77487 20.5H20.2246C21.1352 20.5 21.5904 20.5 21.8534 20.3088C22.0827 20.142 22.2305 19.8857 22.2599 19.6037C22.2936 19.2803 22.0655 18.8863 21.6093 18.0983L13.3844 3.89171C12.9299 3.10654 12.7026 2.71396 12.4061 2.58211C12.1474 2.4671 11.8521 2.4671 11.5935 2.58211C11.2969 2.71396 11.0696 3.10655 10.6151 3.89171Z" ] []
                ]

        ArrowNarrowLeft ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M20 12H4M4 12L10 18M4 12L10 6" ] []
                ]

        Browser ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M22 9H2M2 7.8L2 16.2C2 17.8802 2 18.7202 2.32698 19.362C2.6146 19.9265 3.07354 20.3854 3.63803 20.673C4.27976 21 5.11984 21 6.8 21H17.2C18.8802 21 19.7202 21 20.362 20.673C20.9265 20.3854 21.3854 19.9265 21.673 19.362C22 18.7202 22 17.8802 22 16.2V7.8C22 6.11984 22 5.27977 21.673 4.63803C21.3854 4.07354 20.9265 3.6146 20.362 3.32698C19.7202 3 18.8802 3 17.2 3L6.8 3C5.11984 3 4.27976 3 3.63803 3.32698C3.07354 3.6146 2.6146 4.07354 2.32698 4.63803C2 5.27976 2 6.11984 2 7.8Z" ] []
                ]

        Brush3 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M20 10V3.6C20 3.03995 20 2.75992 19.891 2.54601C19.7951 2.35785 19.6422 2.20487 19.454 2.10899C19.2401 2 18.9601 2 18.4 2H5.6C5.03995 2 4.75992 2 4.54601 2.10899C4.35785 2.20487 4.20487 2.35785 4.10899 2.54601C4 2.75992 4 3.03995 4 3.6V10M20 10H4M20 10V10.2C20 11.8802 20 12.7202 19.673 13.362C19.3854 13.9265 18.9265 14.3854 18.362 14.673C17.7202 15 16.8802 15 15.2 15H8.8C7.11984 15 6.27976 15 5.63803 14.673C5.07354 14.3854 4.6146 13.9265 4.32698 13.362C4 12.7202 4 11.8802 4 10.2V10M14.5 15V19.5C14.5 20.8807 13.3807 22 12 22C10.6193 22 9.5 20.8807 9.5 19.5V15" ] []
                ]

        Camera1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M2 8.37722C2 8.0269 2 7.85174 2.01462 7.70421C2.1556 6.28127 3.28127 5.1556 4.70421 5.01462C4.85174 5 5.03636 5 5.40558 5C5.54785 5 5.61899 5 5.67939 4.99634C6.45061 4.94963 7.12595 4.46288 7.41414 3.746C7.43671 3.68986 7.45781 3.62657 7.5 3.5C7.54219 3.37343 7.56329 3.31014 7.58586 3.254C7.87405 2.53712 8.54939 2.05037 9.32061 2.00366C9.38101 2 9.44772 2 9.58114 2H14.4189C14.5523 2 14.619 2 14.6794 2.00366C15.4506 2.05037 16.126 2.53712 16.4141 3.254C16.4367 3.31014 16.4578 3.37343 16.5 3.5C16.5422 3.62657 16.5633 3.68986 16.5859 3.746C16.874 4.46288 17.5494 4.94963 18.3206 4.99634C18.381 5 18.4521 5 18.5944 5C18.9636 5 19.1483 5 19.2958 5.01462C20.7187 5.1556 21.8444 6.28127 21.9854 7.70421C22 7.85174 22 8.0269 22 8.37722V16.2C22 17.8802 22 18.7202 21.673 19.362C21.3854 19.9265 20.9265 20.3854 20.362 20.673C19.7202 21 18.8802 21 17.2 21H6.8C5.11984 21 4.27976 21 3.63803 20.673C3.07354 20.3854 2.6146 19.9265 2.32698 19.362C2 18.7202 2 17.8802 2 16.2V8.37722Z" ] []
                , Svg.path [ d "M12 16.5C14.2091 16.5 16 14.7091 16 12.5C16 10.2909 14.2091 8.5 12 8.5C9.79086 8.5 8 10.2909 8 12.5C8 14.7091 9.79086 16.5 12 16.5Z" ] []
                ]

        CheckCircle ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M7.5 12L10.5 15L16.5 9M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" ] []
                ]

        ChevronDown ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M6 9L12 15L18 9" ] []
                ]

        ChevronRight ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M9 18L15 12L9 6" ] []
                ]

        Cube2 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M12 2.50008V12.0001M12 12.0001L20.5 7.27779M12 12.0001L3.5 7.27779M12 12.0001V21.5001M20.5 16.7223L12.777 12.4318C12.4934 12.2742 12.3516 12.1954 12.2015 12.1645C12.0685 12.1372 11.9315 12.1372 11.7986 12.1645C11.6484 12.1954 11.5066 12.2742 11.223 12.4318L3.5 16.7223M21 16.0586V7.94153C21 7.59889 21 7.42757 20.9495 7.27477C20.9049 7.13959 20.8318 7.01551 20.7354 6.91082C20.6263 6.79248 20.4766 6.70928 20.177 6.54288L12.777 2.43177C12.4934 2.27421 12.3516 2.19543 12.2015 2.16454C12.0685 2.13721 11.9315 2.13721 11.7986 2.16454C11.6484 2.19543 11.5066 2.27421 11.223 2.43177L3.82297 6.54288C3.52345 6.70928 3.37369 6.79248 3.26463 6.91082C3.16816 7.01551 3.09515 7.13959 3.05048 7.27477C3 7.42757 3 7.59889 3 7.94153V16.0586C3 16.4013 3 16.5726 3.05048 16.7254C3.09515 16.8606 3.16816 16.9847 3.26463 17.0893C3.37369 17.2077 3.52345 17.2909 3.82297 17.4573L11.223 21.5684C11.5066 21.726 11.6484 21.8047 11.7986 21.8356C11.9315 21.863 12.0685 21.863 12.2015 21.8356C12.3516 21.8047 12.4934 21.726 12.777 21.5684L20.177 17.4573C20.4766 17.2909 20.6263 17.2077 20.7354 17.0893C20.8318 16.9847 20.9049 16.8606 20.9495 16.7254C21 16.5726 21 16.4013 21 16.0586Z" ] []
                ]

        Edit2 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M18 10.0001L14 6.00006M2.5 21.5001L5.88437 21.124C6.29786 21.0781 6.5046 21.0551 6.69785 20.9925C6.86929 20.937 7.03245 20.8586 7.18289 20.7594C7.35245 20.6476 7.49955 20.5005 7.79373 20.2063L21 7.00006C22.1046 5.89549 22.1046 4.10463 21 3.00006C19.8955 1.89549 18.1046 1.89549 17 3.00006L3.79373 16.2063C3.49955 16.5005 3.35246 16.6476 3.24064 16.8172C3.14143 16.9676 3.06301 17.1308 3.00751 17.3022C2.94496 17.4955 2.92198 17.7022 2.87604 18.1157L2.5 21.5001Z" ] []
                ]

        Eye ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M2.42012 12.7132C2.28394 12.4975 2.21584 12.3897 2.17772 12.2234C2.14909 12.0985 2.14909 11.9015 2.17772 11.7766C2.21584 11.6103 2.28394 11.5025 2.42012 11.2868C3.54553 9.50484 6.8954 5 12.0004 5C17.1054 5 20.4553 9.50484 21.5807 11.2868C21.7169 11.5025 21.785 11.6103 21.8231 11.7766C21.8517 11.9015 21.8517 12.0985 21.8231 12.2234C21.785 12.3897 21.7169 12.4975 21.5807 12.7132C20.4553 14.4952 17.1054 19 12.0004 19C6.8954 19 3.54553 14.4952 2.42012 12.7132Z" ] []
                , Svg.path [ d "M12.0004 15C13.6573 15 15.0004 13.6569 15.0004 12C15.0004 10.3431 13.6573 9 12.0004 9C10.3435 9 9.0004 10.3431 9.0004 12C9.0004 13.6569 10.3435 15 12.0004 15Z" ] []
                ]

        EyeOff ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M10.7429 5.09232C11.1494 5.03223 11.5686 5 12.0004 5C17.1054 5 20.4553 9.50484 21.5807 11.2868C21.7169 11.5025 21.785 11.6103 21.8231 11.7767C21.8518 11.9016 21.8517 12.0987 21.8231 12.2236C21.7849 12.3899 21.7164 12.4985 21.5792 12.7156C21.2793 13.1901 20.8222 13.8571 20.2165 14.5805M6.72432 6.71504C4.56225 8.1817 3.09445 10.2194 2.42111 11.2853C2.28428 11.5019 2.21587 11.6102 2.17774 11.7765C2.1491 11.9014 2.14909 12.0984 2.17771 12.2234C2.21583 12.3897 2.28393 12.4975 2.42013 12.7132C3.54554 14.4952 6.89541 19 12.0004 19C14.0588 19 15.8319 18.2676 17.2888 17.2766M3.00042 3L21.0004 21M9.8791 9.87868C9.3362 10.4216 9.00042 11.1716 9.00042 12C9.00042 13.6569 10.3436 15 12.0004 15C12.8288 15 13.5788 14.6642 14.1217 14.1213" ] []
                ]

        File2 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M14 11H8M10 15H8M16 7H8M20 6.8V17.2C20 18.8802 20 19.7202 19.673 20.362C19.3854 20.9265 18.9265 21.3854 18.362 21.673C17.7202 22 16.8802 22 15.2 22H8.8C7.11984 22 6.27976 22 5.63803 21.673C5.07354 21.3854 4.6146 20.9265 4.32698 20.362C4 19.7202 4 18.8802 4 17.2V6.8C4 5.11984 4 4.27976 4.32698 3.63803C4.6146 3.07354 5.07354 2.6146 5.63803 2.32698C6.27976 2 7.11984 2 8.8 2H15.2C16.8802 2 17.7202 2 18.362 2.32698C18.9265 2.6146 19.3854 3.07354 19.673 3.63803C20 4.27976 20 5.11984 20 6.8Z" ] []
                ]

        File6 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M14 2.26953V6.40007C14 6.96012 14 7.24015 14.109 7.45406C14.2049 7.64222 14.3578 7.7952 14.546 7.89108C14.7599 8.00007 15.0399 8.00007 15.6 8.00007H19.7305M16 13H8M16 17H8M10 9H8M14 2H8.8C7.11984 2 6.27976 2 5.63803 2.32698C5.07354 2.6146 4.6146 3.07354 4.32698 3.63803C4 4.27976 4 5.11984 4 6.8V17.2C4 18.8802 4 19.7202 4.32698 20.362C4.6146 20.9265 5.07354 21.3854 5.63803 21.673C6.27976 22 7.11984 22 8.8 22H15.2C16.8802 22 17.7202 22 18.362 21.673C18.9265 21.3854 19.3854 20.9265 19.673 20.362C20 19.7202 20 18.8802 20 17.2V8L14 2Z" ] []
                ]

        FlexAlignBottom ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M17.5 17.6L6.5 17.6M7.8 3H16.2C17.8802 3 18.7202 3 19.362 3.32698C19.9265 3.6146 20.3854 4.07354 20.673 4.63803C21 5.27976 21 6.11984 21 7.8V16.2C21 17.8802 21 18.7202 20.673 19.362C20.3854 19.9265 19.9265 20.3854 19.362 20.673C18.7202 21 17.8802 21 16.2 21H7.8C6.11984 21 5.27976 21 4.63803 20.673C4.07354 20.3854 3.6146 19.9265 3.32698 19.362C3 18.7202 3 17.8802 3 16.2V7.8C3 6.11984 3 5.27976 3.32698 4.63803C3.6146 4.07354 4.07354 3.6146 4.63803 3.32698C5.27976 3 6.11984 3 7.8 3Z" ] []
                ]

        Grid1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M8.4 3H4.6C4.03995 3 3.75992 3 3.54601 3.10899C3.35785 3.20487 3.20487 3.35785 3.10899 3.54601C3 3.75992 3 4.03995 3 4.6V8.4C3 8.96005 3 9.24008 3.10899 9.45399C3.20487 9.64215 3.35785 9.79513 3.54601 9.89101C3.75992 10 4.03995 10 4.6 10H8.4C8.96005 10 9.24008 10 9.45399 9.89101C9.64215 9.79513 9.79513 9.64215 9.89101 9.45399C10 9.24008 10 8.96005 10 8.4V4.6C10 4.03995 10 3.75992 9.89101 3.54601C9.79513 3.35785 9.64215 3.20487 9.45399 3.10899C9.24008 3 8.96005 3 8.4 3Z" ] []
                , Svg.path [ d "M19.4 3H15.6C15.0399 3 14.7599 3 14.546 3.10899C14.3578 3.20487 14.2049 3.35785 14.109 3.54601C14 3.75992 14 4.03995 14 4.6V8.4C14 8.96005 14 9.24008 14.109 9.45399C14.2049 9.64215 14.3578 9.79513 14.546 9.89101C14.7599 10 15.0399 10 15.6 10H19.4C19.9601 10 20.2401 10 20.454 9.89101C20.6422 9.79513 20.7951 9.64215 20.891 9.45399C21 9.24008 21 8.96005 21 8.4V4.6C21 4.03995 21 3.75992 20.891 3.54601C20.7951 3.35785 20.6422 3.20487 20.454 3.10899C20.2401 3 19.9601 3 19.4 3Z" ] []
                , Svg.path [ d "M19.4 14H15.6C15.0399 14 14.7599 14 14.546 14.109C14.3578 14.2049 14.2049 14.3578 14.109 14.546C14 14.7599 14 15.0399 14 15.6V19.4C14 19.9601 14 20.2401 14.109 20.454C14.2049 20.6422 14.3578 20.7951 14.546 20.891C14.7599 21 15.0399 21 15.6 21H19.4C19.9601 21 20.2401 21 20.454 20.891C20.6422 20.7951 20.7951 20.6422 20.891 20.454C21 20.2401 21 19.9601 21 19.4V15.6C21 15.0399 21 14.7599 20.891 14.546C20.7951 14.3578 20.6422 14.2049 20.454 14.109C20.2401 14 19.9601 14 19.4 14Z" ] []
                , Svg.path [ d "M8.4 14H4.6C4.03995 14 3.75992 14 3.54601 14.109C3.35785 14.2049 3.20487 14.3578 3.10899 14.546C3 14.7599 3 15.0399 3 15.6V19.4C3 19.9601 3 20.2401 3.10899 20.454C3.20487 20.6422 3.35785 20.7951 3.54601 20.891C3.75992 21 4.03995 21 4.6 21H8.4C8.96005 21 9.24008 21 9.45399 20.891C9.64215 20.7951 9.79513 20.6422 9.89101 20.454C10 20.2401 10 19.9601 10 19.4V15.6C10 15.0399 10 14.7599 9.89101 14.546C9.79513 14.3578 9.64215 14.2049 9.45399 14.109C9.24008 14 8.96005 14 8.4 14Z" ] []
                ]

        HelpCircle ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M9.09 9C9.3251 8.33167 9.78915 7.76811 10.4 7.40913C11.0108 7.05016 11.7289 6.91894 12.4272 7.03871C13.1255 7.15849 13.7588 7.52152 14.2151 8.06353C14.6713 8.60553 14.9211 9.29152 14.92 10C14.92 12 11.92 13 11.92 13M12 17H12.01M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" ] []
                ]

        Image3 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M4.27209 20.7279L10.8686 14.1314C11.2646 13.7354 11.4627 13.5373 11.691 13.4632C11.8918 13.3979 12.1082 13.3979 12.309 13.4632C12.5373 13.5373 12.7354 13.7354 13.1314 14.1314L19.6839 20.6839M14 15L16.8686 12.1314C17.2646 11.7354 17.4627 11.5373 17.691 11.4632C17.8918 11.3979 18.1082 11.3979 18.309 11.4632C18.5373 11.5373 18.7354 11.7354 19.1314 12.1314L22 15M10 9C10 10.1046 9.10457 11 8 11C6.89543 11 6 10.1046 6 9C6 7.89543 6.89543 7 8 7C9.10457 7 10 7.89543 10 9ZM6.8 21H17.2C18.8802 21 19.7202 21 20.362 20.673C20.9265 20.3854 21.3854 19.9265 21.673 19.362C22 18.7202 22 17.8802 22 16.2V7.8C22 6.11984 22 5.27976 21.673 4.63803C21.3854 4.07354 20.9265 3.6146 20.362 3.32698C19.7202 3 18.8802 3 17.2 3H6.8C5.11984 3 4.27976 3 3.63803 3.32698C3.07354 3.6146 2.6146 4.07354 2.32698 4.63803C2 5.27976 2 6.11984 2 7.8V16.2C2 17.8802 2 18.7202 2.32698 19.362C2.6146 19.9265 3.07354 20.3854 3.63803 20.673C4.27976 21 5.11984 21 6.8 21Z" ] []
                ]

        LifeBuoy1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M9.13626 9.13628L4.92893 4.92896M4.92893 19.0711L9.16797 14.8321M14.8611 14.8638L19.0684 19.0711M19.0684 4.92896L14.8287 9.16862M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12ZM16 12C16 14.2091 14.2091 16 12 16C9.79086 16 8 14.2091 8 12C8 9.79086 9.79086 8 12 8C14.2091 8 16 9.79086 16 12Z" ] []
                ]

        Link2 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M9 17H7C4.23858 17 2 14.7614 2 12C2 9.23858 4.23858 7 7 7H9M15 17H17C19.7614 17 22 14.7614 22 12C22 9.23858 19.7614 7 17 7H15M7 12L17 12" ] []
                ]

        LinkExternal1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M21 9L21 3M21 3H15M21 3L13 11M10 5H7.8C6.11984 5 5.27976 5 4.63803 5.32698C4.07354 5.6146 3.6146 6.07354 3.32698 6.63803C3 7.27976 3 8.11984 3 9.8V16.2C3 17.8802 3 18.7202 3.32698 19.362C3.6146 19.9265 4.07354 20.3854 4.63803 20.673C5.27976 21 6.11984 21 7.8 21H14.2C15.8802 21 16.7202 21 17.362 20.673C17.9265 20.3854 18.3854 19.9265 18.673 19.362C19 18.7202 19 17.8802 19 16.2V14" ] []
                ]

        Loading4Animated ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2" ]
                    [ animateTransform [ attributeName "transform", type_ "rotate", from "0 12 12", to "360 12 12", dur "0.6s", repeatCount "indefinite" ] []
                    ]
                ]

        LogOut1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M16 17L21 12M21 12L16 7M21 12H9M9 3H7.8C6.11984 3 5.27976 3 4.63803 3.32698C4.07354 3.6146 3.6146 4.07354 3.32698 4.63803C3 5.27976 3 6.11984 3 7.8V16.2C3 17.8802 3 18.7202 3.32698 19.362C3.6146 19.9265 4.07354 20.3854 4.63803 20.673C5.27976 21 6.11984 21 7.8 21H9" ] []
                ]

        MessageTextSquare2 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M7 8.5H12M7 12H15M7 18V20.3355C7 20.8684 7 21.1348 7.10923 21.2716C7.20422 21.3906 7.34827 21.4599 7.50054 21.4597C7.67563 21.4595 7.88367 21.2931 8.29976 20.9602L10.6852 19.0518C11.1725 18.662 11.4162 18.4671 11.6875 18.3285C11.9282 18.2055 12.1844 18.1156 12.4492 18.0613C12.7477 18 13.0597 18 13.6837 18H16.2C17.8802 18 18.7202 18 19.362 17.673C19.9265 17.3854 20.3854 16.9265 20.673 16.362C21 15.7202 21 14.8802 21 13.2V7.8C21 6.11984 21 5.27976 20.673 4.63803C20.3854 4.07354 19.9265 3.6146 19.362 3.32698C18.7202 3 17.8802 3 16.2 3H7.8C6.11984 3 5.27976 3 4.63803 3.32698C4.07354 3.6146 3.6146 4.07354 3.32698 4.63803C3 5.27976 3 6.11984 3 7.8V14C3 14.93 3 15.395 3.10222 15.7765C3.37962 16.8117 4.18827 17.6204 5.22354 17.8978C5.60504 18 6.07003 18 7 18Z" ] []
                ]

        Monitor1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M8 21H16M12 17V21M6.8 17H17.2C18.8802 17 19.7202 17 20.362 16.673C20.9265 16.3854 21.3854 15.9265 21.673 15.362C22 14.7202 22 13.8802 22 12.2V7.8C22 6.11984 22 5.27976 21.673 4.63803C21.3854 4.07354 20.9265 3.6146 20.362 3.32698C19.7202 3 18.8802 3 17.2 3H6.8C5.11984 3 4.27976 3 3.63803 3.32698C3.07354 3.6146 2.6146 4.07354 2.32698 4.63803C2 5.27976 2 6.11984 2 7.8V12.2C2 13.8802 2 14.7202 2.32698 15.362C2.6146 15.9265 3.07354 16.3854 3.63803 16.673C4.27976 17 5.11984 17 6.8 17Z" ] []
                ]

        Phone1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M12 17.5H12.01M8.2 22H15.8C16.9201 22 17.4802 22 17.908 21.782C18.2843 21.5903 18.5903 21.2843 18.782 20.908C19 20.4802 19 19.9201 19 18.8V5.2C19 4.07989 19 3.51984 18.782 3.09202C18.5903 2.71569 18.2843 2.40973 17.908 2.21799C17.4802 2 16.9201 2 15.8 2H8.2C7.0799 2 6.51984 2 6.09202 2.21799C5.71569 2.40973 5.40973 2.71569 5.21799 3.09202C5 3.51984 5 4.0799 5 5.2V18.8C5 19.9201 5 20.4802 5.21799 20.908C5.40973 21.2843 5.71569 21.5903 6.09202 21.782C6.51984 22 7.07989 22 8.2 22ZM12.5 17.5C12.5 17.7761 12.2761 18 12 18C11.7239 18 11.5 17.7761 11.5 17.5C11.5 17.2239 11.7239 17 12 17C12.2761 17 12.5 17.2239 12.5 17.5Z" ] []
                ]

        Placeholder ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M12 22C17.5228 22 22 17.5228 22 12C22 6.47715 17.5228 2 12 2C6.47715 2 2 6.47715 2 12C2 17.5228 6.47715 22 12 22Z" ] []
                ]

        Plus ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M12 5V19M5 12H19" ] []
                ]

        SearchMd ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M21 21L16.65 16.65M19 11C19 15.4183 15.4183 19 11 19C6.58172 19 3 15.4183 3 11C3 6.58172 6.58172 3 11 3C15.4183 3 19 6.58172 19 11Z" ] []
                ]

        Send1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M10.4995 13.5001L20.9995 3.00005M10.6271 13.8281L13.2552 20.5861C13.4867 21.1815 13.6025 21.4791 13.7693 21.566C13.9139 21.6414 14.0862 21.6415 14.2308 21.5663C14.3977 21.4796 14.5139 21.1821 14.7461 20.587L21.3364 3.69925C21.5461 3.16207 21.6509 2.89348 21.5935 2.72185C21.5437 2.5728 21.4268 2.45583 21.2777 2.40604C21.1061 2.34871 20.8375 2.45352 20.3003 2.66315L3.41258 9.25349C2.8175 9.48572 2.51997 9.60183 2.43326 9.76873C2.35809 9.91342 2.35819 10.0857 2.43353 10.2303C2.52043 10.3971 2.81811 10.5128 3.41345 10.7444L10.1715 13.3725C10.2923 13.4195 10.3527 13.443 10.4036 13.4793C10.4487 13.5114 10.4881 13.5509 10.5203 13.596C10.5566 13.6468 10.5801 13.7073 10.6271 13.8281Z" ] []
                ]

        Settings1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M12 15C13.6569 15 15 13.6569 15 12C15 10.3431 13.6569 9 12 9C10.3431 9 9 10.3431 9 12C9 13.6569 10.3431 15 12 15Z" ] []
                , Svg.path [ d "M18.7273 14.7273C18.6063 15.0015 18.5702 15.3056 18.6236 15.6005C18.6771 15.8954 18.8177 16.1676 19.0273 16.3818L19.0818 16.4364C19.2509 16.6052 19.385 16.8057 19.4765 17.0265C19.568 17.2472 19.6151 17.4838 19.6151 17.7227C19.6151 17.9617 19.568 18.1983 19.4765 18.419C19.385 18.6397 19.2509 18.8402 19.0818 19.0091C18.913 19.1781 18.7124 19.3122 18.4917 19.4037C18.271 19.4952 18.0344 19.5423 17.7955 19.5423C17.5565 19.5423 17.3199 19.4952 17.0992 19.4037C16.8785 19.3122 16.678 19.1781 16.5091 19.0091L16.4545 18.9545C16.2403 18.745 15.9682 18.6044 15.6733 18.5509C15.3784 18.4974 15.0742 18.5335 14.8 18.6545C14.5311 18.7698 14.3018 18.9611 14.1403 19.205C13.9788 19.4489 13.8921 19.7347 13.8909 20.0273V20.1818C13.8909 20.664 13.6994 21.1265 13.3584 21.4675C13.0174 21.8084 12.5549 22 12.0727 22C11.5905 22 11.1281 21.8084 10.7871 21.4675C10.4461 21.1265 10.2545 20.664 10.2545 20.1818V20.1C10.2475 19.7991 10.1501 19.5073 9.97501 19.2625C9.79991 19.0176 9.55521 18.8312 9.27273 18.7273C8.99853 18.6063 8.69437 18.5702 8.39947 18.6236C8.10456 18.6771 7.83244 18.8177 7.61818 19.0273L7.56364 19.0818C7.39478 19.2509 7.19425 19.385 6.97353 19.4765C6.7528 19.568 6.51621 19.6151 6.27727 19.6151C6.03834 19.6151 5.80174 19.568 5.58102 19.4765C5.36029 19.385 5.15977 19.2509 4.99091 19.0818C4.82186 18.913 4.68775 18.7124 4.59626 18.4917C4.50476 18.271 4.45766 18.0344 4.45766 17.7955C4.45766 17.5565 4.50476 17.3199 4.59626 17.0992C4.68775 16.8785 4.82186 16.678 4.99091 16.5091L5.04545 16.4545C5.25503 16.2403 5.39562 15.9682 5.4491 15.6733C5.50257 15.3784 5.46647 15.0742 5.34545 14.8C5.23022 14.5311 5.03887 14.3018 4.79497 14.1403C4.55107 13.9788 4.26526 13.8921 3.97273 13.8909H3.81818C3.33597 13.8909 2.87351 13.6994 2.53253 13.3584C2.19156 13.0174 2 12.5549 2 12.0727C2 11.5905 2.19156 11.1281 2.53253 10.7871C2.87351 10.4461 3.33597 10.2545 3.81818 10.2545H3.9C4.2009 10.2475 4.49273 10.1501 4.73754 9.97501C4.98236 9.79991 5.16883 9.55521 5.27273 9.27273C5.39374 8.99853 5.42984 8.69437 5.37637 8.39947C5.3229 8.10456 5.18231 7.83244 4.97273 7.61818L4.91818 7.56364C4.74913 7.39478 4.61503 7.19425 4.52353 6.97353C4.43203 6.7528 4.38493 6.51621 4.38493 6.27727C4.38493 6.03834 4.43203 5.80174 4.52353 5.58102C4.61503 5.36029 4.74913 5.15977 4.91818 4.99091C5.08704 4.82186 5.28757 4.68775 5.50829 4.59626C5.72901 4.50476 5.96561 4.45766 6.20455 4.45766C6.44348 4.45766 6.68008 4.50476 6.9008 4.59626C7.12152 4.68775 7.32205 4.82186 7.49091 4.99091L7.54545 5.04545C7.75971 5.25503 8.03183 5.39562 8.32674 5.4491C8.62164 5.50257 8.9258 5.46647 9.2 5.34545H9.27273C9.54161 5.23022 9.77093 5.03887 9.93245 4.79497C10.094 4.55107 10.1807 4.26526 10.1818 3.97273V3.81818C10.1818 3.33597 10.3734 2.87351 10.7144 2.53253C11.0553 2.19156 11.5178 2 12 2C12.4822 2 12.9447 2.19156 13.2856 2.53253C13.6266 2.87351 13.8182 3.33597 13.8182 3.81818V3.9C13.8193 4.19253 13.906 4.47834 14.0676 4.72224C14.2291 4.96614 14.4584 5.15749 14.7273 5.27273C15.0015 5.39374 15.3056 5.42984 15.6005 5.37637C15.8954 5.3229 16.1676 5.18231 16.3818 4.97273L16.4364 4.91818C16.6052 4.74913 16.8057 4.61503 17.0265 4.52353C17.2472 4.43203 17.4838 4.38493 17.7227 4.38493C17.9617 4.38493 18.1983 4.43203 18.419 4.52353C18.6397 4.61503 18.8402 4.74913 19.0091 4.91818C19.1781 5.08704 19.3122 5.28757 19.4037 5.50829C19.4952 5.72901 19.5423 5.96561 19.5423 6.20455C19.5423 6.44348 19.4952 6.68008 19.4037 6.9008C19.3122 7.12152 19.1781 7.32205 19.0091 7.49091L18.9545 7.54545C18.745 7.75971 18.6044 8.03183 18.5509 8.32674C18.4974 8.62164 18.5335 8.9258 18.6545 9.2V9.27273C18.7698 9.54161 18.9611 9.77093 19.205 9.93245C19.4489 10.094 19.7347 10.1807 20.0273 10.1818H20.1818C20.664 10.1818 21.1265 10.3734 21.4675 10.7144C21.8084 11.0553 22 11.5178 22 12C22 12.4822 21.8084 12.9447 21.4675 13.2856C21.1265 13.6266 20.664 13.8182 20.1818 13.8182H20.1C19.8075 13.8193 19.5217 13.906 19.2778 14.0676C19.0339 14.2291 18.8425 14.4584 18.7273 14.7273Z" ] []
                ]

        SlashDivider ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M7 22L17 2" ] []
                ]

        Trash1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M16 6V5.2C16 4.0799 16 3.51984 15.782 3.09202C15.5903 2.71569 15.2843 2.40973 14.908 2.21799C14.4802 2 13.9201 2 12.8 2H11.2C10.0799 2 9.51984 2 9.09202 2.21799C8.71569 2.40973 8.40973 2.71569 8.21799 3.09202C8 3.51984 8 4.0799 8 5.2V6M10 11.5V16.5M14 11.5V16.5M3 6H21M19 6V17.2C19 18.8802 19 19.7202 18.673 20.362C18.3854 20.9265 17.9265 21.3854 17.362 21.673C16.7202 22 15.8802 22 14.2 22H9.8C8.11984 22 7.27976 22 6.63803 21.673C6.07354 21.3854 5.6146 20.9265 5.32698 20.362C5 19.7202 5 18.8802 5 17.2V6" ] []
                ]

        Upload1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M21 15V16.2C21 17.8802 21 18.7202 20.673 19.362C20.3854 19.9265 19.9265 20.3854 19.362 20.673C18.7202 21 17.8802 21 16.2 21H7.8C6.11984 21 5.27976 21 4.63803 20.673C4.07354 20.3854 3.6146 19.9265 3.32698 19.362C3 18.7202 3 17.8802 3 16.2V15M17 8L12 3M12 3L7 8M12 3V15" ] []
                ]

        Upload2 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M21 3H3M18 13L12 7M12 7L6 13M12 7V21" ] []
                ]

        Upload3 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M16 12L12 8M12 8L8 12M12 8V16M22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" ] []
                ]

        UploadCloud2 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M8 16L12 12M12 12L16 16M12 12V21M20 16.7428C21.2215 15.734 22 14.2079 22 12.5C22 9.46243 19.5376 7 16.5 7C16.2815 7 16.0771 6.886 15.9661 6.69774C14.6621 4.48484 12.2544 3 9.5 3C5.35786 3 2 6.35786 2 10.5C2 12.5661 2.83545 14.4371 4.18695 15.7935" ] []
                ]

        User1 ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M20 21C20 19.6044 20 18.9067 19.8278 18.3389C19.44 17.0605 18.4395 16.06 17.1611 15.6722C16.5933 15.5 15.8956 15.5 14.5 15.5H9.5C8.10444 15.5 7.40665 15.5 6.83886 15.6722C5.56045 16.06 4.56004 17.0605 4.17224 18.3389C4 18.9067 4 19.6044 4 21M16.5 7.5C16.5 9.98528 14.4853 12 12 12C9.51472 12 7.5 9.98528 7.5 7.5C7.5 5.01472 9.51472 3 12 3C14.4853 3 16.5 5.01472 16.5 7.5Z" ] []
                ]

        UserCircle ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M5.3163 19.4384C5.92462 18.0052 7.34492 17 9 17H15C16.6551 17 18.0754 18.0052 18.6837 19.4384M16 9.5C16 11.7091 14.2091 13.5 12 13.5C9.79086 13.5 8 11.7091 8 9.5C8 7.29086 9.79086 5.5 12 5.5C14.2091 5.5 16 7.29086 16 9.5ZM22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C17.5228 2 22 6.47715 22 12Z" ] []
                ]

        XClose ->
            svg [ width config.size, height config.size, viewBox "0 0 24 24", fill config.fill, stroke config.stroke, strokeWidth config.strokeWidth, strokeLinecap "round", strokeLinejoin "round" ]
                [ Svg.path [ d "M18 6L6 18M6 6L18 18" ] []
                ]

================
File: frontend/src/UI/Quote.elm
================
module UI.Quote exposing (quoteNumber)


quoteNumber : Int -> String
quoteNumber id =
    id
        |> String.fromInt
        |> String.padLeft 6 '0'

================
File: frontend/src/UI/Select.elm
================
module UI.Select exposing (fromValuesWithLabels)

import Html exposing (Attribute, Html, option, text)
import Html.Attributes exposing (selected, value)
import Html.Events


fromValuesWithLabels : a -> (a -> msg) -> List (Attribute msg) -> List ( a, String ) -> Html msg
fromValuesWithLabels currentValue onInput attributes valueLabelPairs =
    let
        pairToOption ( optionValue, optionLabel ) =
            option [ value optionLabel, selected (currentValue == optionValue) ] [ text optionLabel ]

        options =
            List.map pairToOption valueLabelPairs

        valueFromLabel label =
            valueLabelPairs
                |> List.filter (\pair -> Tuple.second pair == label)
                |> List.map Tuple.first
                |> List.head
                |> Maybe.withDefault currentValue
    in
    Html.select (Html.Events.onInput (onInput << valueFromLabel) :: attributes) options

================
File: frontend/src/UI/Time.elm
================
module UI.Time exposing (posixToString)

import Time


posixToString : Time.Zone -> Time.Posix -> String
posixToString zone time =
    let
        toShortMonth m =
            case m of
                Time.Jan ->
                    "Jan"

                Time.Feb ->
                    "Feb"

                Time.Mar ->
                    "Mar"

                Time.Apr ->
                    "Apr"

                Time.May ->
                    "May"

                Time.Jun ->
                    "Jun"

                Time.Jul ->
                    "Jul"

                Time.Aug ->
                    "Aug"

                Time.Sep ->
                    "Sep"

                Time.Oct ->
                    "Oct"

                Time.Nov ->
                    "Nov"

                Time.Dec ->
                    "Dec"

        month =
            time
                |> Time.toMonth zone
                |> toShortMonth

        date =
            time
                |> Time.toDay zone
                |> String.fromInt
                |> String.padLeft 2 '0'

        to12hour h =
            if h > 12 then
                h - 12

            else
                h

        hour =
            time
                |> Time.toHour zone
                |> to12hour
                |> String.fromInt
                |> String.padLeft 2 '0'

        minute =
            time
                |> Time.toMinute zone
                |> String.fromInt
                |> String.padLeft 2 '0'

        hourToAMPM h =
            if h > 12 then
                "PM"

            else
                "AM"

        ampm =
            time
                |> Time.toHour zone
                |> hourToAMPM
    in
    month ++ " " ++ date ++ ", " ++ hour ++ ":" ++ minute ++ " " ++ ampm

================
File: frontend/src/Auth.elm
================
module Auth exposing (User, onPageLoad, viewCustomPage)

import Auth.Action
import Dict
import Html exposing (..)
import Html.Attributes exposing (..)
import Route exposing (Route)
import Route.Path
import Server
import Shared
import Shared.Model
import UI.Icon
import Url
import View exposing (View)


type alias User =
    Server.Agent


{-| Called before an auth-only page is loaded.
-}
onPageLoad : Shared.Model -> Route () -> Auth.Action.Action User
onPageLoad shared route =
    case shared.agent of
        Shared.Model.SignedOut _ ->
            Auth.Action.pushRoute
                { path = Route.Path.SignIn
                , query = Dict.fromList [ ( "redirect_uri", Url.toString route.url ) ]
                , hash = Nothing
                }

        Shared.Model.SignedIn agent ->
            Auth.Action.loadPageWithUser agent

        Shared.Model.Loading ->
            Auth.Action.loadCustomPage


{-| Renders whenever `Auth.Action.loadCustomPage` is returned from `onPageLoad`.
-}
viewCustomPage : Shared.Model -> Route () -> View Never
viewCustomPage shared route =
    { title = "Loading"
    , body =
        [ div [ class "flex justify-center text-gray-300 pt-40" ]
            [ UI.Icon.new UI.Icon.Loading4Animated
                |> UI.Icon.withSize 60
                |> UI.Icon.withStrokeWidth 1
                |> UI.Icon.view
            ]
        ]
    }

================
File: frontend/src/Effect.elm
================
port module Effect exposing
    ( Effect
    , none, batch
    , sendCmd, sendMsg
    , pushRoute, replaceRoute
    , pushRoutePath, replaceRoutePath
    , loadExternalUrl, back
    , map, toCmd
    , closeDialog, showDialog, signOut, windowOpen
    )

{-|

@docs Effect

@docs none, batch
@docs sendCmd, sendMsg

@docs pushRoute, replaceRoute
@docs pushRoutePath, replaceRoutePath
@docs loadExternalUrl, back

@docs map, toCmd

-}

import Browser.Navigation
import Dict exposing (Dict)
import Json.Encode
import Route exposing (Route)
import Route.Path
import Shared.Model
import Shared.Msg
import Task
import Url exposing (Url)


type Effect msg
    = -- BASICS
      None
    | Batch (List (Effect msg))
    | SendCmd (Cmd msg)
      -- ROUTING
    | PushUrl String
    | ReplaceUrl String
    | LoadExternalUrl String
    | Back
      -- SHARED
    | SendSharedMsg Shared.Msg.Msg
      -- PORTS
    | SendMessageToJavaScript
        { tag : String
        , data : Json.Encode.Value
        }



-- BASICS


{-| Don't send any effect.
-}
none : Effect msg
none =
    None


{-| Send multiple effects at once.
-}
batch : List (Effect msg) -> Effect msg
batch =
    Batch


{-| Send a normal `Cmd msg` as an effect, something like `Http.get` or `Random.generate`.
-}
sendCmd : Cmd msg -> Effect msg
sendCmd =
    SendCmd


{-| Send a message as an effect. Useful when emitting events from UI components.
-}
sendMsg : msg -> Effect msg
sendMsg msg =
    Task.succeed msg
        |> Task.perform identity
        |> SendCmd



-- ROUTING


{-| Set the new route, and make the back button go back to the current route.
-}
pushRoute :
    { path : Route.Path.Path
    , query : Dict String String
    , hash : Maybe String
    }
    -> Effect msg
pushRoute route =
    PushUrl (Route.toString route)


{-| Same as `Effect.pushRoute`, but without `query` or `hash` support
-}
pushRoutePath : Route.Path.Path -> Effect msg
pushRoutePath path =
    PushUrl (Route.Path.toString path)


{-| Set the new route, but replace the previous one, so clicking the back
button **won't** go back to the previous route.
-}
replaceRoute :
    { path : Route.Path.Path
    , query : Dict String String
    , hash : Maybe String
    }
    -> Effect msg
replaceRoute route =
    ReplaceUrl (Route.toString route)


{-| Same as `Effect.replaceRoute`, but without `query` or `hash` support
-}
replaceRoutePath : Route.Path.Path -> Effect msg
replaceRoutePath path =
    ReplaceUrl (Route.Path.toString path)


{-| Redirect users to a new URL, somewhere external to your web application.
-}
loadExternalUrl : String -> Effect msg
loadExternalUrl =
    LoadExternalUrl


{-| Navigate back one page
-}
back : Effect msg
back =
    Back



-- PORTS


port outgoing : { tag : String, data : Json.Encode.Value } -> Cmd msg


showDialog : String -> Effect msg
showDialog dialog_id =
    SendMessageToJavaScript
        { tag = "SHOW_DIALOG_MODAL"
        , data = Json.Encode.string dialog_id
        }


closeDialog : String -> Effect msg
closeDialog dialog_id =
    SendMessageToJavaScript
        { tag = "CLOSE_DIALOG_MODAL"
        , data = Json.Encode.string dialog_id
        }


signOut : Effect msg
signOut =
    SendSharedMsg Shared.Msg.SignOutRequested


windowOpen : String -> Effect msg
windowOpen url =
    SendMessageToJavaScript
        { tag = "WINDOW_OPEN"
        , data = Json.Encode.string url
        }



-- INTERNALS


{-| Elm Land depends on this function to connect pages and layouts
together into the overall app.
-}
map : (msg1 -> msg2) -> Effect msg1 -> Effect msg2
map fn effect =
    case effect of
        None ->
            None

        Batch list ->
            Batch (List.map (map fn) list)

        SendCmd cmd ->
            SendCmd (Cmd.map fn cmd)

        PushUrl url ->
            PushUrl url

        ReplaceUrl url ->
            ReplaceUrl url

        Back ->
            Back

        LoadExternalUrl url ->
            LoadExternalUrl url

        SendSharedMsg sharedMsg ->
            SendSharedMsg sharedMsg

        SendMessageToJavaScript message ->
            SendMessageToJavaScript message


{-| Elm Land depends on this function to perform your effects.
-}
toCmd :
    { key : Browser.Navigation.Key
    , url : Url
    , shared : Shared.Model.Model
    , fromSharedMsg : Shared.Msg.Msg -> msg
    , batch : List msg -> msg
    , toCmd : msg -> Cmd msg
    }
    -> Effect msg
    -> Cmd msg
toCmd options effect =
    case effect of
        None ->
            Cmd.none

        Batch list ->
            Cmd.batch (List.map (toCmd options) list)

        SendCmd cmd ->
            cmd

        PushUrl url ->
            Browser.Navigation.pushUrl options.key url

        ReplaceUrl url ->
            Browser.Navigation.replaceUrl options.key url

        Back ->
            Browser.Navigation.back options.key 1

        LoadExternalUrl url ->
            Browser.Navigation.load url

        SendSharedMsg sharedMsg ->
            Task.succeed sharedMsg
                |> Task.perform options.fromSharedMsg

        SendMessageToJavaScript message ->
            outgoing message

================
File: frontend/src/interop.js
================
import "./styles.css";

// This is called BEFORE your Elm app starts up
//
// The value returned here will be passed as flags
// into your `Shared.init` function.
export const flags = ({ env }) => {
  return {
    oauthGoogleLoginUrl: env["OAUTH_GOOGLE_LOGIN_URL"],
  };
};

// This is called AFTER your Elm app starts up
//
// Here you can work with `app.ports` to send messages
// to your Elm application, or subscribe to incoming
// messages from Elm
export const onReady = ({ app, env }) => {
  if (app.ports && app.ports.outgoing) {
    app.ports.outgoing.subscribe(({ tag, data }) => {
      switch (tag) {
        case "SHOW_DIALOG_MODAL":
          var id = data;
          var dialog = document.getElementById(id);
          if (dialog) {
            dialog.showModal();
          }
          break;
        case "CLOSE_DIALOG_MODAL":
          var id = data;
          var dialog = document.getElementById(id);
          if (dialog) {
            dialog.close();
          }
          break;
        case "WINDOW_OPEN":
          var url = data;
          window.open(url);
          break;
      }
    });
  }
};

================
File: frontend/src/Server.elm
================
module Server exposing 
  ( Value(..)
  , Error(..)
  , WebrpcErrorName(..)
  , WebrpcErrorResponse
  , Request
  , CarrierGroup(..)
  , Gender(..)
  , FilingType(..)
  , SupplementalPlanType(..)
  , DiscountCategory(..)
  , SearchResultType(..)
  , County
  , Agent
  , Client
  , IrmaaBracket
  , Carrier
  , DrugQuote
  , SupplementalQuote
  , DentalQuote
  , Quote
  , ShortQuote
  , SupplementalCarrierPlanType
  , SearchResult
  , CreateClientParams
  , UpdateClientParams
  , CreateQuoteParams
  , UpdateQuoteParams
  , UpdateSpouseQuoteParams
  , ListQuotesParams
  , ListQuotesResponse
  , GetQuoteResponse
  , PublicQuotePageData
  , PublicQuoteClientData
  , Dashboard
  , Public
  , dashboard
  , public  
  , webRpcVersion
  , webRpcSchemaVersion
  , webRpcSchemaHash
  , withBaseUrl
  , withCredentials
  , withTimeout
  , withTracker
  , send
  , task
  )
  
  
{- 
    maxquote v1.0.0 f34af1b51e563b8f4f8183c601276d17c844215c
    --
    Code generated by webrpc-gen@v0.20.0 with github.com/eriklott/webrpc-gen-elm@v0.11.6 generator. DO NOT EDIT.
    webrpc-gen -schema=rpc/maxquote/service.ridl -target=github.com/eriklott/webrpc-gen-elm@v0.11.6 -module=Server -timeout=30000 -out=frontend/src/Server.elm
-}


import Http
import Json.Decode as Decode exposing (Decoder)
import Json.Encode as Encode
import Time exposing (Posix)
import Dict exposing (Dict)
import Task exposing (Task)
import Iso8601


webRpcVersion : String
webRpcVersion =
    "v1"


webRpcSchemaVersion : String
webRpcSchemaVersion =
    "v1.0.0"


webRpcSchemaHash : String
webRpcSchemaHash =
    "f34af1b51e563b8f4f8183c601276d17c844215c"


-- TYPES


type CarrierGroup
    = CarrierGroupSupported
    | CarrierGroupAll


type Gender
    = GenderMale
    | GenderFemale


type FilingType
    = FilingTypeIndividual
    | FilingTypeMarriedFilingJointly
    | FilingTypeMarriedFilingSeparately


type SupplementalPlanType
    = SupplementalPlanTypeF
    | SupplementalPlanTypeG
    | SupplementalPlanTypeN


type DiscountCategory
    = DiscountCategoryMultiInsured
    | DiscountCategoryLivingWithSomeone


type SearchResultType
    = SearchResultTypeClient
    | SearchResultTypeQuote


type alias County =
    { fipsCode : String 
    , name : String 
    , stateAlphaCode : String 
    }


type alias Agent =
    { id : Int 
    , firstName : String 
    , lastName : String 
    , email : String 
    , phone : String 
    , phoneExt : Maybe Int 
    , createdAt : Posix 
    , updatedAt : Posix 
    }


type alias Client =
    { id : Int 
    , firstName : String 
    , lastName : String 
    , dateOfBirth : String 
    , age : Int 
    , gender : Gender 
    , zipCode : String 
    , county : County 
    , email : Maybe String 
    , phone : Maybe String 
    , isTobaccoUser : Bool 
    , createdAt : Posix 
    , updatedAt : Posix 
    }


type alias IrmaaBracket =
    { id : Int 
    , year : Int 
    , filingType : FilingType 
    , fromCents : Int 
    , toCents : Maybe Int 
    , partBIrmaaCents : Int 
    , partBMonthlyPremiumCents : Int 
    , partDIrmaaCents : Int 
    }


type alias Carrier =
    { naic : String 
    , name : String 
    , isPreferred : Bool 
    , logoUrl : Maybe String 
    }


type alias DrugQuote =
    { id : Int 
    , contractYear : Int 
    , contractId : String 
    , planId : Int 
    , stateAlphaCode : String 
    , companyName : String 
    , planName : String 
    , monthlyRateCents : Int 
    }


type alias SupplementalQuote =
    { carrier : Carrier 
    , planType : SupplementalPlanType 
    , monthlyRateCents : Int 
    , multiInsuredDiscountRateCents : Maybe Int 
    , livingWithSomeoneDiscountRateCents : Maybe Int 
    }


type alias DentalQuote =
    { id : Int 
    , stateAlphaCode : String 
    , carrierNaic : String 
    , carrierName : String 
    , annualBenefitCents : Int 
    , monthlyRateCents : Int 
    }


type alias Quote =
    { id : Int 
    , parentId : Maybe Int 
    , urlId : String 
    , agent : Agent 
    , client : Client 
    , effectiveDate : Posix 
    , irmaaBracket : IrmaaBracket 
    , drugQuote : Maybe DrugQuote 
    , dentalQuote : Maybe DentalQuote 
    , supplementalCarrierPlanTypes : List SupplementalCarrierPlanType 
    , hasMultiInsuredDiscount : Bool 
    , hasLivingWithSomeoneDiscount : Bool 
    , createdAt : Posix 
    , updatedAt : Posix 
    }


type alias ShortQuote =
    { id : Int 
    , urlId : String 
    , agent : Agent 
    , client : Client 
    , effectiveDate : Posix 
    , createdAt : Posix 
    , updatedAt : Posix 
    }


type alias SupplementalCarrierPlanType =
    { carrierNaic : String 
    , planType : SupplementalPlanType 
    }


type alias SearchResult =
    { type_ : SearchResultType 
    , primaryDescription : String 
    , secondaryDescription : String 
    , id : Int 
    }


type alias CreateClientParams =
    { firstName : String 
    , lastName : String 
    , dateOfBirth : String 
    , gender : Gender 
    , zipCode : String 
    , countyFipsCode : String 
    , email : Maybe String 
    , phone : Maybe String 
    , isTobaccoUser : Bool 
    }


type alias UpdateClientParams =
    { id : Int 
    , firstName : String 
    , lastName : String 
    , dateOfBirth : String 
    , gender : Gender 
    , zipCode : String 
    , countyFipsCode : String 
    , email : Maybe String 
    , phone : Maybe String 
    , isTobaccoUser : Bool 
    }


type alias CreateQuoteParams =
    { clientId : Int 
    , effectiveDate : String 
    , irmaaBracketId : Int 
    , drugQuoteId : Maybe Int 
    , dentalQuoteId : Maybe Int 
    , supplementalCarrierPlanTypes : List SupplementalCarrierPlanType 
    , hasMultiInsuredDiscount : Bool 
    , hasLivingWithSomeoneDiscount : Bool 
    }


type alias UpdateQuoteParams =
    { id : Int 
    , clientId : Int 
    , effectiveDate : String 
    , irmaaBracketId : Int 
    , drugQuoteId : Maybe Int 
    , dentalQuoteId : Maybe Int 
    , supplementalCarrierPlanTypes : List SupplementalCarrierPlanType 
    , hasMultiInsuredDiscount : Bool 
    , hasLivingWithSomeoneDiscount : Bool 
    }


type alias UpdateSpouseQuoteParams =
    { clientId : Int 
    , effectiveDate : String 
    , irmaaBracketId : Int 
    , drugQuoteId : Maybe Int 
    , dentalQuoteId : Maybe Int 
    , supplementalCarrierPlanTypes : List SupplementalCarrierPlanType 
    , hasMultiInsuredDiscount : Bool 
    , hasLivingWithSomeoneDiscount : Bool 
    }


type alias ListQuotesParams =
    { clientId : Maybe Int 
    , startingAfter : Maybe Int 
    , endingBefore : Maybe Int 
    , limit : Int 
    }


type alias ListQuotesResponse =
    { data : List ShortQuote 
    , totalCount : Int 
    , hasMore : Bool 
    }


type alias GetQuoteResponse =
    { quote : Quote 
    , spouseQuote : Maybe Quote 
    }


type alias PublicQuotePageData =
    { client : PublicQuoteClientData 
    , spouse : Maybe PublicQuoteClientData 
    }


type alias PublicQuoteClientData =
    { quote : Quote 
    , irmaaBracket : IrmaaBracket 
    , drugQuote : Maybe DrugQuote 
    }



-- SERVICES


type alias Dashboard =
    { whoAmI : Request Agent
    , signOut : Request ()
    , search : String -> Request (List SearchResult)
    , listCountiesByZipCode : String -> Request (List County)
    , searchClients : String -> Request (List Client)
    , getClient : Int -> Request Client
    , isClientEmailTaken : String -> Maybe Int -> Request Bool
    , createClient : CreateClientParams -> Request Client
    , updateClient : UpdateClientParams -> Request Client
    , listIrmaaBracketsByEffectiveDate : String -> Request (List IrmaaBracket)
    , listDrugQuotesByClientIdAndEffectiveDate : Int -> String -> Request (List DrugQuote)
    , listDentalQuotesByClientId : Int -> Request (List DentalQuote)
    , listSupplementalQuotesByClientIdAndEffectiveDate : Int -> String -> List SupplementalPlanType -> CarrierGroup -> Request (List SupplementalQuote)
    , listSupplementalQuotesForQuote : Int -> Request (List SupplementalQuote)
    , listQuotes : ListQuotesParams -> Request ListQuotesResponse
    , getQuote : Int -> Request Quote
    , getSpouseQuote : Int -> Request Quote
    , createQuote : CreateQuoteParams -> Maybe CreateQuoteParams -> Request Quote
    , updateQuote : UpdateQuoteParams -> Maybe UpdateSpouseQuoteParams -> Request Quote
    , sendQuote : Int -> String -> Request ()
    }


dashboard : Dashboard
dashboard =
    { whoAmI = dashboardWhoAmI 
    , signOut = dashboardSignOut 
    , search = dashboardSearch 
    , listCountiesByZipCode = dashboardListCountiesByZipCode 
    , searchClients = dashboardSearchClients 
    , getClient = dashboardGetClient 
    , isClientEmailTaken = dashboardIsClientEmailTaken 
    , createClient = dashboardCreateClient 
    , updateClient = dashboardUpdateClient 
    , listIrmaaBracketsByEffectiveDate = dashboardListIrmaaBracketsByEffectiveDate 
    , listDrugQuotesByClientIdAndEffectiveDate = dashboardListDrugQuotesByClientIdAndEffectiveDate 
    , listDentalQuotesByClientId = dashboardListDentalQuotesByClientId 
    , listSupplementalQuotesByClientIdAndEffectiveDate = dashboardListSupplementalQuotesByClientIdAndEffectiveDate 
    , listSupplementalQuotesForQuote = dashboardListSupplementalQuotesForQuote 
    , listQuotes = dashboardListQuotes 
    , getQuote = dashboardGetQuote 
    , getSpouseQuote = dashboardGetSpouseQuote 
    , createQuote = dashboardCreateQuote 
    , updateQuote = dashboardUpdateQuote 
    , sendQuote = dashboardSendQuote 
    }    
    
    
dashboardWhoAmI : Request Agent
dashboardWhoAmI =
    let
        encoder : Encode.Value
        encoder =
            Encode.object []

        decoder : Decoder Agent
        decoder =
            Decode.field "agent" agentDecoder
    in
    request
        { url = "/rpc/Dashboard/WhoAmI"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardSignOut : Request ()
dashboardSignOut =
    let
        encoder : Encode.Value
        encoder =
            Encode.object []

        decoder : Decoder ()
        decoder = 
            Decode.succeed ()
    in
    request
        { url = "/rpc/Dashboard/SignOut"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardSearch : String -> Request (List SearchResult)
dashboardSearch term =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("term", Encode.string term)
                ]

        decoder : Decoder (List SearchResult)
        decoder =
            Decode.field "results" (Decode.list searchResultDecoder)
    in
    request
        { url = "/rpc/Dashboard/Search"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardListCountiesByZipCode : String -> Request (List County)
dashboardListCountiesByZipCode zipCode =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("zipCode", Encode.string zipCode)
                ]

        decoder : Decoder (List County)
        decoder =
            Decode.field "counties" (Decode.list countyDecoder)
    in
    request
        { url = "/rpc/Dashboard/ListCountiesByZipCode"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardSearchClients : String -> Request (List Client)
dashboardSearchClients term =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("term", Encode.string term)
                ]

        decoder : Decoder (List Client)
        decoder =
            Decode.field "clients" (Decode.list clientDecoder)
    in
    request
        { url = "/rpc/Dashboard/SearchClients"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardGetClient : Int -> Request Client
dashboardGetClient id =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("id", Encode.int id)
                ]

        decoder : Decoder Client
        decoder =
            Decode.field "client" clientDecoder
    in
    request
        { url = "/rpc/Dashboard/GetClient"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardIsClientEmailTaken : String -> Maybe Int -> Request Bool
dashboardIsClientEmailTaken email excludeId =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("email", Encode.string email)
                , ("excludeId", encodeMaybe Encode.int excludeId)
                ]

        decoder : Decoder Bool
        decoder =
            Decode.field "isTaken" Decode.bool
    in
    request
        { url = "/rpc/Dashboard/IsClientEmailTaken"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardCreateClient : CreateClientParams -> Request Client
dashboardCreateClient params =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("params", createClientParamsEncoder params)
                ]

        decoder : Decoder Client
        decoder =
            Decode.field "client" clientDecoder
    in
    request
        { url = "/rpc/Dashboard/CreateClient"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardUpdateClient : UpdateClientParams -> Request Client
dashboardUpdateClient params =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("params", updateClientParamsEncoder params)
                ]

        decoder : Decoder Client
        decoder =
            Decode.field "client" clientDecoder
    in
    request
        { url = "/rpc/Dashboard/UpdateClient"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardListIrmaaBracketsByEffectiveDate : String -> Request (List IrmaaBracket)
dashboardListIrmaaBracketsByEffectiveDate effectiveDate =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("effectiveDate", Encode.string effectiveDate)
                ]

        decoder : Decoder (List IrmaaBracket)
        decoder =
            Decode.field "irmaaBrackets" (Decode.list irmaaBracketDecoder)
    in
    request
        { url = "/rpc/Dashboard/ListIrmaaBracketsByEffectiveDate"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardListDrugQuotesByClientIdAndEffectiveDate : Int -> String -> Request (List DrugQuote)
dashboardListDrugQuotesByClientIdAndEffectiveDate clientId effectiveDate =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("clientId", Encode.int clientId)
                , ("effectiveDate", Encode.string effectiveDate)
                ]

        decoder : Decoder (List DrugQuote)
        decoder =
            Decode.field "quotes" (Decode.list drugQuoteDecoder)
    in
    request
        { url = "/rpc/Dashboard/ListDrugQuotesByClientIdAndEffectiveDate"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardListDentalQuotesByClientId : Int -> Request (List DentalQuote)
dashboardListDentalQuotesByClientId clientId =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("clientId", Encode.int clientId)
                ]

        decoder : Decoder (List DentalQuote)
        decoder =
            Decode.field "quotes" (Decode.list dentalQuoteDecoder)
    in
    request
        { url = "/rpc/Dashboard/ListDentalQuotesByClientId"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardListSupplementalQuotesByClientIdAndEffectiveDate : Int -> String -> List SupplementalPlanType -> CarrierGroup -> Request (List SupplementalQuote)
dashboardListSupplementalQuotesByClientIdAndEffectiveDate clientId effectiveDate plans carrierGroup =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("clientId", Encode.int clientId)
                , ("effectiveDate", Encode.string effectiveDate)
                , ("plans", Encode.list supplementalPlanTypeEncoder plans)
                , ("carrierGroup", carrierGroupEncoder carrierGroup)
                ]

        decoder : Decoder (List SupplementalQuote)
        decoder =
            Decode.field "quotes" (Decode.list supplementalQuoteDecoder)
    in
    request
        { url = "/rpc/Dashboard/ListSupplementalQuotesByClientIdAndEffectiveDate"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardListSupplementalQuotesForQuote : Int -> Request (List SupplementalQuote)
dashboardListSupplementalQuotesForQuote quoteId =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("quoteId", Encode.int quoteId)
                ]

        decoder : Decoder (List SupplementalQuote)
        decoder =
            Decode.field "quotes" (Decode.list supplementalQuoteDecoder)
    in
    request
        { url = "/rpc/Dashboard/ListSupplementalQuotesForQuote"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardListQuotes : ListQuotesParams -> Request ListQuotesResponse
dashboardListQuotes params =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("params", listQuotesParamsEncoder params)
                ]

        decoder : Decoder ListQuotesResponse
        decoder =
            Decode.field "response" listQuotesResponseDecoder
    in
    request
        { url = "/rpc/Dashboard/ListQuotes"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardGetQuote : Int -> Request Quote
dashboardGetQuote id =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("id", Encode.int id)
                ]

        decoder : Decoder Quote
        decoder =
            Decode.field "quote" quoteDecoder
    in
    request
        { url = "/rpc/Dashboard/GetQuote"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardGetSpouseQuote : Int -> Request Quote
dashboardGetSpouseQuote id =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("id", Encode.int id)
                ]

        decoder : Decoder Quote
        decoder =
            Decode.field "quote" quoteDecoder
    in
    request
        { url = "/rpc/Dashboard/GetSpouseQuote"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardCreateQuote : CreateQuoteParams -> Maybe CreateQuoteParams -> Request Quote
dashboardCreateQuote client spouse =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("client", createQuoteParamsEncoder client)
                , ("spouse", encodeMaybe createQuoteParamsEncoder spouse)
                ]

        decoder : Decoder Quote
        decoder =
            Decode.field "quote" quoteDecoder
    in
    request
        { url = "/rpc/Dashboard/CreateQuote"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardUpdateQuote : UpdateQuoteParams -> Maybe UpdateSpouseQuoteParams -> Request Quote
dashboardUpdateQuote client spouse =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("client", updateQuoteParamsEncoder client)
                , ("spouse", encodeMaybe updateSpouseQuoteParamsEncoder spouse)
                ]

        decoder : Decoder Quote
        decoder =
            Decode.field "quote" quoteDecoder
    in
    request
        { url = "/rpc/Dashboard/UpdateQuote"
        , encoder = encoder
        , decoder = decoder        
        }


dashboardSendQuote : Int -> String -> Request ()
dashboardSendQuote id emailOrPhone =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("id", Encode.int id)
                , ("emailOrPhone", Encode.string emailOrPhone)
                ]

        decoder : Decoder ()
        decoder = 
            Decode.succeed ()
    in
    request
        { url = "/rpc/Dashboard/SendQuote"
        , encoder = encoder
        , decoder = decoder        
        }





type alias Public =
    { getQuote : String -> Request Quote
    , getSpouseQuote : String -> Request Quote
    , listSupplementalQuotesForQuote : String -> Request (List SupplementalQuote)
    }


public : Public
public =
    { getQuote = publicGetQuote 
    , getSpouseQuote = publicGetSpouseQuote 
    , listSupplementalQuotesForQuote = publicListSupplementalQuotesForQuote 
    }    
    
    
publicGetQuote : String -> Request Quote
publicGetQuote urlId =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("urlId", Encode.string urlId)
                ]

        decoder : Decoder Quote
        decoder =
            Decode.field "quote" quoteDecoder
    in
    request
        { url = "/rpc/Public/GetQuote"
        , encoder = encoder
        , decoder = decoder        
        }


publicGetSpouseQuote : String -> Request Quote
publicGetSpouseQuote urlId =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("urlId", Encode.string urlId)
                ]

        decoder : Decoder Quote
        decoder =
            Decode.field "quote" quoteDecoder
    in
    request
        { url = "/rpc/Public/GetSpouseQuote"
        , encoder = encoder
        , decoder = decoder        
        }


publicListSupplementalQuotesForQuote : String -> Request (List SupplementalQuote)
publicListSupplementalQuotesForQuote urlId =
    let
        encoder : Encode.Value
        encoder =
            Encode.object
                [ ("urlId", Encode.string urlId)
                ]

        decoder : Decoder (List SupplementalQuote)
        decoder =
            Decode.field "supplementalQuotes" (Decode.list supplementalQuoteDecoder)
    in
    request
        { url = "/rpc/Public/ListSupplementalQuotesForQuote"
        , encoder = encoder
        , decoder = decoder        
        }


-- REQUEST


type Request a =
    Request 
        { url: String
        , decoder : Decoder a
        , encoder : Encode.Value
        , baseUrl : String
        , withCredentials : Bool
        , tracker : Maybe String
        , timeout : Maybe Float
        }


request : {url: String, decoder : Decoder a, encoder : Encode.Value} -> Request a
request { url, decoder, encoder } =
    Request
        { url = url
        , decoder = decoder
        , encoder = encoder
        , baseUrl = ""
        , withCredentials = False
        , timeout = Just 30000
        , tracker = Nothing
        }


withBaseUrl : String -> Request a -> Request a
withBaseUrl baseUrl (Request req) =
    Request { req | baseUrl = baseUrl }


withCredentials : Bool -> Request a -> Request a
withCredentials withCreds (Request req) =
    Request { req | withCredentials = withCreds }


withTimeout : Maybe Float -> Request a -> Request a
withTimeout timeout (Request req) =
    Request { req | timeout = timeout }


withTracker : Maybe String -> Request a -> Request a
withTracker tracker (Request req) =
    Request { req | tracker = tracker }


send : (Result Error a -> msg) -> Request a -> Cmd msg
send toMsg (Request req)  =
    let
        url =
            req.baseUrl ++ req.url

        body =
            req.encoder

        decoder =
            req.decoder

        timeout =
            req.timeout

        tracker =
            req.tracker            

        httpRequest =
            if req.withCredentials then
                Http.riskyRequest

            else
                Http.request
    in
    httpRequest
        { method = "POST"
        , headers = []
        , url = url
        , body = Http.jsonBody body
        , expect = expectJson toMsg decoder
        , timeout = timeout
        , tracker = tracker
        }


task : Request a -> Task Error a
task (Request req) =
    let
        url =
            req.baseUrl ++ req.url

        body =
            req.encoder

        decoder =
            req.decoder

        timeout =
            req.timeout

        httpTask =
            if req.withCredentials then
                Http.riskyTask

            else
                Http.task
    in
    httpTask
        { method = "POST"
        , headers = []
        , url = url
        , body = Http.jsonBody body
        , resolver = jsonResolver decoder
        , timeout = timeout
        }


-- DECODERS


carrierGroupDecoder : Decoder CarrierGroup
carrierGroupDecoder =
    let
        enumDecoder : String -> Decoder CarrierGroup
        enumDecoder str =
            case str of
                "Supported" -> 
                    Decode.succeed CarrierGroupSupported
                
                "All" -> 
                    Decode.succeed CarrierGroupAll
                
                _ -> 
                    Decode.fail ("unknown value for type CarrierGroup: " ++ str)
    in
    Decode.string |> Decode.andThen enumDecoder  


genderDecoder : Decoder Gender
genderDecoder =
    let
        enumDecoder : String -> Decoder Gender
        enumDecoder str =
            case str of
                "Male" -> 
                    Decode.succeed GenderMale
                
                "Female" -> 
                    Decode.succeed GenderFemale
                
                _ -> 
                    Decode.fail ("unknown value for type Gender: " ++ str)
    in
    Decode.string |> Decode.andThen enumDecoder  


filingTypeDecoder : Decoder FilingType
filingTypeDecoder =
    let
        enumDecoder : String -> Decoder FilingType
        enumDecoder str =
            case str of
                "Individual" -> 
                    Decode.succeed FilingTypeIndividual
                
                "MarriedFilingJointly" -> 
                    Decode.succeed FilingTypeMarriedFilingJointly
                
                "MarriedFilingSeparately" -> 
                    Decode.succeed FilingTypeMarriedFilingSeparately
                
                _ -> 
                    Decode.fail ("unknown value for type FilingType: " ++ str)
    in
    Decode.string |> Decode.andThen enumDecoder  


supplementalPlanTypeDecoder : Decoder SupplementalPlanType
supplementalPlanTypeDecoder =
    let
        enumDecoder : String -> Decoder SupplementalPlanType
        enumDecoder str =
            case str of
                "F" -> 
                    Decode.succeed SupplementalPlanTypeF
                
                "G" -> 
                    Decode.succeed SupplementalPlanTypeG
                
                "N" -> 
                    Decode.succeed SupplementalPlanTypeN
                
                _ -> 
                    Decode.fail ("unknown value for type SupplementalPlanType: " ++ str)
    in
    Decode.string |> Decode.andThen enumDecoder  


discountCategoryDecoder : Decoder DiscountCategory
discountCategoryDecoder =
    let
        enumDecoder : String -> Decoder DiscountCategory
        enumDecoder str =
            case str of
                "MultiInsured" -> 
                    Decode.succeed DiscountCategoryMultiInsured
                
                "LivingWithSomeone" -> 
                    Decode.succeed DiscountCategoryLivingWithSomeone
                
                _ -> 
                    Decode.fail ("unknown value for type DiscountCategory: " ++ str)
    in
    Decode.string |> Decode.andThen enumDecoder  


searchResultTypeDecoder : Decoder SearchResultType
searchResultTypeDecoder =
    let
        enumDecoder : String -> Decoder SearchResultType
        enumDecoder str =
            case str of
                "Client" -> 
                    Decode.succeed SearchResultTypeClient
                
                "Quote" -> 
                    Decode.succeed SearchResultTypeQuote
                
                _ -> 
                    Decode.fail ("unknown value for type SearchResultType: " ++ str)
    in
    Decode.string |> Decode.andThen enumDecoder  


countyDecoder : Decoder County
countyDecoder =
    Decode.succeed County
        |> andMap (Decode.field "fipsCode" Decode.string)
        |> andMap (Decode.field "name" Decode.string)
        |> andMap (Decode.field "stateAlphaCode" Decode.string)


agentDecoder : Decoder Agent
agentDecoder =
    Decode.succeed Agent
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "firstName" Decode.string)
        |> andMap (Decode.field "lastName" Decode.string)
        |> andMap (Decode.field "email" Decode.string)
        |> andMap (Decode.field "phone" Decode.string)
        |> andMap (decodeOptionalField "phoneExt" Decode.int)
        |> andMap (Decode.field "createdAt" Iso8601.decoder)
        |> andMap (Decode.field "updatedAt" Iso8601.decoder)


clientDecoder : Decoder Client
clientDecoder =
    Decode.succeed Client
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "firstName" Decode.string)
        |> andMap (Decode.field "lastName" Decode.string)
        |> andMap (Decode.field "dateOfBirth" Decode.string)
        |> andMap (Decode.field "age" Decode.int)
        |> andMap (Decode.field "gender" genderDecoder)
        |> andMap (Decode.field "zipCode" Decode.string)
        |> andMap (Decode.field "county" countyDecoder)
        |> andMap (decodeOptionalField "email" Decode.string)
        |> andMap (decodeOptionalField "phone" Decode.string)
        |> andMap (Decode.field "isTobaccoUser" Decode.bool)
        |> andMap (Decode.field "createdAt" Iso8601.decoder)
        |> andMap (Decode.field "updatedAt" Iso8601.decoder)


irmaaBracketDecoder : Decoder IrmaaBracket
irmaaBracketDecoder =
    Decode.succeed IrmaaBracket
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "year" Decode.int)
        |> andMap (Decode.field "filingType" filingTypeDecoder)
        |> andMap (Decode.field "fromCents" Decode.int)
        |> andMap (decodeOptionalField "toCents" Decode.int)
        |> andMap (Decode.field "partBIrmaaCents" Decode.int)
        |> andMap (Decode.field "partBMonthlyPremiumCents" Decode.int)
        |> andMap (Decode.field "partDIrmaaCents" Decode.int)


carrierDecoder : Decoder Carrier
carrierDecoder =
    Decode.succeed Carrier
        |> andMap (Decode.field "naic" Decode.string)
        |> andMap (Decode.field "name" Decode.string)
        |> andMap (Decode.field "isPreferred" Decode.bool)
        |> andMap (decodeOptionalField "logoUrl" Decode.string)


drugQuoteDecoder : Decoder DrugQuote
drugQuoteDecoder =
    Decode.succeed DrugQuote
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "contractYear" Decode.int)
        |> andMap (Decode.field "contractId" Decode.string)
        |> andMap (Decode.field "planId" Decode.int)
        |> andMap (Decode.field "stateAlphaCode" Decode.string)
        |> andMap (Decode.field "companyName" Decode.string)
        |> andMap (Decode.field "planName" Decode.string)
        |> andMap (Decode.field "monthlyRateCents" Decode.int)


supplementalQuoteDecoder : Decoder SupplementalQuote
supplementalQuoteDecoder =
    Decode.succeed SupplementalQuote
        |> andMap (Decode.field "carrier" carrierDecoder)
        |> andMap (Decode.field "planType" supplementalPlanTypeDecoder)
        |> andMap (Decode.field "monthlyRateCents" Decode.int)
        |> andMap (decodeOptionalField "multiInsuredDiscountRateCents" Decode.int)
        |> andMap (decodeOptionalField "livingWithSomeoneDiscountRateCents" Decode.int)


dentalQuoteDecoder : Decoder DentalQuote
dentalQuoteDecoder =
    Decode.succeed DentalQuote
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "stateAlphaCode" Decode.string)
        |> andMap (Decode.field "carrierNaic" Decode.string)
        |> andMap (Decode.field "carrierName" Decode.string)
        |> andMap (Decode.field "annualBenefitCents" Decode.int)
        |> andMap (Decode.field "monthlyRateCents" Decode.int)


quoteDecoder : Decoder Quote
quoteDecoder =
    Decode.succeed Quote
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (decodeOptionalField "parentId" Decode.int)
        |> andMap (Decode.field "urlId" Decode.string)
        |> andMap (Decode.field "agent" agentDecoder)
        |> andMap (Decode.field "client" clientDecoder)
        |> andMap (Decode.field "effectiveDate" Iso8601.decoder)
        |> andMap (Decode.field "irmaaBracket" irmaaBracketDecoder)
        |> andMap (decodeOptionalField "drugQuote" drugQuoteDecoder)
        |> andMap (decodeOptionalField "dentalQuote" dentalQuoteDecoder)
        |> andMap (Decode.field "supplementalCarrierPlanTypes" (Decode.list supplementalCarrierPlanTypeDecoder))
        |> andMap (Decode.field "hasMultiInsuredDiscount" Decode.bool)
        |> andMap (Decode.field "hasLivingWithSomeoneDiscount" Decode.bool)
        |> andMap (Decode.field "createdAt" Iso8601.decoder)
        |> andMap (Decode.field "updatedAt" Iso8601.decoder)


shortQuoteDecoder : Decoder ShortQuote
shortQuoteDecoder =
    Decode.succeed ShortQuote
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "urlId" Decode.string)
        |> andMap (Decode.field "agent" agentDecoder)
        |> andMap (Decode.field "client" clientDecoder)
        |> andMap (Decode.field "effectiveDate" Iso8601.decoder)
        |> andMap (Decode.field "createdAt" Iso8601.decoder)
        |> andMap (Decode.field "updatedAt" Iso8601.decoder)


supplementalCarrierPlanTypeDecoder : Decoder SupplementalCarrierPlanType
supplementalCarrierPlanTypeDecoder =
    Decode.succeed SupplementalCarrierPlanType
        |> andMap (Decode.field "carrierNaic" Decode.string)
        |> andMap (Decode.field "planType" supplementalPlanTypeDecoder)


searchResultDecoder : Decoder SearchResult
searchResultDecoder =
    Decode.succeed SearchResult
        |> andMap (Decode.field "type" searchResultTypeDecoder)
        |> andMap (Decode.field "primaryDescription" Decode.string)
        |> andMap (Decode.field "secondaryDescription" Decode.string)
        |> andMap (Decode.field "id" Decode.int)


createClientParamsDecoder : Decoder CreateClientParams
createClientParamsDecoder =
    Decode.succeed CreateClientParams
        |> andMap (Decode.field "firstName" Decode.string)
        |> andMap (Decode.field "lastName" Decode.string)
        |> andMap (Decode.field "dateOfBirth" Decode.string)
        |> andMap (Decode.field "gender" genderDecoder)
        |> andMap (Decode.field "zipCode" Decode.string)
        |> andMap (Decode.field "countyFipsCode" Decode.string)
        |> andMap (decodeOptionalField "email" Decode.string)
        |> andMap (decodeOptionalField "phone" Decode.string)
        |> andMap (Decode.field "isTobaccoUser" Decode.bool)


updateClientParamsDecoder : Decoder UpdateClientParams
updateClientParamsDecoder =
    Decode.succeed UpdateClientParams
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "firstName" Decode.string)
        |> andMap (Decode.field "lastName" Decode.string)
        |> andMap (Decode.field "dateOfBirth" Decode.string)
        |> andMap (Decode.field "gender" genderDecoder)
        |> andMap (Decode.field "zipCode" Decode.string)
        |> andMap (Decode.field "countyFipsCode" Decode.string)
        |> andMap (decodeOptionalField "email" Decode.string)
        |> andMap (decodeOptionalField "phone" Decode.string)
        |> andMap (Decode.field "isTobaccoUser" Decode.bool)


createQuoteParamsDecoder : Decoder CreateQuoteParams
createQuoteParamsDecoder =
    Decode.succeed CreateQuoteParams
        |> andMap (Decode.field "clientId" Decode.int)
        |> andMap (Decode.field "effectiveDate" Decode.string)
        |> andMap (Decode.field "irmaaBracketId" Decode.int)
        |> andMap (decodeOptionalField "drugQuoteId" Decode.int)
        |> andMap (decodeOptionalField "dentalQuoteId" Decode.int)
        |> andMap (Decode.field "supplementalCarrierPlanTypes" (Decode.list supplementalCarrierPlanTypeDecoder))
        |> andMap (Decode.field "hasMultiInsuredDiscount" Decode.bool)
        |> andMap (Decode.field "hasLivingWithSomeoneDiscount" Decode.bool)


updateQuoteParamsDecoder : Decoder UpdateQuoteParams
updateQuoteParamsDecoder =
    Decode.succeed UpdateQuoteParams
        |> andMap (Decode.field "id" Decode.int)
        |> andMap (Decode.field "clientId" Decode.int)
        |> andMap (Decode.field "effectiveDate" Decode.string)
        |> andMap (Decode.field "irmaaBracketId" Decode.int)
        |> andMap (decodeOptionalField "drugQuoteId" Decode.int)
        |> andMap (decodeOptionalField "dentalQuoteId" Decode.int)
        |> andMap (Decode.field "supplementalCarrierPlanTypes" (Decode.list supplementalCarrierPlanTypeDecoder))
        |> andMap (Decode.field "hasMultiInsuredDiscount" Decode.bool)
        |> andMap (Decode.field "hasLivingWithSomeoneDiscount" Decode.bool)


updateSpouseQuoteParamsDecoder : Decoder UpdateSpouseQuoteParams
updateSpouseQuoteParamsDecoder =
    Decode.succeed UpdateSpouseQuoteParams
        |> andMap (Decode.field "clientId" Decode.int)
        |> andMap (Decode.field "effectiveDate" Decode.string)
        |> andMap (Decode.field "irmaaBracketId" Decode.int)
        |> andMap (decodeOptionalField "drugQuoteId" Decode.int)
        |> andMap (decodeOptionalField "dentalQuoteId" Decode.int)
        |> andMap (Decode.field "supplementalCarrierPlanTypes" (Decode.list supplementalCarrierPlanTypeDecoder))
        |> andMap (Decode.field "hasMultiInsuredDiscount" Decode.bool)
        |> andMap (Decode.field "hasLivingWithSomeoneDiscount" Decode.bool)


listQuotesParamsDecoder : Decoder ListQuotesParams
listQuotesParamsDecoder =
    Decode.succeed ListQuotesParams
        |> andMap (decodeOptionalField "clientId" Decode.int)
        |> andMap (decodeOptionalField "startingAfter" Decode.int)
        |> andMap (decodeOptionalField "endingBefore" Decode.int)
        |> andMap (Decode.field "limit" Decode.int)


listQuotesResponseDecoder : Decoder ListQuotesResponse
listQuotesResponseDecoder =
    Decode.succeed ListQuotesResponse
        |> andMap (Decode.field "data" (Decode.list shortQuoteDecoder))
        |> andMap (Decode.field "totalCount" Decode.int)
        |> andMap (Decode.field "hasMore" Decode.bool)


getQuoteResponseDecoder : Decoder GetQuoteResponse
getQuoteResponseDecoder =
    Decode.succeed GetQuoteResponse
        |> andMap (Decode.field "quote" quoteDecoder)
        |> andMap (decodeOptionalField "spouseQuote" quoteDecoder)


publicQuotePageDataDecoder : Decoder PublicQuotePageData
publicQuotePageDataDecoder =
    Decode.succeed PublicQuotePageData
        |> andMap (Decode.field "client" publicQuoteClientDataDecoder)
        |> andMap (decodeOptionalField "spouse" publicQuoteClientDataDecoder)


publicQuoteClientDataDecoder : Decoder PublicQuoteClientData
publicQuoteClientDataDecoder =
    Decode.succeed PublicQuoteClientData
        |> andMap (Decode.field "quote" quoteDecoder)
        |> andMap (Decode.field "irmaaBracket" irmaaBracketDecoder)
        |> andMap (decodeOptionalField "drugQuote" drugQuoteDecoder)


-- ENCODERS


carrierGroupEncoder : CarrierGroup -> Encode.Value
carrierGroupEncoder carrierGroup =
    case carrierGroup of
        CarrierGroupSupported ->
            Encode.string "Supported"
        
        CarrierGroupAll ->
            Encode.string "All"
        

genderEncoder : Gender -> Encode.Value
genderEncoder gender =
    case gender of
        GenderMale ->
            Encode.string "Male"
        
        GenderFemale ->
            Encode.string "Female"
        

filingTypeEncoder : FilingType -> Encode.Value
filingTypeEncoder filingType =
    case filingType of
        FilingTypeIndividual ->
            Encode.string "Individual"
        
        FilingTypeMarriedFilingJointly ->
            Encode.string "MarriedFilingJointly"
        
        FilingTypeMarriedFilingSeparately ->
            Encode.string "MarriedFilingSeparately"
        

supplementalPlanTypeEncoder : SupplementalPlanType -> Encode.Value
supplementalPlanTypeEncoder supplementalPlanType =
    case supplementalPlanType of
        SupplementalPlanTypeF ->
            Encode.string "F"
        
        SupplementalPlanTypeG ->
            Encode.string "G"
        
        SupplementalPlanTypeN ->
            Encode.string "N"
        

discountCategoryEncoder : DiscountCategory -> Encode.Value
discountCategoryEncoder discountCategory =
    case discountCategory of
        DiscountCategoryMultiInsured ->
            Encode.string "MultiInsured"
        
        DiscountCategoryLivingWithSomeone ->
            Encode.string "LivingWithSomeone"
        

searchResultTypeEncoder : SearchResultType -> Encode.Value
searchResultTypeEncoder searchResultType =
    case searchResultType of
        SearchResultTypeClient ->
            Encode.string "Client"
        
        SearchResultTypeQuote ->
            Encode.string "Quote"
        

countyEncoder : County -> Encode.Value
countyEncoder county =
    Encode.object
        [ ("fipsCode", Encode.string county.fipsCode)
        , ("name", Encode.string county.name)
        , ("stateAlphaCode", Encode.string county.stateAlphaCode)
        ]


agentEncoder : Agent -> Encode.Value
agentEncoder agent =
    Encode.object
        [ ("id", Encode.int agent.id)
        , ("firstName", Encode.string agent.firstName)
        , ("lastName", Encode.string agent.lastName)
        , ("email", Encode.string agent.email)
        , ("phone", Encode.string agent.phone)
        , ("phoneExt", encodeMaybe Encode.int agent.phoneExt)
        , ("createdAt", Iso8601.encode agent.createdAt)
        , ("updatedAt", Iso8601.encode agent.updatedAt)
        ]


clientEncoder : Client -> Encode.Value
clientEncoder client =
    Encode.object
        [ ("id", Encode.int client.id)
        , ("firstName", Encode.string client.firstName)
        , ("lastName", Encode.string client.lastName)
        , ("dateOfBirth", Encode.string client.dateOfBirth)
        , ("age", Encode.int client.age)
        , ("gender", genderEncoder client.gender)
        , ("zipCode", Encode.string client.zipCode)
        , ("county", countyEncoder client.county)
        , ("email", encodeMaybe Encode.string client.email)
        , ("phone", encodeMaybe Encode.string client.phone)
        , ("isTobaccoUser", Encode.bool client.isTobaccoUser)
        , ("createdAt", Iso8601.encode client.createdAt)
        , ("updatedAt", Iso8601.encode client.updatedAt)
        ]


irmaaBracketEncoder : IrmaaBracket -> Encode.Value
irmaaBracketEncoder irmaaBracket =
    Encode.object
        [ ("id", Encode.int irmaaBracket.id)
        , ("year", Encode.int irmaaBracket.year)
        , ("filingType", filingTypeEncoder irmaaBracket.filingType)
        , ("fromCents", Encode.int irmaaBracket.fromCents)
        , ("toCents", encodeMaybe Encode.int irmaaBracket.toCents)
        , ("partBIrmaaCents", Encode.int irmaaBracket.partBIrmaaCents)
        , ("partBMonthlyPremiumCents", Encode.int irmaaBracket.partBMonthlyPremiumCents)
        , ("partDIrmaaCents", Encode.int irmaaBracket.partDIrmaaCents)
        ]


carrierEncoder : Carrier -> Encode.Value
carrierEncoder carrier =
    Encode.object
        [ ("naic", Encode.string carrier.naic)
        , ("name", Encode.string carrier.name)
        , ("isPreferred", Encode.bool carrier.isPreferred)
        , ("logoUrl", encodeMaybe Encode.string carrier.logoUrl)
        ]


drugQuoteEncoder : DrugQuote -> Encode.Value
drugQuoteEncoder drugQuote =
    Encode.object
        [ ("id", Encode.int drugQuote.id)
        , ("contractYear", Encode.int drugQuote.contractYear)
        , ("contractId", Encode.string drugQuote.contractId)
        , ("planId", Encode.int drugQuote.planId)
        , ("stateAlphaCode", Encode.string drugQuote.stateAlphaCode)
        , ("companyName", Encode.string drugQuote.companyName)
        , ("planName", Encode.string drugQuote.planName)
        , ("monthlyRateCents", Encode.int drugQuote.monthlyRateCents)
        ]


supplementalQuoteEncoder : SupplementalQuote -> Encode.Value
supplementalQuoteEncoder supplementalQuote =
    Encode.object
        [ ("carrier", carrierEncoder supplementalQuote.carrier)
        , ("planType", supplementalPlanTypeEncoder supplementalQuote.planType)
        , ("monthlyRateCents", Encode.int supplementalQuote.monthlyRateCents)
        , ("multiInsuredDiscountRateCents", encodeMaybe Encode.int supplementalQuote.multiInsuredDiscountRateCents)
        , ("livingWithSomeoneDiscountRateCents", encodeMaybe Encode.int supplementalQuote.livingWithSomeoneDiscountRateCents)
        ]


dentalQuoteEncoder : DentalQuote -> Encode.Value
dentalQuoteEncoder dentalQuote =
    Encode.object
        [ ("id", Encode.int dentalQuote.id)
        , ("stateAlphaCode", Encode.string dentalQuote.stateAlphaCode)
        , ("carrierNaic", Encode.string dentalQuote.carrierNaic)
        , ("carrierName", Encode.string dentalQuote.carrierName)
        , ("annualBenefitCents", Encode.int dentalQuote.annualBenefitCents)
        , ("monthlyRateCents", Encode.int dentalQuote.monthlyRateCents)
        ]


quoteEncoder : Quote -> Encode.Value
quoteEncoder quote =
    Encode.object
        [ ("id", Encode.int quote.id)
        , ("parentId", encodeMaybe Encode.int quote.parentId)
        , ("urlId", Encode.string quote.urlId)
        , ("agent", agentEncoder quote.agent)
        , ("client", clientEncoder quote.client)
        , ("effectiveDate", Iso8601.encode quote.effectiveDate)
        , ("irmaaBracket", irmaaBracketEncoder quote.irmaaBracket)
        , ("drugQuote", encodeMaybe drugQuoteEncoder quote.drugQuote)
        , ("dentalQuote", encodeMaybe dentalQuoteEncoder quote.dentalQuote)
        , ("supplementalCarrierPlanTypes", Encode.list supplementalCarrierPlanTypeEncoder quote.supplementalCarrierPlanTypes)
        , ("hasMultiInsuredDiscount", Encode.bool quote.hasMultiInsuredDiscount)
        , ("hasLivingWithSomeoneDiscount", Encode.bool quote.hasLivingWithSomeoneDiscount)
        , ("createdAt", Iso8601.encode quote.createdAt)
        , ("updatedAt", Iso8601.encode quote.updatedAt)
        ]


shortQuoteEncoder : ShortQuote -> Encode.Value
shortQuoteEncoder shortQuote =
    Encode.object
        [ ("id", Encode.int shortQuote.id)
        , ("urlId", Encode.string shortQuote.urlId)
        , ("agent", agentEncoder shortQuote.agent)
        , ("client", clientEncoder shortQuote.client)
        , ("effectiveDate", Iso8601.encode shortQuote.effectiveDate)
        , ("createdAt", Iso8601.encode shortQuote.createdAt)
        , ("updatedAt", Iso8601.encode shortQuote.updatedAt)
        ]


supplementalCarrierPlanTypeEncoder : SupplementalCarrierPlanType -> Encode.Value
supplementalCarrierPlanTypeEncoder supplementalCarrierPlanType =
    Encode.object
        [ ("carrierNaic", Encode.string supplementalCarrierPlanType.carrierNaic)
        , ("planType", supplementalPlanTypeEncoder supplementalCarrierPlanType.planType)
        ]


searchResultEncoder : SearchResult -> Encode.Value
searchResultEncoder searchResult =
    Encode.object
        [ ("type", searchResultTypeEncoder searchResult.type_)
        , ("primaryDescription", Encode.string searchResult.primaryDescription)
        , ("secondaryDescription", Encode.string searchResult.secondaryDescription)
        , ("id", Encode.int searchResult.id)
        ]


createClientParamsEncoder : CreateClientParams -> Encode.Value
createClientParamsEncoder createClientParams =
    Encode.object
        [ ("firstName", Encode.string createClientParams.firstName)
        , ("lastName", Encode.string createClientParams.lastName)
        , ("dateOfBirth", Encode.string createClientParams.dateOfBirth)
        , ("gender", genderEncoder createClientParams.gender)
        , ("zipCode", Encode.string createClientParams.zipCode)
        , ("countyFipsCode", Encode.string createClientParams.countyFipsCode)
        , ("email", encodeMaybe Encode.string createClientParams.email)
        , ("phone", encodeMaybe Encode.string createClientParams.phone)
        , ("isTobaccoUser", Encode.bool createClientParams.isTobaccoUser)
        ]


updateClientParamsEncoder : UpdateClientParams -> Encode.Value
updateClientParamsEncoder updateClientParams =
    Encode.object
        [ ("id", Encode.int updateClientParams.id)
        , ("firstName", Encode.string updateClientParams.firstName)
        , ("lastName", Encode.string updateClientParams.lastName)
        , ("dateOfBirth", Encode.string updateClientParams.dateOfBirth)
        , ("gender", genderEncoder updateClientParams.gender)
        , ("zipCode", Encode.string updateClientParams.zipCode)
        , ("countyFipsCode", Encode.string updateClientParams.countyFipsCode)
        , ("email", encodeMaybe Encode.string updateClientParams.email)
        , ("phone", encodeMaybe Encode.string updateClientParams.phone)
        , ("isTobaccoUser", Encode.bool updateClientParams.isTobaccoUser)
        ]


createQuoteParamsEncoder : CreateQuoteParams -> Encode.Value
createQuoteParamsEncoder createQuoteParams =
    Encode.object
        [ ("clientId", Encode.int createQuoteParams.clientId)
        , ("effectiveDate", Encode.string createQuoteParams.effectiveDate)
        , ("irmaaBracketId", Encode.int createQuoteParams.irmaaBracketId)
        , ("drugQuoteId", encodeMaybe Encode.int createQuoteParams.drugQuoteId)
        , ("dentalQuoteId", encodeMaybe Encode.int createQuoteParams.dentalQuoteId)
        , ("supplementalCarrierPlanTypes", Encode.list supplementalCarrierPlanTypeEncoder createQuoteParams.supplementalCarrierPlanTypes)
        , ("hasMultiInsuredDiscount", Encode.bool createQuoteParams.hasMultiInsuredDiscount)
        , ("hasLivingWithSomeoneDiscount", Encode.bool createQuoteParams.hasLivingWithSomeoneDiscount)
        ]


updateQuoteParamsEncoder : UpdateQuoteParams -> Encode.Value
updateQuoteParamsEncoder updateQuoteParams =
    Encode.object
        [ ("id", Encode.int updateQuoteParams.id)
        , ("clientId", Encode.int updateQuoteParams.clientId)
        , ("effectiveDate", Encode.string updateQuoteParams.effectiveDate)
        , ("irmaaBracketId", Encode.int updateQuoteParams.irmaaBracketId)
        , ("drugQuoteId", encodeMaybe Encode.int updateQuoteParams.drugQuoteId)
        , ("dentalQuoteId", encodeMaybe Encode.int updateQuoteParams.dentalQuoteId)
        , ("supplementalCarrierPlanTypes", Encode.list supplementalCarrierPlanTypeEncoder updateQuoteParams.supplementalCarrierPlanTypes)
        , ("hasMultiInsuredDiscount", Encode.bool updateQuoteParams.hasMultiInsuredDiscount)
        , ("hasLivingWithSomeoneDiscount", Encode.bool updateQuoteParams.hasLivingWithSomeoneDiscount)
        ]


updateSpouseQuoteParamsEncoder : UpdateSpouseQuoteParams -> Encode.Value
updateSpouseQuoteParamsEncoder updateSpouseQuoteParams =
    Encode.object
        [ ("clientId", Encode.int updateSpouseQuoteParams.clientId)
        , ("effectiveDate", Encode.string updateSpouseQuoteParams.effectiveDate)
        , ("irmaaBracketId", Encode.int updateSpouseQuoteParams.irmaaBracketId)
        , ("drugQuoteId", encodeMaybe Encode.int updateSpouseQuoteParams.drugQuoteId)
        , ("dentalQuoteId", encodeMaybe Encode.int updateSpouseQuoteParams.dentalQuoteId)
        , ("supplementalCarrierPlanTypes", Encode.list supplementalCarrierPlanTypeEncoder updateSpouseQuoteParams.supplementalCarrierPlanTypes)
        , ("hasMultiInsuredDiscount", Encode.bool updateSpouseQuoteParams.hasMultiInsuredDiscount)
        , ("hasLivingWithSomeoneDiscount", Encode.bool updateSpouseQuoteParams.hasLivingWithSomeoneDiscount)
        ]


listQuotesParamsEncoder : ListQuotesParams -> Encode.Value
listQuotesParamsEncoder listQuotesParams =
    Encode.object
        [ ("clientId", encodeMaybe Encode.int listQuotesParams.clientId)
        , ("startingAfter", encodeMaybe Encode.int listQuotesParams.startingAfter)
        , ("endingBefore", encodeMaybe Encode.int listQuotesParams.endingBefore)
        , ("limit", Encode.int listQuotesParams.limit)
        ]


listQuotesResponseEncoder : ListQuotesResponse -> Encode.Value
listQuotesResponseEncoder listQuotesResponse =
    Encode.object
        [ ("data", Encode.list shortQuoteEncoder listQuotesResponse.data)
        , ("totalCount", Encode.int listQuotesResponse.totalCount)
        , ("hasMore", Encode.bool listQuotesResponse.hasMore)
        ]


getQuoteResponseEncoder : GetQuoteResponse -> Encode.Value
getQuoteResponseEncoder getQuoteResponse =
    Encode.object
        [ ("quote", quoteEncoder getQuoteResponse.quote)
        , ("spouseQuote", encodeMaybe quoteEncoder getQuoteResponse.spouseQuote)
        ]


publicQuotePageDataEncoder : PublicQuotePageData -> Encode.Value
publicQuotePageDataEncoder publicQuotePageData =
    Encode.object
        [ ("client", publicQuoteClientDataEncoder publicQuotePageData.client)
        , ("spouse", encodeMaybe publicQuoteClientDataEncoder publicQuotePageData.spouse)
        ]


publicQuoteClientDataEncoder : PublicQuoteClientData -> Encode.Value
publicQuoteClientDataEncoder publicQuoteClientData =
    Encode.object
        [ ("quote", quoteEncoder publicQuoteClientData.quote)
        , ("irmaaBracket", irmaaBracketEncoder publicQuoteClientData.irmaaBracket)
        , ("drugQuote", encodeMaybe drugQuoteEncoder publicQuoteClientData.drugQuote)
        ]


-- ERRORS


type Error
    = BadUrl String
    | Timeout
    | NetworkError
    | BadStatus Int
    | WebrpcError WebrpcErrorName WebrpcErrorResponse    
    | BadBody String


type alias WebrpcErrorResponse =
    { name : WebrpcErrorName
    , code : Int
    , message : String
    , cause : Maybe String
    , httpStatus : Int
    }


type WebrpcErrorName
    = WebrpcEndpoint
    | WebrpcRequestFailed
    | WebrpcBadRoute
    | WebrpcBadMethod
    | WebrpcBadRequest
    | WebrpcBadResponse
    | WebrpcServerPanic
    | WebrpcInternalError
    | WebrpcClientDisconnected
    | WebrpcStreamLost
    | WebrpcStreamFinished
    | EntityNotFound
    | Unauthorized
    | InvalidArgument
    | Internal
    

webrpcErrorDecoder : Decoder Error
webrpcErrorDecoder =
    Decode.succeed WebrpcError
        |> andMap (Decode.field "error" webrpcErrorNameDecoder)
        |> andMap webrpcErrorResponseDecoder


webrpcErrorResponseDecoder : Decoder WebrpcErrorResponse
webrpcErrorResponseDecoder =
    Decode.succeed WebrpcErrorResponse
        |> andMap (Decode.field "error" webrpcErrorNameDecoder)
        |> andMap (Decode.field "code" Decode.int)
        |> andMap (Decode.field "msg" Decode.string)
        |> andMap (decodeOptionalField "cause" Decode.string)
        |> andMap (Decode.field "status" Decode.int)
        

webrpcErrorNameDecoder : Decoder WebrpcErrorName
webrpcErrorNameDecoder =
    let
        enumDecoder : String -> Decoder WebrpcErrorName
        enumDecoder str =
            case str of
                "WebrpcEndpoint" ->
                    Decode.succeed WebrpcEndpoint

                "WebrpcRequestFailed" ->
                    Decode.succeed WebrpcRequestFailed

                "WebrpcBadRoute" ->
                    Decode.succeed WebrpcBadRoute

                "WebrpcBadMethod" ->
                    Decode.succeed WebrpcBadMethod

                "WebrpcBadRequest" ->
                    Decode.succeed WebrpcBadRequest

                "WebrpcBadResponse" ->
                    Decode.succeed WebrpcBadResponse

                "WebrpcServerPanic" ->
                    Decode.succeed WebrpcServerPanic

                "WebrpcInternalError" ->
                    Decode.succeed WebrpcInternalError

                "WebrpcClientDisconnected" ->
                    Decode.succeed WebrpcClientDisconnected

                "WebrpcStreamLost" ->
                    Decode.succeed WebrpcStreamLost

                "WebrpcStreamFinished" ->
                    Decode.succeed WebrpcStreamFinished

                "EntityNotFound" ->
                    Decode.succeed EntityNotFound

                "Unauthorized" ->
                    Decode.succeed Unauthorized

                "InvalidArgument" ->
                    Decode.succeed InvalidArgument

                "Internal" ->
                    Decode.succeed Internal

                _ -> 
                    Decode.fail ("unknown value for type WebrpcErrorName: " ++ str)
    in
    Decode.string |> Decode.andThen enumDecoder     



-- Value


type Value
    = ObjectValue (List ( String, Value ))
    | ArrayValue (List Value)
    | BoolValue Bool
    | NullValue
    | NumericValue Float
    | StringValue String


valueDecoder : Decoder Value
valueDecoder =
    let
        objectValueDecoder =
            Decode.keyValuePairs (Decode.lazy (\_ -> valueDecoder))
                |> Decode.map ObjectValue

        arrayValueDecoder =
            Decode.list (Decode.lazy (\_ -> valueDecoder))
                |> Decode.map ArrayValue
    in
    Decode.oneOf
        [ objectValueDecoder
        , arrayValueDecoder
        , Decode.null NullValue
        , Decode.string |> Decode.map StringValue
        , Decode.float |> Decode.map NumericValue
        , Decode.bool |> Decode.map BoolValue
        ]


valueEncoder : Value -> Encode.Value
valueEncoder value =
    case value of
        ObjectValue pairs ->
            pairs
                |> List.map (\( k, v ) -> ( k, valueEncoder v ))
                |> Encode.object

        ArrayValue values ->
            Encode.list valueEncoder values
            
        BoolValue bool ->
            Encode.bool bool

        NullValue ->
            Encode.null

        NumericValue float ->
            Encode.float float

        StringValue string ->
            Encode.string string


-- HELPERS


andMap : Decoder a -> Decoder (a -> b) -> Decoder b
andMap =
    Decode.map2 (|>)


decodeOptionalField : String -> Decoder a -> Decoder (Maybe a)
decodeOptionalField fieldName decoder =
    let
        finishDecoding json =
            case Decode.decodeValue (Decode.field fieldName Decode.value) json of
                Ok _ ->
                    Decode.map Just (Decode.field fieldName decoder)

                Err _ ->
                    Decode.succeed Nothing
    in
    Decode.oneOf
        [ Decode.field fieldName (Decode.null Nothing)
        , Decode.value |> Decode.andThen finishDecoding
        ]


decodeDict : (String -> Maybe comparable) -> Decoder v -> Decoder (Dict comparable v)
decodeDict toKey valDecoder =
    Decode.keyValuePairs valDecoder
        |> Decode.andThen (decodeDictFromTuples toKey)


decodeDictFromTuples : (String -> Maybe comparable) -> List ( String, v ) -> Decoder (Dict comparable v)
decodeDictFromTuples toKey tuples =
    case tuples of
        [] ->
            Decode.succeed Dict.empty

        ( strKey, value ) :: rest ->
            case toKey strKey of
                Just key ->
                    decodeDictFromTuples toKey rest
                        |> Decode.andThen (Dict.insert key value >> Decode.succeed)

                Nothing ->
                    Decode.fail ("failed to decode key: " ++ strKey)  


encodeMaybe : (a -> Encode.Value) -> Maybe a -> Encode.Value
encodeMaybe encoder =
    Maybe.map encoder >> Maybe.withDefault Encode.null
    
    
expectJson : (Result Error a -> msg) -> Decoder a -> Http.Expect msg
expectJson toMsg decoder =
    Http.expectStringResponse 
        toMsg 
        (\response ->
            case response of
                Http.BadUrl_ url ->
                    Err (BadUrl url)

                Http.Timeout_ ->
                    Err Timeout

                Http.NetworkError_ ->
                    Err NetworkError

                Http.BadStatus_ metadata body ->
                    let
                        contentType =
                            metadata.headers
                                |> Dict.get "content-type"
                                |> Maybe.withDefault ""
                    in
                    if String.contains "application/json" contentType then
                        case Decode.decodeString webrpcErrorDecoder body of
                            Ok webrpcError ->
                                Err webrpcError

                            Err err ->
                                Err (BadBody (Decode.errorToString err))
                    else
                        Err (BadStatus metadata.statusCode)

                Http.GoodStatus_ _ body ->
                    case Decode.decodeString decoder body of
                        Ok value ->
                            Ok value

                        Err err ->
                            Err (BadBody (Decode.errorToString err))
        )


jsonResolver : Decoder a -> Http.Resolver Error a
jsonResolver decoder =
    Http.stringResolver
        (\ response ->
            case response of
                Http.BadUrl_ url ->
                    Err (BadUrl url)

                Http.Timeout_ ->
                    Err Timeout

                Http.NetworkError_ ->
                    Err NetworkError

                Http.BadStatus_ metadata body ->
                    let
                        contentType =
                            metadata.headers
                                |> Dict.get "content-type"
                                |> Maybe.withDefault ""
                    in
                    if String.contains "application/json" contentType then
                        case Decode.decodeString webrpcErrorDecoder body of
                            Ok webrpcError ->
                                Err webrpcError

                            Err err ->
                                Err (BadBody (Decode.errorToString err))
                    else
                        Err (BadStatus metadata.statusCode)

                Http.GoodStatus_ _ body ->
                    case Decode.decodeString decoder body of
                        Ok value ->
                            Ok value

                        Err err ->
                            Err (BadBody (Decode.errorToString err))
        )


dictStringKey : String -> Maybe String
dictStringKey =
    Just


dictIntKey : String -> Maybe Int
dictIntKey =
    String.toInt

================
File: frontend/src/Shared.elm
================
module Shared exposing
    ( Flags, decoder
    , Model, Msg
    , init, update, subscriptions
    )

{-|

@docs Flags, decoder
@docs Model, Msg
@docs init, update, subscriptions

-}

import Effect exposing (Effect)
import Json.Decode
import Route exposing (Route)
import Route.Path
import Server
import Shared.Model
import Shared.Msg
import Task
import Time



-- FLAGS


type alias Flags =
    { oauthGoogleLoginUrl : String }


decoder : Json.Decode.Decoder Flags
decoder =
    Json.Decode.map Flags
        (Json.Decode.field "oauthGoogleLoginUrl" Json.Decode.string)


defaultFlags : Flags
defaultFlags =
    { oauthGoogleLoginUrl = "/oauth/google/login"
    }



-- INIT


type alias Model =
    Shared.Model.Model


init : Result Json.Decode.Error Flags -> Route () -> ( Model, Effect Msg )
init flagsResult route =
    let
        flags =
            Result.withDefault defaultFlags flagsResult
    in
    ( { agent = Shared.Model.Loading
      , time = Time.millisToPosix 0
      , zone = Time.utc
      , oauthGoogleLoginUrl = flags.oauthGoogleLoginUrl
      }
    , Effect.batch
        [ Server.dashboard.whoAmI
            |> Server.send Shared.Msg.CompletedWhoAmI
            |> Effect.sendCmd
        , Time.now
            |> Task.perform Shared.Msg.GotCurrentTime
            |> Effect.sendCmd
        ]
    )



-- UPDATE


type alias Msg =
    Shared.Msg.Msg


update : Route () -> Msg -> Model -> ( Model, Effect Msg )
update route msg model =
    case msg of
        Shared.Msg.GotCurrentTime time ->
            ( { model | time = time }
            , Effect.none
            )

        Shared.Msg.GotCurrentTimeZone zone ->
            ( { model | zone = zone }
            , Effect.none
            )

        Shared.Msg.SignOutRequested ->
            ( { model | agent = Shared.Model.SignedOut Nothing }
            , Effect.batch
                [ Effect.pushRoutePath Route.Path.SignIn
                , Server.dashboard.signOut
                    |> Server.send Shared.Msg.CompletedSignOut
                    |> Effect.sendCmd
                ]
            )

        Shared.Msg.CompletedSignOut _ ->
            ( model
            , Effect.none
            )

        Shared.Msg.CompletedWhoAmI (Ok agent) ->
            ( { model | agent = Shared.Model.SignedIn agent }
            , Effect.none
            )

        Shared.Msg.CompletedWhoAmI (Err (Server.WebrpcError Server.Unauthorized _)) ->
            ( { model | agent = Shared.Model.SignedOut Nothing }
            , Effect.none
            )

        Shared.Msg.CompletedWhoAmI (Err e) ->
            ( { model | agent = Shared.Model.SignedOut (Just e) }
            , Effect.none
            )



-- SUBSCRIPTIONS


subscriptions : Route () -> Model -> Sub Msg
subscriptions route model =
    Sub.none

================
File: frontend/src/styles.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
    :root {
        --sidebar-width: 220px;
        --header-height: 68px;
        --content-max-width: 1000px;
        --brand-color: #2fa49d;
        --brand-dark-color: #267d78;
    }

    /* FONTS */
    @font-face {
        font-family: InterVariable;
        font-style: normal;
        font-weight: 100 900;
        font-display: swap;
        src: url("./InterVariable.woff2") format("woff2");
    }

    @font-face {
        font-family: InterVariable;
        font-style: italic;
        font-weight: 100 900;
        font-display: swap;
        src: url("./InterVariable-Italic.woff2") format("woff2");
    }

    html {
        @apply font-sans leading-normal antialiased;
        text-rendering: optimizeLegibility;
    }

    body {
        @apply text-sm text-gray-800;
    }

    dialog:not([open]) {
        display: none;
    }
}

@layer utilities {
    [type="text"],
    [type="email"],
    [type="url"],
    [type="password"],
    [type="number"],
    [type="date"],
    [type="datetime-local"],
    [type="month"],
    [type="search"],
    [type="tel"],
    [type="time"],
    [type="week"],
    [multiple],
    textarea,
    select {
        @apply text-sm py-[0.5625rem] border-gray-300 rounded shadow-sm;
    }

    [type="checkbox"] {
        @apply rounded border-gray-400;
    }

    [type="radio"] {
        @apply border-gray-400;
    }

    .input-error {
        @apply border-red-500 focus:border-red-500 focus:ring-red-500;
    }
}

================
File: frontend/src/Validate.elm
================
module Validate exposing (isBlank, isCountyFipsCode, isEmail, isMinLength, isNumeric, isPhoneNumber, isZipCode)

import Regex


emailPattern : Regex.Regex
emailPattern =
    Regex.fromString "^.+@.+$"
        |> Maybe.withDefault Regex.never


zipCodePattern : Regex.Regex
zipCodePattern =
    Regex.fromString "^[0-9]{5}$"
        |> Maybe.withDefault Regex.never


countyFipsCodePattern : Regex.Regex
countyFipsCodePattern =
    Regex.fromString "^[0-9]{5}$"
        |> Maybe.withDefault Regex.never


numericPattern : Regex.Regex
numericPattern =
    Regex.fromString "^[0-9]+$"
        |> Maybe.withDefault Regex.never


phonePattern : Regex.Regex
phonePattern =
    Regex.fromString "^[0-9]+(?:-[0-9]+)*$"
        |> Maybe.withDefault Regex.never


isNumeric : String -> Bool
isNumeric =
    Regex.contains numericPattern


isBlank : String -> Bool
isBlank s =
    String.isEmpty (String.trim s)


isEmail : String -> Bool
isEmail =
    Regex.contains emailPattern


isZipCode : String -> Bool
isZipCode =
    Regex.contains zipCodePattern


isCountyFipsCode : String -> Bool
isCountyFipsCode =
    Regex.contains countyFipsCodePattern


isPhoneNumber : String -> Bool
isPhoneNumber =
    Regex.contains phonePattern


isMinLength : Int -> String -> Bool
isMinLength min str =
    String.length str >= min

================
File: frontend/src/View.elm
================
module View exposing
    ( View, map
    , none, fromString
    , toBrowserDocument
    )

{-|

@docs View, map
@docs none, fromString
@docs toBrowserDocument

-}

import Browser
import Html exposing (Html)
import Route exposing (Route)
import Shared.Model


type alias View msg =
    { title : String
    , body : List (Html msg)
    }


{-| Used internally by Elm Land to create your application
so it works with Elm's expected `Browser.Document msg` type.
-}
toBrowserDocument :
    { shared : Shared.Model.Model
    , route : Route ()
    , view : View msg
    }
    -> Browser.Document msg
toBrowserDocument { view } =
    let
        title_ =
            [ "Maxquote", view.title ]
                |> List.filter (not << String.isEmpty)
                |> String.join " | "
    in
    { title = title_
    , body = view.body
    }


{-| Used internally by Elm Land to connect your pages together.
-}
map : (msg1 -> msg2) -> View msg1 -> View msg2
map fn view =
    { title = view.title
    , body = List.map (Html.map fn) view.body
    }


{-| Used internally by Elm Land whenever transitioning between
authenticated pages.
-}
none : View msg
none =
    { title = ""
    , body = []
    }


{-| If you customize the `View` module, anytime you run `elm-land add page`,
the generated page will use this when adding your `view` function.

That way your app will compile after adding new pages, and you can see
the new page working in the web browser!

-}
fromString : String -> View msg
fromString moduleName =
    { title = moduleName
    , body = [ Html.text moduleName ]
    }

================
File: frontend/static/medicare_school_com_logo.svg
================
<svg width="159" height="33" viewBox="0 0 159 33" fill="none" xmlns="http://www.w3.org/2000/svg">
<path d="M23.0137 13.4681H23.0395L25.6723 20.8983H27.3191L29.9571 13.4269H29.9829V20.8983H31.8465V10.6941H29.2653L26.5499 18.5728H26.5241L23.8087 10.6941H21.1914V20.8983H23.0137V13.4681Z" fill="#4B4039"/>
<path d="M36.7972 21.0427C37.3422 21.0747 37.8873 20.9811 38.3903 20.7692C38.8934 20.5573 39.3409 20.2328 39.6984 19.8206L38.5524 18.7894C38.3583 19.0617 38.101 19.2828 37.8024 19.4337C37.5039 19.5846 37.1731 19.6607 36.8385 19.6556C35.6511 19.6556 35.0678 18.975 34.9336 17.887H39.8946C39.9365 17.6228 39.9555 17.3554 39.9514 17.0878C39.9514 15.1233 38.8311 13.5919 36.6113 13.5919C34.3915 13.5919 33.101 15.1645 33.101 17.3147C33.101 19.4648 34.376 21.0427 36.7972 21.0427ZM36.5959 14.9841C37.6283 14.9841 38.0878 15.6853 38.1446 16.6959H34.9336C35.042 15.675 35.5582 14.9841 36.5959 14.9841Z" fill="#4B4039"/>
<path d="M46.2597 19.8206L46.301 20.8983H48.0097V10.6941H46.2184V14.6902C45.9642 14.3499 45.6328 14.0747 45.2513 13.8874C44.8699 13.7 44.4494 13.6058 44.0244 13.6125C42.1091 13.6125 40.896 15.2625 40.896 17.3869C40.896 19.4494 42.042 21.0427 43.9573 21.0427C44.4117 21.0418 44.859 20.9301 45.2603 20.7171C45.6616 20.5041 46.0047 20.1963 46.2597 19.8206ZM44.4477 19.635C43.25 19.635 42.6925 18.547 42.6925 17.3508C42.6925 16.1545 43.2655 15.0253 44.4787 15.0253C45.6918 15.0253 46.27 15.938 46.27 17.3198C46.27 18.7017 45.635 19.635 44.4477 19.635Z" fill="#4B4039"/>
<path d="M51.6234 10.6941H49.7495V12.3286H51.6234V10.6941Z" fill="#4B4039"/>
<path d="M51.5821 13.762H49.7856V20.8983H51.5821V13.762Z" fill="#4B4039"/>
<path d="M56.6308 21.0427C57.261 21.0851 57.8898 20.9427 58.44 20.6331C58.9903 20.3235 59.438 19.8601 59.7283 19.2998L58.3602 18.5625C58.2294 18.892 58.0013 19.1741 57.7063 19.3711C57.4112 19.5682 57.0632 19.671 56.7083 19.6659C55.4435 19.6659 54.8447 18.6347 54.8447 17.3405C54.8447 16.0462 55.459 14.9995 56.6567 14.9995C57.0054 14.9999 57.3456 15.1075 57.6309 15.3077C57.9163 15.5078 58.1331 15.7909 58.2518 16.1184L59.6611 15.3605C59.3818 14.806 58.9459 14.3454 58.4074 14.0357C57.8688 13.726 57.2512 13.5806 56.6308 13.6177C54.3026 13.6177 53.0172 15.2419 53.0172 17.3662C53.0172 19.4906 54.3284 21.0427 56.6308 21.0427Z" fill="#4B4039"/>
<path d="M66.6767 16.1236C66.6767 14.5767 65.6133 13.6125 63.6826 13.6125C62.232 13.6125 61.2614 14.1745 60.7813 15.2625L62.1648 15.938C62.2682 15.6447 62.4651 15.3936 62.7253 15.2231C62.9856 15.0526 63.2947 14.9722 63.6051 14.9944C63.7663 14.9722 63.9304 14.9849 64.0862 15.0316C64.242 15.0782 64.386 15.1578 64.5084 15.2649C64.6308 15.3719 64.7287 15.504 64.7955 15.6522C64.8623 15.8003 64.8965 15.9611 64.8957 16.1236V16.6392C63.8898 16.6261 62.8865 16.7457 61.9119 16.995C61.5079 17.1049 61.1535 17.3494 60.9076 17.6879C60.6616 18.0264 60.5388 18.4387 60.5594 18.8564C60.5513 19.1518 60.6054 19.4457 60.7181 19.7189C60.8308 19.9922 60.9997 20.2388 61.2137 20.4429C61.4277 20.647 61.6822 20.804 61.9608 20.9037C62.2393 21.0035 62.5357 21.0438 62.8308 21.022C63.2521 21.0413 63.6705 20.9436 64.0396 20.7397C64.4087 20.5358 64.714 20.2337 64.9215 19.867L64.9628 20.8983H66.6509L66.6767 16.1236ZM64.8957 18.1861C64.9043 18.3853 64.8717 18.5841 64.8001 18.7701C64.7285 18.9562 64.6194 19.1256 64.4795 19.2678C64.3395 19.4099 64.1719 19.5219 63.9868 19.5966C63.8018 19.6713 63.6033 19.7072 63.4038 19.702C62.7275 19.702 62.3404 19.3153 62.3404 18.7945C62.3404 18.2737 62.8205 18.0108 63.3728 17.9334C63.8529 17.8664 64.4518 17.8252 64.8802 17.7994L64.8957 18.1861Z" fill="#4B4039"/>
<path d="M70.0839 16.8042C70.0822 16.5834 70.1269 16.3646 70.2152 16.1621C70.3034 15.9597 70.4333 15.7779 70.5963 15.6287C70.7593 15.4795 70.9519 15.3661 71.1615 15.296C71.3711 15.2258 71.5932 15.2003 71.8133 15.2213C72.043 15.2208 72.2718 15.2485 72.4947 15.3038V13.7569C72.287 13.6773 72.0668 13.6354 71.8443 13.6331C71.4573 13.6526 71.0836 13.7804 70.7659 14.002C70.4483 14.2236 70.1994 14.5299 70.0478 14.8861H70.022L69.9807 13.7827H68.2926V20.8983H70.0839V16.8042Z" fill="#4B4039"/>
<path d="M76.5833 21.0427C77.1311 21.0787 77.6797 20.987 78.1859 20.775C78.6921 20.5629 79.142 20.2362 79.5001 19.8206L78.3592 18.7894C78.1646 19.0624 77.9064 19.2839 77.6069 19.4349C77.3074 19.5858 76.9756 19.6616 76.6401 19.6556C75.4579 19.6556 74.8746 18.975 74.7404 17.887H79.7014C79.7414 17.6226 79.7586 17.3552 79.753 17.0878C79.753 15.1233 78.6379 13.5919 76.4181 13.5919C74.1983 13.5919 72.9026 15.1645 72.9026 17.3147C72.9026 19.4648 74.1622 21.0427 76.5833 21.0427ZM76.4027 14.9841C77.4351 14.9841 77.8946 15.6853 77.9514 16.6959H74.7197C74.823 15.675 75.3702 14.9841 76.4027 14.9841Z" fill="#4B4039"/>
<path d="M86.7273 14.8036C85.225 14.4272 84.3733 14.2312 84.3733 13.298C84.3733 12.5297 84.9824 11.947 86.2214 11.947C86.7243 11.9447 87.2223 12.0461 87.6842 12.2448C88.1461 12.4436 88.562 12.7354 88.9058 13.102L89.9383 11.8645C89.446 11.3873 88.8618 11.0151 88.2211 10.7704C87.5803 10.5258 86.8965 10.4138 86.211 10.4414C83.7899 10.4414 82.4322 11.7202 82.4322 13.4836C82.4322 15.4636 84.0842 16.0617 85.7877 16.4639C87.3364 16.8197 88.2089 17.0723 88.2089 18.0108C88.2089 18.9492 87.5687 19.4339 86.1439 19.4339C85.5955 19.4397 85.0518 19.3329 84.5465 19.12C84.0412 18.9071 83.5851 18.5927 83.2066 18.1964L82.0812 19.4236C82.6172 19.9408 83.254 20.3424 83.9521 20.6032C84.6502 20.864 85.3945 20.9785 86.1388 20.9395C88.689 20.9395 90.0983 19.6659 90.0983 17.8458C90.1034 15.8091 88.498 15.2522 86.7273 14.8036Z" fill="#4B4039"/>
<path d="M94.6205 19.5577C93.3557 19.5577 92.7569 18.5264 92.7569 17.2322C92.7569 15.938 93.3712 14.8964 94.5637 14.8964C94.9127 14.8953 95.2535 15.0017 95.5399 15.2009C95.8262 15.4002 96.0441 15.6828 96.164 16.0102L97.5682 15.2522C97.2877 14.6978 96.8507 14.2378 96.3112 13.9289C95.7717 13.6201 95.1533 13.476 94.5327 13.5145C92.2045 13.5145 90.9191 15.1336 90.9191 17.258C90.9191 19.3823 92.22 20.9395 94.5327 20.9395C95.1625 20.9838 95.7915 20.8428 96.3419 20.534C96.8924 20.2251 97.3402 19.7621 97.6301 19.2019L96.2724 18.4542C96.1428 18.7846 95.915 19.0675 95.6197 19.2647C95.3244 19.462 94.9757 19.5642 94.6205 19.5577Z" fill="#4B4039"/>
<path d="M102.731 13.5145C102.306 13.4974 101.884 13.5911 101.506 13.7864C101.129 13.9817 100.809 14.2719 100.578 14.6283V10.5909H98.7814V20.7952H100.578V16.5C100.564 16.2918 100.594 16.083 100.666 15.8873C100.739 15.6916 100.852 15.5134 100.998 15.3644C101.144 15.2154 101.321 15.0989 101.515 15.0227C101.709 14.9465 101.918 14.9123 102.127 14.9222C102.3 14.9118 102.474 14.939 102.636 15.002C102.799 15.065 102.945 15.1623 103.066 15.2871C103.188 15.412 103.28 15.5615 103.338 15.7255C103.396 15.8894 103.418 16.0639 103.402 16.237V20.7952H105.198V15.9431C105.219 15.6156 105.169 15.2875 105.052 14.9809C104.935 14.6743 104.754 14.3964 104.52 14.1661C104.285 13.9358 104.005 13.7584 103.696 13.646C103.387 13.5336 103.058 13.4887 102.731 13.5145Z" fill="#4B4039"/>
<path d="M109.958 13.5145C107.588 13.5145 106.287 15.1078 106.287 17.2322C106.287 19.3566 107.573 20.9395 109.958 20.9395C112.343 20.9395 113.628 19.3462 113.628 17.2322C113.628 15.1181 112.332 13.5145 109.958 13.5145ZM109.958 19.5577C108.719 19.5577 108.11 18.5264 108.11 17.2322C108.11 15.938 108.719 14.8964 109.958 14.8964C111.197 14.8964 111.806 15.9019 111.806 17.2322C111.806 18.5625 111.186 19.5577 109.958 19.5577Z" fill="#4B4039"/>
<path d="M118.31 13.5145C115.941 13.5145 114.64 15.1078 114.64 17.2322C114.64 19.3566 115.931 20.9395 118.31 20.9395C120.69 20.9395 121.981 19.3462 121.981 17.2322C121.981 15.1181 120.69 13.5145 118.31 13.5145ZM118.31 19.5577C117.071 19.5577 116.462 18.5264 116.462 17.2322C116.462 15.938 117.071 14.8964 118.31 14.8964C119.549 14.8964 120.159 15.9019 120.159 17.2322C120.159 18.5625 119.544 19.5577 118.31 19.5577Z" fill="#4B4039"/>
<path d="M125.006 10.5909H123.21V20.7952H125.006V10.5909Z" fill="#4B4039"/>
<path d="M128.893 19.7175H127.778V20.8313H128.893V19.7175Z" fill="#4B4039"/>
<path d="M136.198 18.9595C136.018 19.3454 135.731 19.6711 135.37 19.8971C135.009 20.1232 134.59 20.2399 134.164 20.2331C132.724 20.2331 131.753 19.073 131.753 17.3405C131.753 15.608 132.719 14.4633 134.148 14.4633C134.576 14.4599 134.996 14.5816 135.356 14.8134C135.715 15.0452 135.999 15.3769 136.172 15.7678V15.8039L136.895 15.4069V15.3708C136.644 14.8617 136.251 14.4355 135.764 14.1429C135.277 13.8504 134.716 13.7038 134.148 13.7208C132.238 13.7208 130.907 15.2161 130.907 17.3302C130.907 19.4442 132.238 20.9395 134.148 20.9395C134.716 20.9588 135.278 20.8157 135.767 20.5271C136.257 20.2384 136.653 19.8162 136.91 19.3102V19.2792L136.203 18.8822L136.198 18.9595Z" fill="#4B4039"/>
<path d="M141.257 13.7208C139.29 13.7208 137.917 15.2109 137.917 17.3302C137.917 19.4494 139.254 20.9705 141.247 20.9705C143.239 20.9705 144.592 19.4752 144.592 17.3302C144.592 15.1852 143.219 13.7208 141.257 13.7208ZM141.257 20.2331C140.018 20.2331 138.774 19.3463 138.774 17.3559C138.774 15.3656 140.028 14.4633 141.267 14.4633C142.506 14.4633 143.75 15.3553 143.75 17.3559C143.75 19.3566 142.48 20.2331 141.247 20.2331H141.257Z" fill="#4B4039"/>
<path d="M153.59 13.7208C153.112 13.7094 152.642 13.8344 152.233 14.081C151.824 14.3276 151.494 14.6856 151.282 15.113C151.124 14.6858 150.834 14.3202 150.453 14.0697C150.072 13.8192 149.621 13.697 149.166 13.7208C148.722 13.7024 148.282 13.808 147.896 14.0257C147.509 14.2434 147.191 14.5646 146.977 14.9531V13.8445H146.146V20.8364H146.992V16.6598C146.992 15.3656 147.808 14.4633 148.975 14.4633C150.007 14.4633 150.606 15.1233 150.606 16.2267V20.8364H151.458V16.6598C151.458 15.3656 152.273 14.4633 153.44 14.4633C154.473 14.4633 155.071 15.1233 155.071 16.2267V20.8364H155.903V16.0308C155.92 15.7229 155.872 15.4149 155.762 15.1269C155.651 14.8388 155.482 14.5773 155.263 14.3592C155.045 14.1412 154.783 13.9716 154.495 13.8616C154.206 13.7516 153.898 13.7036 153.59 13.7208Z" fill="#4B4039"/>
<path d="M14.7178 1.65H1.48157V22.1719C1.48157 22.275 1.48157 22.5277 1.48157 23.1722V24.9408V25.4822L2.51403 26.5134L5.57014 23.4609L8.07387 25.9566L10.5208 23.497L11.3571 24.3736C11.6514 24.683 11.9353 24.9769 12.1883 25.2192L8.0842 29.3906L5.9315 27.2611L4.58413 28.6172L8.11517 32.1544L14.7333 25.2141L14.7178 1.65ZM12.8387 8.68313V23.2031L10.4744 20.8312L8.03257 23.3166L5.64241 20.8312L3.36582 23.0227V8.68313H12.8387ZM12.8387 3.52687V6.80625H3.36582V3.52687H12.8387Z" fill="#00B49F"/>
</svg>

================
File: frontend/.gitignore
================
/dist
/.elm-land
/.env
/elm-stuff
/node_modules
.DS_Store
*.pem

================
File: frontend/elm-land.json
================
{
  "app": {
    "elm": {
      "development": { "debugger": true },
      "production": { "debugger": false }
    },
    "env": ["OAUTH_GOOGLE_LOGIN_URL"],
    "html": {
      "attributes": {
        "html": { "lang": "en" },
        "head": {}
      },
      "title": "Maxquote",
      "meta": [
        { "charset": "UTF-8" },
        { "http-equiv": "X-UA-Compatible", "content": "IE=edge" },
        {
          "name": "viewport",
          "content": "width=device-width, initial-scale=1.0"
        }
      ],
      "link": [
        {
          "rel": "icon",
          "href": "https://medicareschool.com/wp-content/uploads/2024/02/cropped-favicon-32x32.png",
          "sizes": "32x32"
        },
        {
          "rel": "icon",
          "href": "https://medicareschool.com/wp-content/uploads/2024/02/cropped-favicon-192x192.png",
          "sizes": "192x192"
        },
        {
          "rel": "apple-touch-icon",
          "href": "https://medicareschool.com/wp-content/uploads/2024/02/cropped-favicon-180x180.png"
        },
        {
          "rel": "msapplication-TileImage",
          "href": "https://medicareschool.com/wp-content/uploads/2024/02/cropped-favicon-270x270.png"
        }
      ],
      "script": []
    },
    "router": {
      "useHashRouting": false
    },
    "proxy": {
      "/rpc": "http://localhost:8080"
    }
  }
}

================
File: frontend/elm.json
================
{
    "type": "application",
    "source-directories": [
        "src",
        ".elm-land/src"
    ],
    "elm-version": "0.19.1",
    "dependencies": {
        "direct": {
            "billstclair/elm-sortable-table": "1.2.1",
            "elm/browser": "1.0.2",
            "elm/core": "1.0.5",
            "elm/html": "1.0.0",
            "elm/http": "2.0.0",
            "elm/json": "1.1.3",
            "elm/regex": "1.0.0",
            "elm/svg": "1.0.1",
            "elm/time": "1.0.0",
            "elm/url": "1.0.0",
            "jinjor/elm-debounce": "3.0.0",
            "justinmimbs/date": "4.1.0",
            "krisajenkins/remotedata": "6.0.1",
            "rtfeldman/elm-iso8601-date-strings": "1.1.4",
            "turboMaCk/any-dict": "3.0.0",
            "turboMaCk/any-set": "1.6.1"
        },
        "indirect": {
            "elm/bytes": "1.0.8",
            "elm/file": "1.0.5",
            "elm/parser": "1.1.0",
            "elm/virtual-dom": "1.0.3"
        }
    },
    "test-dependencies": {
        "direct": {},
        "indirect": {}
    }
}

================
File: frontend/package.json
================
{
  "name": "frontend",
  "version": "1.0.0",
  "description": "> Built with [Elm Land](https://elm.land) 🌈",
  "main": "index.html",
  "scripts": {
    "server": "elm-land server",
    "build": "elm-land build"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@tailwindcss/forms": "^0.5.9",
    "autoprefixer": "^10.4.20",
    "elm": "^0.19.1-6",
    "elm-format": "^0.8.7",
    "elm-land": "^0.20.1",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.13"
  }
}

================
File: frontend/postcss.config.js
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
};

================
File: frontend/README.md
================
# frontend
> Built with [Elm Land](https://elm.land) 🌈

## Local development

```bash
# Requires Node.js v18+ (https://nodejs.org)
npx elm-land server
```

## Deploying to production

Elm Land projects are most commonly deployed as static websites.

Please visit [the "Deployment" guide](https://elm.land/guide/deploying) to learn more
about deploying your app for free using Netlify or Vercel.

================
File: frontend/tailwind.config.js
================
const defaultTheme = require("tailwindcss/defaultTheme");
const colors = require("tailwindcss/colors");

module.exports = {
  content: ["./src/**/*.{js,elm,css}"],
  theme: {
    colors: {
      transparent: "transparent",
      current: "currentColor",
      white: colors.white,
      black: colors.black,
      gray: colors.neutral,
      blue: colors.blue,
      red: colors.red,
    },
    extend: {
      fontFamily: {
        sans: ["InterVariable", ...defaultTheme.fontFamily.sans],
      },
      gridTemplateColumns: {
        supquote: "repeat(auto-fill, minmax(300px, 1fr))",
      },
    },
  },
  plugins: [
    require("@tailwindcss/forms")({
      strategy: "base", // only generate global styles
    }),
  ],
};

================
File: internal/config/config.go
================
package config

import (
	"errors"
	"flag"
	"fmt"
	"os"

	"github.com/peterbourgon/ff/v3"
)

// Config contains configuation data obtained from flag argements or environment variables
// at startup.
type Config struct {
	BaseURL     string
	Database    string
	Development bool
	Port        int
	Cookie      struct {
		Name     string
		Domain   string
		HTTPOnly bool
		Path     string
		Persist  bool
		SameSite int
		Secure   bool
	}
	OAuth struct {
		ClientID     string
		ClientSecret string
		RedirectURL  string
	}
	Sendgrid struct {
		FromName         string
		FromEmailAddress string
		APIKey           string
	}
	Twilio struct {
		Username        string
		Password        string
		FromPhoneNumber string
	}
	CSGCache struct {
		APIKey  string
		BaseURL string
	}
	Storage struct {
		StaticBaseURL string
	}
}

// Parse returns configuration data parsed from flag arguments or environment variables.
func Parse(serviceName string) (*Config, error) {
	var c Config

	fs := flag.NewFlagSet(serviceName, flag.ExitOnError)
	fs.StringVar(&c.BaseURL, "base-url", "", "The application base url.")
	fs.StringVar(&c.Database, "database", "", "The postgres database connection string.")
	fs.BoolVar(&c.Development, "development", false, "Enable development mode.")
	fs.IntVar(&c.Port, "port", 8080, "Specifies the TCP port on which to listen.")
	fs.StringVar(&c.Cookie.Name, "cookie-name", "session", "The session cookie name.")
	fs.StringVar(&c.Cookie.Domain, "cookie-domain", "", "The session cookie domain.")
	fs.BoolVar(&c.Cookie.HTTPOnly, "cookie-http-only", true, "The session cookie http only value.")
	fs.StringVar(&c.Cookie.Path, "cookie-path", "/", "The session cookie path.")
	fs.IntVar(&c.Cookie.SameSite, "cookie-same-site", 2, "The session cookie same site value. Valid values are 1 (Default), 2 (Lax), 3 (Strict), 4 (None)")
	fs.BoolVar(&c.Cookie.Secure, "cookie-secure", true, "Enable secure session cookie.")
	fs.StringVar(&c.OAuth.ClientID, "oauth-client-id", "", "The oauth client id for google signin.")
	fs.StringVar(&c.OAuth.ClientSecret, "oauth-client-secret", "", "The oauth client secret for google signin.")
	fs.StringVar(&c.OAuth.RedirectURL, "oauth-redirect-url", "", "The oauth redirect url for google signin.")
	fs.StringVar(&c.Sendgrid.FromName, "sendgrid-from-name", "", "The from name of notifiction emails.")
	fs.StringVar(&c.Sendgrid.FromEmailAddress, "sendgrid-from-email-address", "", "The reply address of notification emails.")
	fs.StringVar(&c.Sendgrid.APIKey, "sendgrid-api-key", "", "The sendgrid api key.")
	fs.StringVar(&c.Twilio.Username, "twilio-username", "", "The twilio username.")
	fs.StringVar(&c.Twilio.Password, "twilio-password", "", "The twilio password.")
	fs.StringVar(&c.Twilio.FromPhoneNumber, "twilio-from-phone-number", "", "The from phone number of sms messages.")
	fs.StringVar(&c.CSGCache.APIKey, "csg-cache-api-key", "", "The csg caching app api key.")
	fs.StringVar(&c.CSGCache.BaseURL, "csg-cache-base-url", "", "The csg caching app base url.")
	fs.StringVar(&c.Storage.StaticBaseURL, "storage-static-base-url", "", "The base url of the objects in static storage")

	_ = fs.String("config", "", "")

	err := ff.Parse(fs, os.Args[1:],
		ff.WithEnvVarNoPrefix(),
		ff.WithConfigFileFlag("config"),
		ff.WithConfigFileParser(ff.PlainParser),
	)
	if err != nil {
		return nil, fmt.Errorf("failed to parse configuration: %w", err)
	}

	if err := validateConfig(c); err != nil {
		return nil, err
	}

	return &c, nil
}

func validateConfig(c Config) error {
	if len(c.BaseURL) == 0 {
		return errors.New("base-url required")
	}

	if len(c.Database) == 0 {
		return errors.New("database required")
	}

	if c.Cookie.SameSite < 1 || c.Cookie.SameSite > 4 {
		return errors.New("cookie-same-site invalid")
	}

	if len(c.OAuth.ClientID) == 0 {
		return errors.New("oauth-client-id required")
	}

	if len(c.OAuth.ClientSecret) == 0 {
		return errors.New("oauth-client-secret required")
	}

	if len(c.OAuth.RedirectURL) == 0 {
		return errors.New("oauth-redirect-url required")
	}

	if len(c.Sendgrid.FromName) == 0 {
		return errors.New("sendgrid-from-name required")
	}

	if len(c.Sendgrid.FromEmailAddress) == 0 {
		return errors.New("sendgrid-from-email-address required")
	}

	if len(c.Sendgrid.APIKey) == 0 {
		return errors.New("sendgrid-api-key required")
	}

	if len(c.Twilio.Username) == 0 {
		return errors.New("twilio-username required")
	}

	if len(c.Twilio.Password) == 0 {
		return errors.New("twilio-password")
	}

	if len(c.Twilio.FromPhoneNumber) == 0 {
		return errors.New("twilio-from-phone-number")
	}

	if len(c.CSGCache.APIKey) == 0 {
		return errors.New("csg-cache-api-key")
	}

	if len(c.CSGCache.BaseURL) == 0 {
		return errors.New("csg-cache-base-url")
	}

	if len(c.Storage.StaticBaseURL) == 0 {
		return errors.New("storage-static-base-url")
	}

	return nil
}

================
File: internal/domain/agent/agent.go
================
package agent

import (
	"time"

	"github.com/medicareschoolcom/maxquote/internal/domain/common"
)

// ID of an Agent
type ID int64

// Agent
type Agent struct {
	ID        ID
	Name      common.PersonName
	Email     common.Email
	Phone     common.Phone
	PhoneExt  *common.PhoneExt
	CreatedAt time.Time
	UpdatedAt time.Time
}

================
File: internal/domain/agent/store_test.go
================
package agent

import (
	"context"
	"path/filepath"
	"testing"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

func TestStore(t *testing.T) {
	ctx := context.Background()

	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:16-alpine"),
		postgres.WithInitScripts(
			filepath.Join("..", "..", "..", "db", "migrations", "20241006213447_baseline.up.sql"),
			filepath.Join("testdata", "fixture.sql"),
		),
		postgres.WithDatabase("test-db"),
		postgres.WithUsername("postgres"),
		postgres.WithPassword("postgres"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).WithStartupTimeout(5*time.Minute)),
	)
	if err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() {
		if err := pgContainer.Terminate(ctx); err != nil {
			t.Fatalf("failed to terminate pgContainer: %s", err)
		}
	})

	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		t.Fatalf("failed to get postgres connection string: %s", err)
	}

	db, err := pgx.Connect(ctx, connStr)
	if err != nil {
		t.Fatalf("failed to connect to postgres: %s", err)
	}

	t.Run("Get", func(t *testing.T) {
		tt := []struct {
			name    string
			agentID ID
			err     error
		}{
			{
				name:    "agent found",
				agentID: 4,
				err:     nil,
			},
			{
				name:    "agent not found",
				agentID: 999,
				err:     ErrAgentNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())
				_, err = store.Get(ctx, tx, tc.agentID)
				if err != tc.err {
					t.Fatalf("expected error: %s, got: %s", tc.err, err)
				}
			})
		}
	})

	t.Run("GetByEmail", func(t *testing.T) {
		tt := []struct {
			name  string
			email common.Email
			err   error
		}{
			{
				name:  "agent found",
				email: "aaron.butler@medicareschool.com",
				err:   nil,
			},
			{
				name:  "agent not found",
				email: "jimmy.nobody@medicareschool.com",
				err:   ErrAgentNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())
				_, err = store.GetByEmail(ctx, tx, tc.email)
				if err != tc.err {
					t.Fatalf("expected error: %s, got: %s", tc.err, err)
				}
			})
		}
	})
}

================
File: internal/domain/agent/store.go
================
package agent

import (
	"context"
	"errors"

	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	sql "github.com/medicareschoolcom/maxquote/internal/sqlc"
)

var ErrAgentNotFound = errors.New("agent not found")

// Store provides a interface for persisting and fetching an Agent
// from a storage mechanism
type Store interface {
	Get(context.Context, common.DB, ID) (*Agent, error)
	GetByEmail(context.Context, common.DB, common.Email) (*Agent, error)
}

type PGStore struct {
	querier sql.Querier
}

func NewPGStore(querier sql.Querier) *PGStore {
	return &PGStore{querier: querier}
}

var _ Store = new(PGStore)

func (s *PGStore) Get(ctx context.Context, db common.DB, id ID) (*Agent, error) {
	row, err := s.querier.GetAgent(ctx, db, int64(id))
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrAgentNotFound
	}
	if err != nil {
		return nil, err
	}

	return s.mapRowToAgent(row), nil
}

func (s *PGStore) GetByEmail(ctx context.Context, db common.DB, email common.Email) (*Agent, error) {
	row, err := s.querier.GetAgentByEmail(ctx, db, string(email))
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrAgentNotFound
	}
	if err != nil {
		return nil, err
	}

	return s.mapRowToAgent(row), nil
}

func (s *PGStore) mapRowToAgent(row *sql.Agent) *Agent {
	var a Agent
	a.ID = ID(row.ID)
	a.Name = common.PersonName{
		First: row.FirstName,
		Last:  row.LastName,
	}
	a.Email = common.Email(row.Email)
	a.Phone = common.Phone(row.Phone)
	if row.PhoneExt.Valid {
		phoneExt := common.PhoneExt(row.PhoneExt.Int32)
		a.PhoneExt = &phoneExt
	}
	a.CreatedAt = row.CreatedAt.Time
	a.UpdatedAt = row.UpdatedAt.Time
	return &a
}

================
File: internal/domain/client/client.go
================
package client

import (
	"time"

	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
)

type ID int64

type Client struct {
	ID             ID
	Name           common.PersonName
	DateOfBirth    common.Date
	Gender         common.Gender
	ZipCode        geo.ZipCode
	CountyFIPSCode geo.CountyFIPSCode
	Phone          *common.Phone
	Email          *common.Email
	IsTobaccoUser  bool
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

================
File: internal/domain/client/store_test.go
================
package client

import (
	"context"
	"path/filepath"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

func TestStore(t *testing.T) {
	ctx := context.Background()

	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:16-alpine"),
		postgres.WithInitScripts(
			filepath.Join("..", "..", "..", "db", "migrations", "20241006213447_baseline.up.sql"),
			filepath.Join("testdata", "fixture.sql"),
		),
		postgres.WithDatabase("test-db"),
		postgres.WithUsername("postgres"),
		postgres.WithPassword("postgres"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).WithStartupTimeout(5*time.Minute)),
	)
	if err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() {
		if err := pgContainer.Terminate(ctx); err != nil {
			t.Fatalf("failed to terminate pgContainer: %s", err)
		}
	})

	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		t.Fatalf("failed to get postgres connection string: %s", err)
	}

	db, err := pgx.Connect(ctx, connStr)
	if err != nil {
		t.Fatalf("failed to connect to postgres: %s", err)
	}
	defer db.Close(ctx)

	t.Run("NextID", func(t *testing.T) {
		tx, err := db.Begin(ctx)
		if err != nil {
			t.Fatalf("failed to begin transaction: %s", err)
		}
		defer tx.Rollback(ctx)

		store := NewPGStore(sqlc.New())

		id1, err := store.NextID(ctx, tx)
		if err != nil {
			t.Fatalf("failed store.NextID: %s", err)
		}

		expectedID1 := ID(5)
		if id1 != expectedID1 {
			t.Fatalf("id expected: %d, got: %d", expectedID1, id1)
		}

		id2, err := store.NextID(ctx, tx)
		if err != nil {
			t.Fatalf("failed store.NextID: %s", err)
		}

		expectedID2 := ID(6)
		if id2 != expectedID2 {
			t.Fatalf("id expected: %d, got: %d", expectedID2, id2)
		}
	})

	t.Run("ListByIDS", func(t *testing.T) {
		tt := []struct {
			name    string
			ids     []ID
			wantNum int
		}{
			{
				name:    "Find client by first name",
				ids:     []ID{1, 2, 3, 4},
				wantNum: 4,
			},
		}

		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())

				clients, err := store.ListByIDS(ctx, db, tc.ids)
				if err != nil {
					t.Fatal(err)
				}

				gotNum := len(clients)

				if gotNum != tc.wantNum {
					t.Fatalf("num of clients expected: %d, got: %d", tc.wantNum, gotNum)
				}
			})
		}
	})

	t.Run("Search", func(t *testing.T) {
		tt := []struct {
			name       string
			searchTerm string
			expected   []ID
		}{
			{
				name:       "Find client by first name",
				searchTerm: "jonathan",
				expected:   []ID{1},
			},
			{
				name:       "Find client by last name",
				searchTerm: "seb",
				expected:   []ID{1},
			},
			{
				name:       "Find client by full name",
				searchTerm: "Jonathan Sebastian",
				expected:   []ID{1},
			},
			{
				name:       "Find client by email suffix",
				searchTerm: "gmail",
				expected:   []ID{3, 1},
			},
			{
				name:       "Find by name and email",
				searchTerm: "bob",
				expected:   []ID{4, 2},
			},
			{
				name:       "Find nothing",
				searchTerm: "moon",
				expected:   []ID{},
			},
			{
				name:       "Handle blank search term",
				searchTerm: "",
				expected:   []ID{},
			},
		}

		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())

				clients, err := store.Search(ctx, db, tc.searchTerm, 8)
				if err != nil {
					t.Fatal(err)
				}

				clientIDS := make([]ID, len(clients))
				for i, client := range clients {
					clientIDS[i] = client.ID
				}

				if !cmp.Equal(tc.expected, clientIDS) {
					t.Errorf("client ids expected: %v, got: %v", tc.expected, clientIDS)
				}
			})
		}
	})

	t.Run("Get", func(t *testing.T) {
		tt := []struct {
			name     string
			clientID ID
			err      error
		}{
			{
				name:     "client found",
				clientID: 2,
				err:      nil,
			},
			{
				name:     "client not found",
				clientID: 999,
				err:      ErrClientNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())
				_, err = store.Get(ctx, tx, tc.clientID)
				if err != tc.err {
					t.Fatalf("expected error: %s, got: %s", tc.err, err)
				}
			})
		}
	})

	t.Run("GetByEmail", func(t *testing.T) {
		tt := []struct {
			name  string
			email common.Email
			err   error
		}{
			{
				name:  "client found",
				email: "jonathan.sebastian@gmail.com",
				err:   nil,
			},
			{
				name:  "client not found",
				email: "nobody@example.com",
				err:   ErrClientNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())
				_, err = store.GetByEmail(ctx, tx, tc.email)
				if err != tc.err {
					t.Fatalf("expected error: %s, got: %s", tc.err, err)
				}
			})
		}
	})

	t.Run("Store/Insert", func(t *testing.T) {
		tx, err := db.Begin(ctx)
		if err != nil {
			t.Fatalf("failed to begin transaction: %s", err)
		}
		defer tx.Rollback(ctx)

		phone := common.Phone("123-456-7890")
		email := common.Email("jimmy.humphrey@example.com")

		client := &Client{
			ID:             ID(4),
			Name:           common.PersonName{First: "Jimmy", Last: "Humphrey"},
			DateOfBirth:    common.NewDate(time.Unix(1, 0)),
			Gender:         common.GenderMale,
			ZipCode:        "36576",
			CountyFIPSCode: "01003",
			Phone:          &phone,
			Email:          &email,
			IsTobaccoUser:  false,
			CreatedAt:      time.Now(),
			UpdatedAt:      time.Now(),
		}
		if err != nil {
			t.Fatalf("failed to insert client: %s", err)
		}

		err = NewPGStore(sqlc.New()).Store(ctx, tx, client)
		if err != nil {
			t.Fatalf("failed store.Store: %s", err)
		}
	})

	t.Run("Store/Update", func(t *testing.T) {
		tx, err := db.Begin(ctx)
		if err != nil {
			t.Fatalf("failed to begin transaction: %s", err)
		}
		defer tx.Rollback(ctx)

		store := NewPGStore(sqlc.New())

		client, err := store.Get(ctx, tx, ID(4))
		if err != nil {
			t.Fatalf("failed store.Get: %s", err)
		}

		err = store.Store(ctx, tx, client)
		if err != nil {
			t.Fatalf("failed store.Store: %s", err)
		}
	})
}

================
File: internal/domain/client/store.go
================
package client

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
	sql "github.com/medicareschoolcom/maxquote/internal/sqlc"
)

var ErrClientNotFound = errors.New("client not found")

type Store interface {
	NextID(context.Context, common.DB) (ID, error)
	ListByIDS(context.Context, common.DB, []ID) ([]*Client, error)
	Get(context.Context, common.DB, ID) (*Client, error)
	GetByEmail(context.Context, common.DB, common.Email) (*Client, error)
	Search(context.Context, common.DB, string, int32) ([]*Client, error)
	Store(context.Context, common.DB, *Client) error
}

type PGStore struct {
	querier sql.Querier
}

func NewPGStore(querier sql.Querier) *PGStore {
	return &PGStore{querier: querier}
}

var _ Store = new(PGStore)

func (s *PGStore) NextID(ctx context.Context, tx common.DB) (ID, error) {
	i, err := s.querier.GetNextClientID(ctx, tx)
	if err != nil {
		return ID(0), fmt.Errorf("failed sqlc.GetNextClientID: %w", err)
	}
	return ID(i), nil
}

func (s *PGStore) ListByIDS(ctx context.Context, tx common.DB, ids []ID) ([]*Client, error) {
	i64IDS := make([]int64, len(ids))
	for i, id := range ids {
		i64IDS[i] = int64(id)
	}

	rows, err := s.querier.ListClientsByIDS(ctx, tx, i64IDS)
	if err != nil {
		return nil, fmt.Errorf("failed ListClientsByIDS: %w", err)
	}

	clients := make([]*Client, len(rows))
	for i, row := range rows {
		clients[i] = s.mapClientToDomainClient(row)
	}

	return clients, nil
}

func (s *PGStore) Search(ctx context.Context, tx common.DB, searchTerm string, limit int32) ([]*Client, error) {
	if strings.TrimSpace(searchTerm) == "" {
		return []*Client{}, nil
	}

	rows, err := s.querier.SearchClients(ctx, tx, sql.SearchClientsParams{
		Column1: pgtype.Text{String: searchTerm, Valid: true},
		Limit:   limit,
	})
	if err != nil {
		return nil, fmt.Errorf("failed sqlc.SearchClients: %w", err)
	}

	clients := make([]*Client, len(rows))
	for i, row := range rows {
		clients[i] = s.mapClientToDomainClient(row)
	}
	return clients, nil
}

func (s *PGStore) Get(ctx context.Context, tx common.DB, id ID) (*Client, error) {
	row, err := s.querier.GetClient(ctx, tx, int64(id))
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrClientNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed sqlc.GetClient: %w", err)
	}

	client := s.mapClientToDomainClient(row)

	return client, nil
}

func (s *PGStore) GetByEmail(ctx context.Context, tx common.DB, email common.Email) (*Client, error) {
	row, err := s.querier.GetClientByEmail(ctx, tx, pgtype.Text{String: string(email), Valid: true})
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrClientNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed sqlc.GetClientByEmail: %w", err)
	}

	client := s.mapClientToDomainClient(row)

	return client, nil
}

func (s *PGStore) Store(ctx context.Context, tx common.DB, client *Client) error {
	var params sqlc.UpsertClientParams
	params.ID = int64(client.ID)
	params.FirstName = client.Name.First
	params.LastName = client.Name.Last
	params.DateOfBirth = pgtype.Date{Time: client.DateOfBirth.Time(), Valid: true}
	params.Gender = string(client.Gender)
	params.ZipCode = string(client.ZipCode)
	params.CountyFipsCode = string(client.CountyFIPSCode)
	if client.Phone != nil {
		params.Phone = pgtype.Text{String: string(*client.Phone), Valid: true}
	}
	if client.Email != nil {
		params.Email = pgtype.Text{String: string(*client.Email), Valid: true}
	}
	params.IsTobaccoUser = client.IsTobaccoUser
	params.CreatedAt = pgtype.Timestamptz{Time: client.CreatedAt, Valid: true}
	params.UpdatedAt = pgtype.Timestamptz{Time: client.UpdatedAt, Valid: true}
	return s.querier.UpsertClient(ctx, tx, params)
}

func (s *PGStore) mapClientToDomainClient(row *sql.Client) *Client {
	var c Client
	c.ID = ID(row.ID)
	c.Name = common.PersonName{
		First: row.FirstName,
		Last:  row.LastName,
	}
	c.DateOfBirth = common.NewDate(row.DateOfBirth.Time)
	c.Gender = common.Gender(row.Gender)
	c.ZipCode = geo.ZipCode(row.ZipCode)
	c.CountyFIPSCode = geo.CountyFIPSCode(row.CountyFipsCode)
	if row.Phone.Valid {
		c.Phone = (*common.Phone)(&row.Phone.String)
	}
	if row.Email.Valid {
		c.Email = (*common.Email)(&row.Email.String)
	}
	c.IsTobaccoUser = row.IsTobaccoUser
	c.CreatedAt = row.CreatedAt.Time
	c.UpdatedAt = row.UpdatedAt.Time
	return &c
}

================
File: internal/domain/common/clock.go
================
package common

import (
	"time"
)

type Clock interface {
	Now() time.Time
	Today() Date
}

type SystemClock struct{}

var _ Clock = SystemClock{}

func (c SystemClock) Now() time.Time {
	return time.Now()
}

func (c SystemClock) Today() Date {
	return NewDate(time.Now())
}

================
File: internal/domain/common/common_test.go
================
package common

import (
	"testing"
	"time"
)

func TestDate_YearsSince(t *testing.T) {
	tt := []struct {
		name      string
		startDate string
		endDate   string
		wantYears int
	}{
		{
			name:      "Years before anniversary",
			startDate: "1982-07-20",
			endDate:   "2025-03-07",
			wantYears: 42,
		},
		{
			name:      "Years on anniversary",
			startDate: "1982-07-20",
			endDate:   "2025-07-20",
			wantYears: 43,
		},
		{
			name:      "Years after anniversary",
			startDate: "1982-07-20",
			endDate:   "2025-10-07",
			wantYears: 43,
		},
	}

	for _, tc := range tt {
		t.Run(string(tc.name), func(t *testing.T) {

			startDate, err := ParseDate(tc.startDate)
			if err != nil {
				t.Fatal(err)
			}

			endDate, err := ParseDate(tc.endDate)
			if err != nil {
				t.Fatal(err)
			}

			years := endDate.YearsSince(startDate)

			if years != tc.wantYears {
				t.Fatalf("years expected: %d, want: %d", tc.wantYears, years)
			}
		})
	}
}

func TestDate_StartOfMonth(t *testing.T) {
	tt := []struct {
		startDate string
		wantDate  string
	}{
		{
			startDate: "2025-03-07",
			wantDate:  "2025-03-01",
		},
	}

	for _, tc := range tt {
		t.Run(string(tc.startDate), func(t *testing.T) {

			startDate, err := ParseDate(tc.startDate)
			if err != nil {
				t.Fatal(err)
			}

			wantDate, err := ParseDate(tc.wantDate)
			if err != nil {
				t.Fatal(err)
			}

			firstOfMonth := startDate.StartOfMonth()

			if !firstOfMonth.Equal(wantDate) {
				t.Fatalf("date expected: %s, got: %s", wantDate.String(), firstOfMonth.String())
			}
		})
	}
}

func TestDate_EndOfMonth(t *testing.T) {
	tt := []struct {
		startDate string
		wantDate  string
	}{
		{
			startDate: "2025-03-07",
			wantDate:  "2025-03-31",
		},
		{
			startDate: "2025-12-07",
			wantDate:  "2025-12-31",
		},
		{
			startDate: "2025-01-07",
			wantDate:  "2025-01-31",
		},
	}

	for _, tc := range tt {
		t.Run(string(tc.startDate), func(t *testing.T) {

			startDate, err := ParseDate(tc.startDate)
			if err != nil {
				t.Fatal(err)
			}

			wantDate, err := ParseDate(tc.wantDate)
			if err != nil {
				t.Fatal(err)
			}

			gotDate := startDate.EndOfMonth()

			if !gotDate.Equal(wantDate) {
				t.Fatalf("date expected: %s, got: %s", wantDate.String(), gotDate.String())
			}
		})
	}
}

func TestDate_FirstDayNextMonth(t *testing.T) {
	tt := []struct {
		startDate string
		wantDate  string
	}{
		{
			startDate: "2025-03-07",
			wantDate:  "2025-04-01",
		},
		{
			startDate: "2025-12-07",
			wantDate:  "2026-01-01",
		},
		{
			startDate: "2025-01-07",
			wantDate:  "2025-02-01",
		},
	}

	for _, tc := range tt {
		t.Run(string(tc.startDate), func(t *testing.T) {

			startDate, err := ParseDate(tc.startDate)
			if err != nil {
				t.Fatal(err)
			}

			wantDate, err := ParseDate(tc.wantDate)
			if err != nil {
				t.Fatal(err)
			}

			gotDate := startDate.FirstDayNextMonth()

			if !gotDate.Equal(wantDate) {
				t.Fatalf("date expected: %s, got: %s", wantDate.String(), gotDate.String())
			}
		})
	}
}

func TestPhone_NumericString(t *testing.T) {
	tt := []struct {
		number   Phone
		expected string
	}{
		{
			number:   "123-456-7890",
			expected: "1234567890",
		},
	}

	for _, tc := range tt {
		t.Run(string(tc.number), func(t *testing.T) {
			got := tc.number.NumericString()
			if got != tc.expected {
				t.Errorf("numeric string expected: %s, got: %s", tc.expected, got)
			}
		})
	}
}

func TestNewPersonName(t *testing.T) {
	tt := []struct {
		name  string
		first string
		last  string
		err   error
	}{
		{
			name:  "valid name",
			first: "John",
			last:  "Doe",
			err:   nil,
		},
		{
			name:  "invalid first name",
			first: "",
			last:  "Doe",
			err:   ErrPersonName,
		},
		{
			name:  "invalid last name",
			first: "John",
			last:  "",
			err:   ErrPersonName,
		},
	}
	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			_, err := NewPersonName(tc.first, tc.last)
			if err != tc.err {
				t.Fatalf("expected error: %s, got: %s", tc.err, err)
			}
		})
	}
}

func TestNewPhone(t *testing.T) {
	tt := []struct {
		name  string
		phone string
		err   error
	}{
		{
			name:  "phone must be groups of digits seperated by hyphens",
			phone: "123-456-7890",
			err:   nil,
		},
		{
			name:  "phone can by any length",
			phone: "456-7890",
			err:   nil,
		},
		{
			name:  "phone cannot start with hypen",
			phone: "-123-456-7890",
			err:   ErrPhone,
		},
		{
			name:  "phone cannot end with hypen",
			phone: "123-456-7890-",
			err:   ErrPhone,
		},
	}
	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			_, err := NewPhone(tc.phone)
			if err != tc.err {
				t.Fatalf("expected error: %s, got: %s", tc.err, err)
			}
		})
	}
}

func TestNewEmail(t *testing.T) {
	tt := []struct {
		name  string
		email string
		err   error
	}{
		{
			name:  "email must have a prefix and domain suffix separated by an @ symbol",
			email: "blah@blah.blah",
			err:   nil,
		},
		{
			name:  "email cannot have a missing prefix",
			email: "@blah.blah",
			err:   ErrEmail,
		},
		{
			name:  "email cannot have a missing domain suffix",
			email: "blah@blah",
			err:   ErrEmail,
		},
	}
	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			_, err := NewEmail(tc.email)
			if err != tc.err {
				t.Fatalf("expected error: %s, got: %s", tc.err, err)
			}
		})
	}
}

type testingClock struct {
	time time.Time
}

func (c testingClock) Now() time.Time {
	return c.time
}

================
File: internal/domain/common/common.go
================
package common

import (
	"context"
	"errors"
	"regexp"
	"strings"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

var (
	ErrPersonName  = errors.New("person name invalid")
	ErrPhone       = errors.New("phone invalid")
	ErrEmail       = errors.New("email invalid")
	ErrDateOfBirth = errors.New("date of birth invalid")
)

var (
	phonePattern = regexp.MustCompile(`^[0-9]+(?:-[0-9]+)*$`)
	emailPattern = regexp.MustCompile(`^[^@]+@[^@]+(:?\.[^@\.]{2,})+$`)
)

// DB is a database connection
type DB interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
	Begin(ctx context.Context) (pgx.Tx, error)
	CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error)
}

type Gender string

const (
	GenderMale   Gender = "Male"
	GenderFemale Gender = "Female"
)

type NAIC string

type Year int32

type Date struct {
	time time.Time
}

func ParseDate(v string) (Date, error) {
	t, err := time.Parse(time.DateOnly, v)
	if err != nil {
		return Date{}, err
	}
	return Date{time: t}, nil
}

func NewDate(t time.Time) Date {
	y, m, d := t.Date()
	return Date{time: time.Date(y, m, d, 0, 0, 0, 0, time.UTC)}
}

func (d Date) Year() int {
	return d.time.Year()
}

func (d Date) After(u Date) bool {
	return d.time.After(u.time)
}

func (d Date) Before(u Date) bool {
	return d.time.Before(u.time)
}

func (d Date) Equal(u Date) bool {
	return d.time.Equal(u.time)
}

func (d Date) YearsSince(u Date) int {
	startDate := u.time
	endDate := d.time

	if endDate.Before(startDate) {
		return 0
	}

	durationYears := endDate.Year() - startDate.Year()

	anniversary := startDate.AddDate(durationYears, 0, 0)
	if anniversary.After(endDate) {
		durationYears--
	}

	return durationYears
}

func (d Date) StartOfMonth() Date {
	year, month, _ := d.time.Date()
	firstDayOfMonth := time.Date(year, month, 1, 0, 0, 0, 0, time.UTC)
	return Date{time: firstDayOfMonth}
}

func (d Date) EndOfMonth() Date {
	year, month, _ := d.time.Date()
	if month == 12 {
		month = 1
		year = year + 1
	} else {
		month = month + 1
	}

	firstDayOfNextMonth := d.FirstDayNextMonth()
	negOneDay := time.Duration(24) * time.Hour * -1
	lastDayOfThisMonth := firstDayOfNextMonth.time.Add(negOneDay)

	return NewDate(lastDayOfThisMonth)
}

func (d Date) FirstDayNextMonth() Date {
	year, month, _ := d.time.Date()
	if month == 12 {
		month = 1
		year = year + 1
	} else {
		month = month + 1
	}

	return Date{time: time.Date(year, month, 1, 0, 0, 0, 0, time.UTC)}
}

func (d Date) String() string {
	return d.time.Format(time.DateOnly)
}

func (d Date) Time() time.Time {
	return d.time
}

type Age int32

type PersonName struct {
	First string
	Last  string
}

func NewPersonName(first, last string) (PersonName, error) {
	first = strings.TrimSpace(first)
	if len(first) == 0 {
		return PersonName{}, ErrPersonName
	}

	last = strings.TrimSpace(last)
	if len(last) == 0 {
		return PersonName{}, ErrPersonName
	}

	return PersonName{first, last}, nil
}

func (p PersonName) String() string {
	return p.First + " " + p.Last
}

type Phone string

func NewPhone(v string) (Phone, error) {
	v = strings.TrimSpace(v)
	if !phonePattern.MatchString(v) {
		return "", ErrPhone
	}
	return Phone(v), nil
}

func (p Phone) NumericString() string {
	s := []byte(p)
	j := 0
	for _, b := range s {
		if '0' <= b && b <= '9' {
			s[j] = b
			j++
		}
	}
	return string(s[:j])
}

type PhoneExt int32

type Email string

func NewEmail(v string) (Email, error) {
	v = strings.TrimSpace(v)
	if !emailPattern.MatchString(v) {
		return "", ErrEmail
	}
	return Email(v), nil
}

type Carrier struct {
	NAIC        NAIC
	Name        string
	FullName    string
	IsPreferred bool
	LogoKey     *string
}

================
File: internal/domain/currency/currency.go
================
package currency

type Currency int32

const (
	Cent   Currency = 1
	Dollar          = 100 * Cent
)

func (c Currency) Cents() int32 {
	return int32(c)
}

================
File: internal/domain/dental/dental.go
================
package dental

import (
	"time"

	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
)

type QuoteID int64

type Quote struct {
	ID             QuoteID
	StateAlphaCode geo.StateAlphaCode
	CarrierNaic    common.NAIC
	CarrierName    string
	AnnualBenefit  currency.Currency
	MonthlyRate    currency.Currency
	CreatedAt      time.Time
}

================
File: internal/domain/dental/store_test.go
================
package dental

import (
	"context"
	"path/filepath"
	"testing"
	"time"

	"github.com/jackc/pgx/v5"

	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

func TestQuoteStore(t *testing.T) {
	ctx := context.Background()

	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:16-alpine"),
		postgres.WithInitScripts(
			filepath.Join("..", "..", "..", "db", "migrations", "20241006213447_baseline.up.sql"),
			filepath.Join("testdata", "fixture.sql"),
		),
		postgres.WithDatabase("test-db"),
		postgres.WithUsername("postgres"),
		postgres.WithPassword("postgres"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).WithStartupTimeout(5*time.Minute)),
	)
	if err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() {
		if err := pgContainer.Terminate(ctx); err != nil {
			t.Fatalf("failed to terminate pgContainer: %s", err)
		}
	})

	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		t.Fatalf("failed to get postgres connection string: %s", err)
	}

	db, err := pgx.Connect(ctx, connStr)
	if err != nil {
		t.Fatalf("failed to connect to postgres: %s", err)
	}
	defer db.Close(ctx)

	t.Run("ListByStateAlphaCode", func(t *testing.T) {
		tt := []struct {
			name        string
			state       geo.StateAlphaCode
			expectedNum int
		}{
			{
				name:        "quote found",
				state:       "CA",
				expectedNum: 3,
			},
			{
				name:        "quote not found",
				state:       "NY",
				expectedNum: 0,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGQuoteStore(sqlc.New())
				quotes, err := store.ListByStateAlphaCode(ctx, tx, tc.state)
				if err != nil {
					t.Fatalf("failed to list quotes by state: %s", err)
				}

				gotNum := len(quotes)
				if gotNum != tc.expectedNum {
					t.Fatalf("num of quotes expected: %d, got: %d", tc.expectedNum, gotNum)
				}
			})
		}
	})

	t.Run("Get", func(t *testing.T) {
		tt := []struct {
			name    string
			quoteID QuoteID
			err     error
		}{
			{
				name:    "quote found",
				quoteID: 1,
				err:     nil,
			},
			{
				name:    "quote not found",
				quoteID: 999,
				err:     ErrQuoteNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGQuoteStore(sqlc.New())
				_, err = store.Get(ctx, tx, tc.quoteID)
				if err != tc.err {
					t.Fatalf("expected error: %s, got: %s", tc.err, err)
				}
			})
		}
	})

}

================
File: internal/domain/dental/store.go
================
package dental

import (
	"context"
	"errors"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
)

var ErrQuoteNotFound = errors.New("quote not found")

type QuoteStore interface {
	ListByStateAlphaCode(context.Context, common.DB, geo.StateAlphaCode) ([]*Quote, error)
	Get(context.Context, common.DB, QuoteID) (*Quote, error)
	GetEffective(context.Context, common.DB, common.NAIC, currency.Currency, geo.StateAlphaCode) (*Quote, error)
}

type PGQuoteStore struct {
	querier sqlc.Querier
}

var _ QuoteStore = new(PGQuoteStore)

func NewPGQuoteStore(querier sqlc.Querier) *PGQuoteStore {
	return &PGQuoteStore{querier: querier}
}

func (s *PGQuoteStore) ListByStateAlphaCode(ctx context.Context, db common.DB, stateAlphaCode geo.StateAlphaCode) ([]*Quote, error) {
	rows, err := s.querier.ListDentalQuotesByStateAlphaCode(ctx, db, string(stateAlphaCode))
	if err != nil {
		return nil, err
	}

	quotes := make([]*Quote, len(rows))
	for i, row := range rows {
		quotes[i] = s.mapRowToDentalQuote(row)
	}
	return quotes, nil
}

func (s *PGQuoteStore) Get(ctx context.Context, db common.DB, id QuoteID) (*Quote, error) {
	row, err := s.querier.GetDentalQuote(ctx, db, int64(id))
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrQuoteNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed queries.GetDentalQuote: %w", err)
	}

	return s.mapRowToDentalQuote((*sqlc.ListDentalQuotesByStateAlphaCodeRow)(row)), nil
}

func (s *PGQuoteStore) GetEffective(ctx context.Context, tx common.DB, naic common.NAIC, annualBenefit currency.Currency, stateAlphaCode geo.StateAlphaCode) (*Quote, error) {
	row, err := s.querier.GetEffectiveDentalQuote(ctx, tx, sqlc.GetEffectiveDentalQuoteParams{
		StateAlphaCode:     string(stateAlphaCode),
		CarrierNaic:        string(naic),
		AnnualBenefitCents: annualBenefit.Cents(),
	})
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrQuoteNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed queries.GetDentalQuote: %w", err)
	}

	rowConv := (*sqlc.ListDentalQuotesByStateAlphaCodeRow)(row)

	return s.mapRowToDentalQuote(rowConv), nil
}

func (s *PGQuoteStore) mapRowToDentalQuote(row *sqlc.ListDentalQuotesByStateAlphaCodeRow) *Quote {
	return &Quote{
		ID:             QuoteID(row.ID),
		StateAlphaCode: geo.StateAlphaCode(row.StateAlphaCode),
		CarrierNaic:    common.NAIC(row.CarrierNaic),
		CarrierName:    row.CarrierName,
		AnnualBenefit:  currency.Currency(row.AnnualBenefitCents) * currency.Cent,
		MonthlyRate:    currency.Currency(row.MonthlyRateCents) * currency.Cent,
		CreatedAt:      row.CreatedAt.Time,
	}
}

================
File: internal/domain/drug/drug.go
================
package drug

import (
	"time"

	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
)

type QuoteID int64

type ContractID string

type PlanID int32

type CompanyName string

type PlanName string

type Quote struct {
	ID             QuoteID
	ContractYear   int
	ContractID     ContractID
	PlanID         PlanID
	StateAlphaCode geo.StateAlphaCode
	CompanyName    CompanyName
	PlanName       PlanName
	MonthlyRate    currency.Currency
	CreatedAt      time.Time
	UpdatedAt      time.Time
}

================
File: internal/domain/drug/store_test.go
================
package drug

// import (
// 	"context"
// 	"path/filepath"
// 	"testing"
// 	"time"

// 	"github.com/jackc/pgx/v5"
// 	"github.com/medicareschoolcom/maxquote/internal/domain/common"
// 	"github.com/medicareschoolcom/maxquote/internal/domain/drug"
// 	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
// 	"github.com/testcontainers/testcontainers-go"
// 	"github.com/testcontainers/testcontainers-go/modules/postgres"
// 	"github.com/testcontainers/testcontainers-go/wait"
// )

// func TestQuoteStore(t *testing.T) {
// 	ctx := context.Background()

// 	pgContainer, err := postgres.RunContainer(ctx,
// 		testcontainers.WithImage("postgres:16-alpine"),
// 		postgres.WithInitScripts(
// 			filepath.Join("..", "..", "..", "..", "db", "migrations", "20241006213447_baseline.up.sql"),
// 			filepath.Join("testdata", "fixture.sql"),
// 		),
// 		postgres.WithDatabase("test-db"),
// 		postgres.WithUsername("postgres"),
// 		postgres.WithPassword("postgres"),
// 		testcontainers.WithWaitStrategy(
// 			wait.ForLog("database system is ready to accept connections").
// 				WithOccurrence(2).WithStartupTimeout(5*time.Minute)),
// 	)
// 	if err != nil {
// 		t.Fatal(err)
// 	}

// 	t.Cleanup(func() {
// 		if err := pgContainer.Terminate(ctx); err != nil {
// 			t.Fatalf("failed to terminate pgContainer: %s", err)
// 		}
// 	})

// 	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
// 	if err != nil {
// 		t.Fatalf("failed to get postgres connection string: %s", err)
// 	}

// 	db, err := pgx.Connect(ctx, connStr)
// 	if err != nil {
// 		t.Fatalf("failed to connect to postgres: %s", err)
// 	}
// 	defer db.Close(ctx)

// 	t.Run("ListByLatestYearAndState", func(t *testing.T) {
// 		tt := []struct {
// 			name                 string
// 			year                 common.Year
// 			state                geo.StateAlphaCode
// 			expectedContractYear common.Year
// 			expectedNum          int
// 		}{
// 			{
// 				name:                 "getting quotes from year with results",
// 				year:                 2024,
// 				state:                "CA",
// 				expectedContractYear: 2024,
// 				expectedNum:          22,
// 			},
// 			{
// 				name:                 "future year",
// 				year:                 2027,
// 				state:                "CA",
// 				expectedContractYear: 2025,
// 				expectedNum:          18,
// 			},
// 		}
// 		for _, tc := range tt {
// 			t.Run(tc.name, func(t *testing.T) {
// 				tx, err := db.Begin(ctx)
// 				if err != nil {
// 					t.Fatalf("failed to begin transaction: %s", err)
// 				}
// 				defer tx.Rollback(ctx)

// 				store := NewQuoteStore()
// 				quotes, err := store.ListByLatestYearAndState(ctx, tx, tc.year, tc.state)
// 				if err != nil {
// 					t.Fatalf("failed to list quotes by state: %s", err)
// 				}

// 				gotNum := len(quotes)
// 				if gotNum != tc.expectedNum {
// 					t.Fatalf("num of quotes expected: %d, got: %d", tc.expectedNum, gotNum)
// 				}

// 				if len(quotes) > 0 {
// 					quote := quotes[0]

// 					if quote.ContractYear != tc.expectedContractYear {
// 						t.Fatalf("contract year expected: %d, got: %d", tc.expectedContractYear, quote.ContractYear)
// 					}
// 				}
// 			})
// 		}
// 	})

// 	t.Run("Get", func(t *testing.T) {
// 		tt := []struct {
// 			name    string
// 			quoteID drug.QuoteID
// 			err     error
// 		}{
// 			{
// 				name:    "quote found",
// 				quoteID: 5488,
// 				err:     nil,
// 			},
// 			{
// 				name:    "quote not found",
// 				quoteID: 9999,
// 				err:     drug.ErrQuoteNotFound,
// 			},
// 		}
// 		for _, tc := range tt {
// 			t.Run(tc.name, func(t *testing.T) {
// 				tx, err := db.Begin(ctx)
// 				if err != nil {
// 					t.Fatalf("failed to begin transaction: %s", err)
// 				}
// 				defer tx.Rollback(ctx)

// 				store := NewQuoteStore()
// 				_, err = store.Get(ctx, tx, tc.quoteID)
// 				if err != tc.err {
// 					t.Fatalf("expected error: %s, got: %s", tc.err, err)
// 				}
// 			})
// 		}
// 	})

// 	t.Run("GetEffective", func(t *testing.T) {
// 		tt := []struct {
// 			name       string
// 			year       common.Year
// 			contractID drug.ContractID
// 			planID     drug.PlanID
// 			state      geo.StateAlphaCode
// 			err        error
// 		}{
// 			{
// 				name:       "quote found",
// 				year:       2025,
// 				contractID: "S1030",
// 				planID:     6,
// 				state:      "AL",
// 				err:        nil,
// 			},
// 			{
// 				name:       "quote not found",
// 				year:       2025,
// 				contractID: "9999999",
// 				planID:     6,
// 				state:      "AL",
// 				err:        drug.ErrQuoteNotFound,
// 			},
// 		}
// 		for _, tc := range tt {
// 			t.Run(tc.name, func(t *testing.T) {
// 				tx, err := db.Begin(ctx)
// 				if err != nil {
// 					t.Fatalf("failed to begin transaction: %s", err)
// 				}
// 				defer tx.Rollback(ctx)

// 				store := NewQuoteStore()
// 				_, err = store.GetEffective(ctx, tx, tc.year, tc.contractID, tc.planID, tc.state)
// 				if err != tc.err {
// 					t.Fatalf("expected error: %s, got: %s", tc.err, err)
// 				}
// 			})
// 		}
// 	})

// }

================
File: internal/domain/drug/store.go
================
package drug

import (
	"context"
	"errors"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
)

var ErrQuoteNotFound = errors.New("quote not found")

type QuoteStore interface {
	ListByLatestYearAndState(ctx context.Context, tx common.DB, contractYear int, stateAlphaCode geo.StateAlphaCode) ([]*Quote, error)
	Get(ctx context.Context, tx common.DB, id QuoteID) (*Quote, error)
	GetEffective(ctx context.Context, tx common.DB, contractYear int, contractID ContractID, planID PlanID, stateAlphaCode geo.StateAlphaCode) (*Quote, error)
}

type PGQuoteStore struct {
	querier sqlc.Querier
}

func NewPGQuoteStore(querier sqlc.Querier) *PGQuoteStore {
	return &PGQuoteStore{querier: querier}
}

var _ QuoteStore = new(PGQuoteStore)

func (r *PGQuoteStore) ListByLatestYearAndState(ctx context.Context, tx common.DB, contractYear int, stateAlphaCode geo.StateAlphaCode) ([]*Quote, error) {
	rows, err := r.querier.ListDrugQuotesByLatestYearAndState(ctx, tx, sqlc.ListDrugQuotesByLatestYearAndStateParams{
		ContractYear:   int32(contractYear),
		StateAlphaCode: string(stateAlphaCode),
	})
	if err != nil {
		return nil, err
	}

	quotes := make([]*Quote, len(rows))
	for i, row := range rows {
		quotes[i] = r.mapRowToDrugQuote(row)
	}

	return quotes, nil
}

func (r *PGQuoteStore) Get(ctx context.Context, db common.DB, id QuoteID) (*Quote, error) {
	row, err := r.querier.GetDrugQuote(ctx, db, int64(id))
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrQuoteNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed querier.GetDrugQuote: %w", err)
	}

	return r.mapRowToDrugQuote(row), nil
}

func (r *PGQuoteStore) GetEffective(ctx context.Context, db common.DB, contractYear int, contractID ContractID, planID PlanID, stateAlphaCode geo.StateAlphaCode) (*Quote, error) {
	row, err := r.querier.GetEffectiveDrugQuote(ctx, db, sqlc.GetEffectiveDrugQuoteParams{
		ContractYear:   int32(contractYear),
		ContractID:     string(contractID),
		PlanID:         int32(planID),
		StateAlphaCode: string(stateAlphaCode),
	})
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrQuoteNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed querier.GetEffectiveDrugQuote: %w", err)
	}

	return r.mapRowToDrugQuote(row), nil
}

func (r *PGQuoteStore) mapRowToDrugQuote(row *sqlc.DrugQuote) *Quote {
	return &Quote{
		ID:             QuoteID(row.ID),
		ContractYear:   int(row.ContractYear),
		ContractID:     ContractID(row.ContractID),
		PlanID:         PlanID(row.PlanID),
		StateAlphaCode: geo.StateAlphaCode(row.StateAlphaCode),
		CompanyName:    CompanyName(row.CompanyName),
		PlanName:       PlanName(row.PlanName),
		MonthlyRate:    currency.Currency(row.MonthlyRateCents) * currency.Cent,
		CreatedAt:      row.CreatedAt.Time,
		UpdatedAt:      row.UpdatedAt.Time,
	}
}

================
File: internal/domain/geo/geo.go
================
package geo

type County struct {
	FIPSCode       CountyFIPSCode
	Name           CountyName
	StateAlphaCode StateAlphaCode
}

type ZipCodeCounty struct {
	ZipCode        ZipCode
	CountyFIPSCode CountyFIPSCode
}

================
File: internal/domain/geo/store_test.go
================
package geo

import (
	"context"
	"path/filepath"
	"testing"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

func TestPGCountyStore(t *testing.T) {
	ctx := context.Background()

	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:16-alpine"),
		postgres.WithInitScripts(
			filepath.Join("..", "..", "..", "db", "migrations", "20241006213447_baseline.up.sql"),
			filepath.Join("testdata", "fixture.sql"),
		),
		postgres.WithDatabase("test-db"),
		postgres.WithUsername("postgres"),
		postgres.WithPassword("postgres"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).WithStartupTimeout(5*time.Minute)),
	)
	if err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() {
		if err := pgContainer.Terminate(ctx); err != nil {
			t.Fatalf("failed to terminate pgContainer: %s", err)
		}
	})

	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		t.Fatalf("failed to get postgres connection string: %s", err)
	}

	db, err := pgx.Connect(ctx, connStr)
	if err != nil {
		t.Fatalf("failed to connect to postgres: %s", err)
	}
	defer db.Close(ctx)

	t.Run("ListByFIPSCodes", func(t *testing.T) {
		tt := []struct {
			name      string
			fipsCodes []CountyFIPSCode
			wantNum   int
		}{
			{
				name:      "List fips codes by name",
				fipsCodes: []CountyFIPSCode{"01001", "01003", "01005"},
				wantNum:   3,
			},
		}

		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGCountyStore(sqlc.New())

				counties, err := store.ListByFIPSCodes(ctx, db, tc.fipsCodes)
				if err != nil {
					t.Fatal(err)
				}

				gotNum := len(counties)

				if gotNum != tc.wantNum {
					t.Fatalf("num of counties expected: %d, got: %d", tc.wantNum, gotNum)
				}
			})
		}
	})

	t.Run("Get", func(t *testing.T) {
		tt := []struct {
			name     string
			fipsCode CountyFIPSCode
			err      error
		}{
			{
				name:     "county found",
				fipsCode: "01001",
				err:      nil,
			},
			{
				name:     "county not found",
				fipsCode: "00000",
				err:      ErrCountyNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGCountyStore(sqlc.New())
				_, err = store.Get(ctx, tx, tc.fipsCode)
				if err != tc.err {
					t.Fatalf("expected error: %s, got: %s", tc.err, err)
				}
			})
		}
	})
}

func TestPGZipCodeCountyStore(t *testing.T) {
	ctx := context.Background()

	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:16-alpine"),
		postgres.WithInitScripts(
			filepath.Join("..", "..", "..", "db", "migrations", "20241006213447_baseline.up.sql"),
			filepath.Join("testdata", "fixture.sql"),
		),
		postgres.WithDatabase("test-db"),
		postgres.WithUsername("postgres"),
		postgres.WithPassword("postgres"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).WithStartupTimeout(5*time.Minute)),
	)
	if err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() {
		if err := pgContainer.Terminate(ctx); err != nil {
			t.Fatalf("failed to terminate pgContainer: %s", err)
		}
	})

	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		t.Fatalf("failed to get postgres connection string: %s", err)
	}

	db, err := pgx.Connect(ctx, connStr)
	if err != nil {
		t.Fatalf("failed to connect to postgres: %s", err)
	}
	defer db.Close(ctx)

	t.Run("ListByZipCode", func(t *testing.T) {
		tt := []struct {
			name    string
			zipcode ZipCode
			wantNum int
		}{
			{
				name:    "List by zip code",
				zipcode: "38583",
				wantNum: 5,
			},
		}

		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGZipCodeCountyStore(sqlc.New())

				zipCodeCounties, err := store.ListByZipCode(ctx, db, tc.zipcode)
				if err != nil {
					t.Fatal(err)
				}

				gotNum := len(zipCodeCounties)

				if gotNum != tc.wantNum {
					t.Fatalf("num of zipCodeCounties expected: %d, got: %d", tc.wantNum, gotNum)
				}
			})
		}
	})
}

================
File: internal/domain/geo/store.go
================
package geo

import (
	"context"
	"errors"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
)

var ErrCountyNotFound = errors.New("county not found")

type CountyStore interface {
	ListByFIPSCodes(context.Context, common.DB, []CountyFIPSCode) ([]*County, error)
	Get(context.Context, common.DB, CountyFIPSCode) (*County, error)
}

type PGCountyStore struct {
	querier sqlc.Querier
}

var _ CountyStore = new(PGCountyStore)

func NewPGCountyStore(querier sqlc.Querier) *PGCountyStore {
	return &PGCountyStore{querier: querier}
}

func (s *PGCountyStore) ListByFIPSCodes(ctx context.Context, tx common.DB, fipsCodes_ []CountyFIPSCode) ([]*County, error) {
	fipsCodes := make([]string, len(fipsCodes_))
	for i, fipsCode_ := range fipsCodes_ {
		fipsCodes[i] = string(fipsCode_)
	}

	rows, err := s.querier.ListCountiesByFIPSCodes(ctx, tx, fipsCodes)
	if err != nil {
		return nil, fmt.Errorf("failed ListCountiesByFIPSCodes: %w", err)
	}

	counties := make([]*County, len(rows))
	for i, row := range rows {
		counties[i] = s.mapRowToCounty(row)
	}

	return counties, nil
}

func (s *PGCountyStore) Get(ctx context.Context, tx common.DB, fipsCode CountyFIPSCode) (*County, error) {
	row, err := s.querier.GetCounty(ctx, tx, string(fipsCode))
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrCountyNotFound

	}
	if err != nil {
		return nil, fmt.Errorf("failed GetCounty: %w", err)
	}

	return s.mapRowToCounty(row), nil
}

func (s *PGCountyStore) mapRowToCounty(row *sqlc.County) *County {
	return &County{
		FIPSCode:       CountyFIPSCode(row.FipsCode),
		Name:           CountyName(row.Name),
		StateAlphaCode: StateAlphaCode(row.StateAlphaCode),
	}
}

type ZipCodeCountyStore interface {
	ListByZipCode(context.Context, common.DB, ZipCode) ([]*ZipCodeCounty, error)
}

type PGZipCodeCountyStore struct {
	querier sqlc.Querier
}

var _ ZipCodeCountyStore = new(PGZipCodeCountyStore)

func NewPGZipCodeCountyStore(querier sqlc.Querier) *PGZipCodeCountyStore {
	return &PGZipCodeCountyStore{querier: querier}
}

func (s *PGZipCodeCountyStore) ListByZipCode(ctx context.Context, tx common.DB, zipCode ZipCode) ([]*ZipCodeCounty, error) {
	rows, err := s.querier.ListZipCodeCountiesByZipCode(ctx, tx, string(zipCode))
	if err != nil {
		return nil, fmt.Errorf("failed ListZipCodeCountiesByZipCode: %w", err)
	}

	zipCodeCounties := make([]*ZipCodeCounty, len(rows))
	for i, row := range rows {
		zipCodeCounties[i] = s.mapRowToZipCodeCounty(row)
	}

	return zipCodeCounties, nil
}

func (s *PGZipCodeCountyStore) mapRowToZipCodeCounty(row *sqlc.ZipCodeCounty) *ZipCodeCounty {
	return &ZipCodeCounty{
		ZipCode:        ZipCode(row.ZipCode),
		CountyFIPSCode: CountyFIPSCode(row.CountyFipsCode),
	}
}

================
File: internal/domain/geo/values_test.go
================
package geo

import "testing"

func TestNewCountyFIPSCode(t *testing.T) {
	tt := []struct {
		name string
		code string
		err  error
	}{
		{
			name: "must be 5 numerals",
			code: "12345",
			err:  nil,
		},
		{
			name: "cannot have less than 5 numerals",
			code: "1234",
			err:  ErrCountyFIPSCode,
		},
		{
			name: "cannot have more than 5 numerals",
			code: "123456",
			err:  ErrCountyFIPSCode,
		},
	}
	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			_, err := NewCountyFIPSCode(tc.code)
			if err != tc.err {
				t.Fatalf("expected error: %s, got: %s", tc.err, err)
			}
		})
	}
}

func TestNewZipCode(t *testing.T) {
	tt := []struct {
		name string
		code string
		err  error
	}{
		{
			name: "must be 5 numerals",
			code: "12345",
			err:  nil,
		},
		{
			name: "cannot have less than 5 numerals",
			code: "1234",
			err:  ErrZipCode,
		},
		{
			name: "cannot have more than 5 numerals",
			code: "123456",
			err:  ErrZipCode,
		},
	}
	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			_, err := NewZipCode(tc.code)
			if err != tc.err {
				t.Fatalf("expected error: %s, got: %s", tc.err, err)
			}
		})
	}
}

================
File: internal/domain/geo/values.go
================
package geo

import (
	"errors"
	"regexp"
)

var (
	ErrZipCode        = errors.New("zip code invalid")
	ErrCountyFIPSCode = errors.New("county fips code invalid")
)

var (
	reZipCode        = regexp.MustCompile(`^[0-9]{5}$`)
	reCountyFIPSCode = regexp.MustCompile(`^[0-9]{5}$`)
)

type CountyFIPSCode string

func NewCountyFIPSCode(v string) (CountyFIPSCode, error) {
	if !reCountyFIPSCode.MatchString(v) {
		return "", ErrCountyFIPSCode
	}
	return CountyFIPSCode(v), nil
}

type CountyName string

type StateAlphaCode string

type ZipCode string

func NewZipCode(v string) (ZipCode, error) {
	if !reZipCode.MatchString(v) {
		return "", ErrZipCode
	}
	return ZipCode(v), nil
}

================
File: internal/domain/irmaa/irmaa_test.go
================
package irmaa

import (
	"testing"

	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
)

func TestBracket_Average(t *testing.T) {
	tt := []struct {
		name     string
		from     currency.Currency
		to       currency.Currency
		expected currency.Currency
	}{
		{
			name:     "returns average of from & to when to is provided",
			from:     10000,
			to:       20000,
			expected: 15000,
		},
		{
			name:     "returns from value when to is not provided",
			from:     10000,
			expected: 10000,
		},
	}

	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			from := tc.from
			var to *currency.Currency
			if tc.to != currency.Currency(0) {
				to = &tc.to
			}

			bracket := &Bracket{
				From: from,
				To:   to,
			}

			got := bracket.Average()

			if got != tc.expected {
				t.Fatalf("filing amount expected: %d, got: %d", tc.expected, got)
			}
		})
	}
}

================
File: internal/domain/irmaa/irmaa.go
================
package irmaa

import (
	"time"

	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
)

type BracketID int64

type FilingType string

const (
	IndividualFiling        FilingType = "Individual"
	MarriedFilingJointly    FilingType = "MarriedFilingJointly"
	MarriedFilingSeparately FilingType = "MarriedFilingSeparately"
)

type Bracket struct {
	ID                  BracketID
	Year                int
	FilingType          FilingType
	From                currency.Currency
	To                  *currency.Currency // READ ONLY
	PartBIRMAA          currency.Currency
	PartBMonthlyPremium currency.Currency
	PartDIRMAA          currency.Currency
	CreatedAt           time.Time
	UpdatedAt           time.Time
}

func (b *Bracket) Average() currency.Currency {
	if b.To == nil {
		return b.From
	}

	from := b.From.Cents()
	to := b.To.Cents()
	avg := (from + to) / 2
	return currency.Currency(avg) * currency.Cent
}

================
File: internal/domain/irmaa/store_test.go
================
package irmaa

import (
	"context"
	"path/filepath"
	"testing"
	"time"

	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

func TestStore(t *testing.T) {
	ctx := context.Background()

	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:16-alpine"),
		postgres.WithInitScripts(
			filepath.Join("..", "..", "..", "db", "migrations", "20241006213447_baseline.up.sql"),
			filepath.Join("testdata", "fixture.sql"),
		),
		postgres.WithDatabase("test-db"),
		postgres.WithUsername("postgres"),
		postgres.WithPassword("postgres"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).WithStartupTimeout(5*time.Minute)),
	)
	if err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() {
		if err := pgContainer.Terminate(ctx); err != nil {
			t.Fatalf("failed to terminate pgContainer: %s", err)
		}
	})

	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		t.Fatalf("failed to get postgres connection string: %s", err)
	}

	db, err := pgx.Connect(ctx, connStr)
	if err != nil {
		t.Fatalf("failed to connect to postgres: %s", err)
	}
	defer db.Close(ctx)

	t.Run("ListLatestByYear", func(t *testing.T) {
		tt := []struct {
			name         string
			year         int
			expectedNum  int
			expectedYear int
		}{
			{
				name:         "Gets most recent year",
				year:         2025,
				expectedYear: 2025,
				expectedNum:  15,
			},
			{
				name:         "Gets future year",
				year:         2026,
				expectedYear: 2025,
				expectedNum:  15,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGBracketStore(sqlc.New())
				brackets, err := store.ListLatestByYear(ctx, tx, tc.year)
				if err != nil {
					t.Fatalf("failed to list brackets by year: %s", err)
				}

				gotNum := len(brackets)
				if gotNum != tc.expectedNum {
					t.Fatalf("num of brackets expected: %d, got: %d", tc.expectedNum, gotNum)
				}

				if len(brackets) > 0 {
					bracket := brackets[0]

					if bracket.Year != tc.expectedYear {
						t.Fatalf("year expected: %d, got: %d", tc.expectedYear, bracket.Year)
					}
				}
			})
		}
	})

	t.Run("Get", func(t *testing.T) {
		tt := []struct {
			name      string
			bracketID BracketID
			err       error
		}{
			{
				name:      "bracket found",
				bracketID: 1,
				err:       nil,
			},
			{
				name:      "bracket not found",
				bracketID: 9999,
				err:       ErrBracketNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGBracketStore(sqlc.New())
				_, err = store.Get(ctx, tx, tc.bracketID)
				if err != tc.err {
					t.Fatalf("expected error: %s, got: %s", tc.err, err)
				}
			})
		}
	})

	t.Run("GetEffective", func(t *testing.T) {
		tt := []struct {
			name          string
			effectiveYear int
			filingType    FilingType
			amount        currency.Currency
			err           error
		}{
			{
				name:          "quote found",
				effectiveYear: 2025,
				filingType:    IndividualFiling,
				amount:        currency.Currency(15700000),
				err:           nil,
			},
			{
				name:          "quote not found",
				effectiveYear: 2024,
				filingType:    IndividualFiling,
				amount:        currency.Currency(15700000),
				err:           ErrBracketNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGBracketStore(sqlc.New())
				_, err = store.GetEffective(ctx, tx, tc.effectiveYear, tc.filingType, tc.amount)
				if err != tc.err {
					t.Fatalf("expected error: %s, got: %s", tc.err, err)
				}
			})
		}
	})

}

================
File: internal/domain/irmaa/store.go
================
package irmaa

import (
	"context"
	"errors"
	"fmt"

	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
)

var ErrBracketNotFound = errors.New("irmaa bracket not found")

type BracketStore interface {
	ListLatestByYear(context.Context, common.DB, int) ([]*Bracket, error)
	Get(context.Context, common.DB, BracketID) (*Bracket, error)
	GetEffective(ctx context.Context, db common.DB, year int, filingType FilingType, filingAmount currency.Currency) (*Bracket, error)
}

type PGBracketStore struct {
	querier sqlc.Querier
}

var _ BracketStore = new(PGBracketStore)

func NewPGBracketStore(querier sqlc.Querier) *PGBracketStore {
	return &PGBracketStore{querier: querier}
}

func (s *PGBracketStore) ListLatestByYear(ctx context.Context, tx common.DB, year int) ([]*Bracket, error) {
	rows, err := s.querier.ListLatestIrmaaBracketsByYear(ctx, tx, int32(year))
	if err != nil {
		return nil, err
	}

	brackets := make([]*Bracket, len(rows))
	for i, row := range rows {
		row2 := (*sqlc.GetIrmaaBracketRow)(row)
		bracket, err := s.mapRowToDomainBracket(row2)
		if err != nil {
			return nil, fmt.Errorf("failed mapRowToDomainBracket: %w", err)
		}
		brackets[i] = bracket
	}

	return brackets, nil
}

func (s *PGBracketStore) Get(ctx context.Context, tx common.DB, id BracketID) (*Bracket, error) {
	row, err := s.querier.GetIrmaaBracket(ctx, tx, int64(id))
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrBracketNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed querier.GetIrmaaBracket: %w", err)
	}

	bracket, err := s.mapRowToDomainBracket(row)
	if err != nil {
		return nil, fmt.Errorf("failed mapRowToDomainBracket: %w", err)
	}

	return bracket, nil
}

func (s *PGBracketStore) GetEffective(ctx context.Context, db common.DB, year int, filingType FilingType, amount currency.Currency) (*Bracket, error) {
	row, err := s.querier.GetEffectiveIrmaaBracket(ctx, db, sqlc.GetEffectiveIrmaaBracketParams{
		Year:       int32(year),
		FilingType: string(filingType),
		FromCents:  amount.Cents(),
	})
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrBracketNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed querier.GetEffectiveIrmaaBracket: %w", err)
	}

	row2 := (*sqlc.GetIrmaaBracketRow)(row)

	bracket, err := s.mapRowToDomainBracket(row2)
	if err != nil {
		return nil, fmt.Errorf("failed mapRowToDomainBracket: %w", err)
	}

	return bracket, nil
}

func (r *PGBracketStore) mapRowToDomainBracket(row *sqlc.GetIrmaaBracketRow) (*Bracket, error) {
	var entity Bracket
	entity.ID = BracketID(row.ID)
	entity.Year = int(row.Year)

	switch row.FilingType {
	case "Individual":
		entity.FilingType = IndividualFiling
	case "MarriedFilingJointly":
		entity.FilingType = MarriedFilingJointly
	case "MarriedFilingSeparately":
		entity.FilingType = MarriedFilingSeparately
	default:
		return nil, fmt.Errorf("unknown irmaa bracking filing type: %s", row.FilingType)
	}

	entity.From = currency.Currency(row.FromCents) * currency.Cent
	if row.ToCents > 0 {
		toCents := currency.Currency(row.ToCents) * currency.Cent
		entity.To = &toCents
	}

	entity.PartBIRMAA = currency.Currency(row.PartBIrmaaCents) * currency.Cent
	entity.PartBMonthlyPremium = currency.Currency(row.PartBMonthlyPremiumCents) * currency.Cent
	entity.PartDIRMAA = currency.Currency(row.PartDIrmaaCents) * currency.Cent
	entity.CreatedAt = row.CreatedAt.Time
	entity.UpdatedAt = row.UpdatedAt.Time

	return &entity, nil
}

================
File: internal/domain/quote/email_notifier_test.go
================
package quote

import (
	"context"
	"testing"

	"github.com/google/go-cmp/cmp"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/sendgrid/rest"
	"github.com/sendgrid/sendgrid-go/helpers/mail"
)

func TestSendGridEmailNotifier_SendQuote(t *testing.T) {
	var sentEmail *mail.SGMailV3
	client := testClient{
		sendFn: func(email *mail.SGMailV3) (*rest.Response, error) {
			sentEmail = email
			return nil, nil
		},
	}

	quote := &Quote{URLID: "abcdefgh"}
	agent_ := &agent.Agent{Name: common.PersonName{First: "Sam", Last: "Turner"}}

	dest := common.Email("jim.jangles@example.com")
	notifier := NewSendGridEmailNotifier("MedicareSchool.com", "support@medicareschool.com", "https://www.example.com", client)
	err := notifier.SendQuote(context.Background(), quote, agent_, dest)
	if err != nil {
		t.Fatal(err)
	}

	expected := []*mail.Content{
		{Type: "text/plain",
			Value: `Hello,
Your quote is ready. Please click the link below to view the details:
https://www.example.com/quotes/abcdefgh/review

If you have any questions, feel free to reach out to us.
Thank you for choosing Medicareschool.com!

Regards,
Sam Turner`,
		},
		{Type: "text/html",
			Value: `<!doctype html>
<html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Your Supplemental Insurance Quote is Ready!</title>
    </head>
    <body>
        <p>
            Hello,<br />
            Your quote is ready. Please click the link below to view the
            details:<br />
            <a href="https://www.example.com/quotes/abcdefgh/review">https://www.example.com/quotes/abcdefgh/review</a>
        </p>
        <p>
            If you have any questions, feel free to reach out to us.<br />
            Thank you for choosing Medicareschool.com!
        </p>
        <p>
            Regards,<br />
            Sam Turner
        </p>
    </body>
</html>`,
		},
	}

	got := sentEmail.Content
	if !cmp.Equal(expected, got) {
		t.Error(cmp.Diff(expected, got))
	}
}

type testClient struct {
	sendFn func(email *mail.SGMailV3) (*rest.Response, error)
}

func (c testClient) Send(email *mail.SGMailV3) (*rest.Response, error) {
	return c.sendFn(email)
}

================
File: internal/domain/quote/email_notifier.go
================
package quote

import (
	"context"
	"fmt"
	htmltemplate "html/template"
	"strings"
	texttemplate "text/template"

	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/sendgrid/rest"
	"github.com/sendgrid/sendgrid-go/helpers/mail"
)

type EmailNotifier interface {
	SendQuote(context.Context, *Quote, *agent.Agent, common.Email) error
}

type SendGridClient interface {
	Send(email *mail.SGMailV3) (*rest.Response, error)
}

type SendGridEmailNotifier struct {
	fromName    string
	fromAddress string
	baseURL     string
	client      SendGridClient
}

var _ EmailNotifier = new(SendGridEmailNotifier)

func NewSendGridEmailNotifier(fromName, fromAddress, baseURL string, client SendGridClient) *SendGridEmailNotifier {
	return &SendGridEmailNotifier{
		fromName:    fromName,
		fromAddress: fromAddress,
		baseURL:     baseURL,
		client:      client,
	}
}

type sendEmailParams struct {
	QuoteURL  string
	AgentName string
}

const emailHtmlTmpl = `<!doctype html>
<html lang="en">
    <head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Your Supplemental Insurance Quote is Ready!</title>
    </head>
    <body>
        <p>
            Hello,<br />
            Your quote is ready. Please click the link below to view the
            details:<br />
            <a href="{{.QuoteURL}}">{{.QuoteURL}}</a>
        </p>
        <p>
            If you have any questions, feel free to reach out to us.<br />
            Thank you for choosing Medicareschool.com!
        </p>
        <p>
            Regards,<br />
            {{.AgentName}}
        </p>
    </body>
</html>`

const emailTextTmpl = `Hello,
Your quote is ready. Please click the link below to view the details:
{{.QuoteURL}}

If you have any questions, feel free to reach out to us.
Thank you for choosing Medicareschool.com!

Regards,
{{.AgentName}}`

func (n *SendGridEmailNotifier) SendQuote(ctx context.Context, quote *Quote, agent_ *agent.Agent, email common.Email) error {
	quoteURL := n.baseURL + "/quotes/" + string(quote.URLID) + "/review"
	from := mail.NewEmail(n.fromName, n.fromAddress)
	subject := "Your Supplemental Insurance Quote is Ready!"
	to := mail.NewEmail("", string(email))

	msgParams := sendEmailParams{
		QuoteURL:  quoteURL,
		AgentName: agent_.Name.String(),
	}

	plainTextContent, err := n.renderSendQuotePlainTextMessage(emailTextTmpl, msgParams)
	if err != nil {
		return fmt.Errorf("failed to render plain text message: %w", err)
	}

	htmlContent, err := n.renderSendQuoteHTMLMessage(emailHtmlTmpl, msgParams)
	if err != nil {
		return fmt.Errorf("failed to render html message: %w", err)
	}

	message := mail.NewSingleEmail(from, subject, to, plainTextContent, htmlContent)
	if _, err := n.client.Send(message); err != nil {
		return fmt.Errorf("failed to send email: %w", err)
	}

	return nil
}

func (n *SendGridEmailNotifier) renderSendQuotePlainTextMessage(text string, params sendEmailParams) (string, error) {
	t, err := texttemplate.New("main").Parse(text)
	if err != nil {
		return "", fmt.Errorf("failed to parse html template: %w", err)
	}

	var b strings.Builder
	if err := t.Execute(&b, params); err != nil {
		return "", fmt.Errorf("failed to execute text template: %w", err)
	}

	return b.String(), nil
}

func (n *SendGridEmailNotifier) renderSendQuoteHTMLMessage(text string, params sendEmailParams) (string, error) {
	t, err := htmltemplate.New("main").Parse(text)
	if err != nil {
		return "", fmt.Errorf("failed to parse text template: %w", err)
	}

	var b strings.Builder
	if err := t.Execute(&b, params); err != nil {
		return "", fmt.Errorf("failed to execute text template: %w", err)
	}

	return b.String(), nil
}

================
File: internal/domain/quote/quote.go
================
package quote

import (
	"errors"
	"strings"
	"time"

	set "github.com/deckarep/golang-set/v2"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/client"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/dental"
	"github.com/medicareschoolcom/maxquote/internal/domain/drug"
	"github.com/medicareschoolcom/maxquote/internal/domain/irmaa"
	"github.com/medicareschoolcom/maxquote/internal/domain/sup"
)

var ErrQuoteNotFound = errors.New("quote not found")
var ErrBadURLID = errors.New("bad url id")

type ID int64

type URLID string

func NewURLID(v string) (URLID, error) {
	v = strings.TrimSpace(v)
	if v == "" {
		return "", ErrBadURLID
	}
	return URLID(v), nil
}

type SupplementalCarrierPlanType struct {
	CarrierNAIC common.NAIC
	PlanType    sup.PlanType
}

type Quote struct {
	ID                           ID
	URLID                        URLID
	ParentID                     *ID
	AgentID                      agent.ID
	ClientID                     client.ID
	EffectiveDate                common.Date
	IrmaaBracketID               irmaa.BracketID
	DrugQuoteID                  *drug.QuoteID
	DentalQuoteID                *dental.QuoteID
	HasMultiInsuredDiscount      bool
	HasLivingWithSomeoneDiscount bool
	SupplementalCarrierPlanTypes []SupplementalCarrierPlanType
	CreatedAt                    time.Time
	UpdatedAt                    time.Time
}

func New(id ID, urlID URLID, agentID agent.ID, clientID client.ID, effectiveDate common.Date, irmaaBracketID irmaa.BracketID, now time.Time) *Quote {
	return &Quote{
		ID:             id,
		URLID:          urlID,
		AgentID:        agentID,
		ClientID:       clientID,
		EffectiveDate:  effectiveDate,
		IrmaaBracketID: irmaaBracketID,

		CreatedAt: now,
		UpdatedAt: now,
	}
}

// RollingEffectiveDate returns the EffectiveDate. When the current date has passed the EffectiveDate,
// this function returns the date representing the first day of the next month.
func (q *Quote) RollingEffectiveDate(c common.Clock) common.Date {
	today := common.NewDate(c.Now())
	if today.After(q.EffectiveDate) {
		return today.FirstDayNextMonth()
	}
	return q.EffectiveDate
}

func (q *Quote) SupplementalPlanTypes() []sup.PlanType {
	planTypes := set.NewSet[sup.PlanType]()

	for _, carrierPlanType := range q.SupplementalCarrierPlanTypes {
		planTypes.Add(carrierPlanType.PlanType)
	}

	return planTypes.ToSlice()
}

func (q *Quote) SupplementalCarrierNAICS() []common.NAIC {
	naics := set.NewSet[common.NAIC]()

	for _, carrierPlanType := range q.SupplementalCarrierPlanTypes {
		naics.Add(carrierPlanType.CarrierNAIC)
	}

	return naics.ToSlice()
}

// type InsertParams struct {
// 	URLID                        URLID
// 	ParentID                     *ID
// 	AgentID                      agent.ID
// 	ClientID                     client.ID
// 	EffectiveDate                time.Time
// 	IRMAABracketID               irmaa.BracketID
// 	DrugQuoteID                  *drug.QuoteID
// 	DentalQuoteID                *dental.QuoteID
// 	HasMultiInsuredDiscount      bool
// 	HasLivingWithSomeoneDiscount bool
// 	SupplementalCarrierPlanTypes []sup.CarrierPlanType
// }

// type UpdateParams struct {
// 	ID                           ID
// 	ClientID                     client.ID
// 	EffectiveDate                time.Time
// 	IRMAABracketID               irmaa.BracketID
// 	DrugQuoteID                  *drug.QuoteID
// 	DentalQuoteID                *dental.QuoteID
// 	HasMultiInsuredDiscount      bool
// 	HasLivingWithSomeoneDiscount bool
// 	SupplementalCarrierPlanTypes []sup.CarrierPlanType
// }

// type QuoteStore interface {
// 	ListByAgentID(ctx context.Context, db common.DB, agentID agent.ID, limit int32) ([]*Quote, error)
// 	ListByAgentIDStartingAfterID(ctx context.Context, db common.DB, agentID agent.ID, startingAfter ID, limit int32) ([]*Quote, error)
// 	ListByAgentIDEndingBeforeID(ctx context.Context, db common.DB, agentID agent.ID, endingBefore ID, limit int32) ([]*Quote, error)
// 	ListByAgentIDAndClientID(context.Context, common.DB, agent.ID, client.ID) ([]*Quote, error)
// 	CountByAgentID(context.Context, common.DB, agent.ID) (int64, error)
// 	Get(context.Context, common.DB, ID) (*Quote, error)
// 	GetByUrlID(context.Context, common.DB, URLID) (*Quote, error)
// 	GetByParentID(context.Context, common.DB, ID) (*Quote, error)
// 	Insert(context.Context, common.DB, InsertParams) (ID, error)
// 	Update(context.Context, common.DB, UpdateParams) error
// }

================
File: internal/domain/quote/sms_notifier_test.go
================
package quote

import (
	"context"
	"testing"

	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	api "github.com/twilio/twilio-go/rest/api/v2010"
)

func TestQuoteSMSNotifier_SendQuote(t *testing.T) {
	quote := &Quote{URLID: "abcdefg"}
	agent_ := &agent.Agent{Name: common.PersonName{First: "John", Last: "Doe"}}

	var message *api.CreateMessageParams

	apiService := testApiService{
		createMessageFn: func(params *api.CreateMessageParams) (*api.ApiV2010Message, error) {
			message = params
			return nil, nil
		},
	}

	notifier := NewTwilioSMSNotifier(apiService, "+19132701758", "http://www.example.com")
	err := notifier.SendQuote(context.Background(), quote, agent_, "123-456-7890")
	if err != nil {
		t.Fatalf("failed to send quote: %s", err)
	}

	bodyExpected := "Hi! Your quote is ready. View it here: http://www.example.com/quotes/abcdefg/review. Have questions? Reply to this message. Thanks for choosing Medicareschool.com! – John Doe"
	bodyGot := *message.Body
	if bodyGot != bodyExpected {
		t.Errorf("body expected: %s, got: %s", bodyExpected, bodyGot)
	}

	fromExpected := "+19132701758"
	fromGot := *message.From
	if fromGot != fromExpected {
		t.Errorf("from expected: %s, got: %s", fromExpected, fromGot)
	}

	toExpected := "+19132701758"
	toGot := *message.From
	if toGot != toExpected {
		t.Errorf("to expected: %s, got: %s", toExpected, toGot)
	}
}

type testApiService struct {
	createMessageFn func(*api.CreateMessageParams) (*api.ApiV2010Message, error)
}

func (s testApiService) CreateMessage(params *api.CreateMessageParams) (*api.ApiV2010Message, error) {
	return s.createMessageFn(params)
}

================
File: internal/domain/quote/sms_notifier.go
================
package quote

import (
	"context"
	"fmt"
	"strings"
	"text/template"

	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/twilio/twilio-go"
	api "github.com/twilio/twilio-go/rest/api/v2010"
)

type SMSNotifier interface {
	SendQuote(context.Context, *Quote, *agent.Agent, common.Phone) error
}

type TwilioApiService interface {
	CreateMessage(*api.CreateMessageParams) (*api.ApiV2010Message, error)
}

func NewTwilioApiService(username, password string) *api.ApiService {
	client := twilio.NewRestClientWithParams(twilio.ClientParams{
		Username: username,
		Password: password,
	})
	return client.Api
}

type TwilioSMSNotifier struct {
	apiService      TwilioApiService
	fromPhoneNumber string
	baseURL         string
}

var _ SMSNotifier = new(TwilioSMSNotifier)

func NewTwilioSMSNotifier(apiService TwilioApiService, fromPhoneNumber, baseURL string) *TwilioSMSNotifier {
	return &TwilioSMSNotifier{
		apiService:      apiService,
		fromPhoneNumber: fromPhoneNumber,
		baseURL:         baseURL,
	}
}

const smsNotificationTemplate = `Hi! Your quote is ready. View it here: {{.QuoteURL}}. Have questions? Reply to this message. Thanks for choosing Medicareschool.com! – {{.AgentName}}`

func (n *TwilioSMSNotifier) SendQuote(ctx context.Context, quote *Quote, agent_ *agent.Agent, toPhone common.Phone) error {
	// Build template params
	type sendQuoteParams struct {
		QuoteURL  string
		AgentName string
	}

	quoteURL := n.baseURL + "/quotes/" + string(quote.URLID) + "/review"

	msgParams := sendQuoteParams{
		QuoteURL:  quoteURL,
		AgentName: agent_.Name.String(),
	}

	// Render the template string
	tmpl, err := template.New("main").Parse(smsNotificationTemplate)
	if err != nil {
		return fmt.Errorf("failed to parse text template: %w", err)
	}

	var buf strings.Builder
	if err := tmpl.Execute(&buf, msgParams); err != nil {
		return fmt.Errorf("failed to execute text template: %w", err)
	}

	// Build twilio message
	params := &api.CreateMessageParams{}
	params.SetBody(buf.String())
	params.SetFrom(n.fromPhoneNumber)
	params.SetTo(fmt.Sprintf("+1%s", toPhone.NumericString()))

	_, err = n.apiService.CreateMessage(params)
	if err != nil {
		return fmt.Errorf("failed to create message: %w", err)
	}

	return nil
}

================
File: internal/domain/quote/store_test.go
================
package quote

import (
	"context"
	"path/filepath"
	"testing"
	"time"

	"github.com/google/go-cmp/cmp"
	"github.com/jackc/pgx/v5"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/client"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/dental"
	"github.com/medicareschoolcom/maxquote/internal/domain/drug"
	"github.com/medicareschoolcom/maxquote/internal/domain/irmaa"
	"github.com/medicareschoolcom/maxquote/internal/domain/sup"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

func TestQuoteStore(t *testing.T) {
	ctx := context.Background()

	pgContainer, err := postgres.RunContainer(ctx,
		testcontainers.WithImage("postgres:16-alpine"),
		postgres.WithInitScripts(
			filepath.Join("..", "..", "..", "db", "migrations", "20241006213447_baseline.up.sql"),
			filepath.Join("testdata", "fixture.sql"),
		),
		postgres.WithDatabase("test-db"),
		postgres.WithUsername("postgres"),
		postgres.WithPassword("postgres"),
		testcontainers.WithWaitStrategy(
			wait.ForLog("database system is ready to accept connections").
				WithOccurrence(2).WithStartupTimeout(5*time.Minute)),
	)
	if err != nil {
		t.Fatal(err)
	}

	t.Cleanup(func() {
		if err := pgContainer.Terminate(ctx); err != nil {
			t.Fatalf("failed to terminate pgContainer: %s", err)
		}
	})

	connStr, err := pgContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		t.Fatalf("failed to get postgres connection string: %s", err)
	}

	db, err := pgx.Connect(ctx, connStr)
	if err != nil {
		t.Fatalf("failed to connect to postgres: %s", err)
	}
	defer db.Close(ctx)

	t.Run("NextID", func(t *testing.T) {
		tx, err := db.Begin(ctx)
		if err != nil {
			t.Fatalf("failed to begin transaction: %s", err)
		}
		defer tx.Rollback(ctx)

		store := NewPGStore(sqlc.New())

		id1, err := store.NextID(ctx, tx)
		if err != nil {
			t.Fatalf("failed store.NextID: %s", err)
		}
		if id1 != ID(9) {
			t.Fatalf("id expected: %d, got: %d", ID(9), id1)
		}

		id2, err := store.NextID(ctx, tx)
		if err != nil {
			t.Fatalf("failed store.NextID: %s", err)
		}
		if id2 != ID(10) {
			t.Fatalf("id expected: %d, got: %d", ID(10), id2)
		}
	})

	t.Run("Count", func(t *testing.T) {
		agentID2 := agent.ID(2)
		agentID4 := agent.ID(4)
		clientID1 := client.ID(1)

		tt := []struct {
			name      string
			params    CountParams
			wantCount int64
		}{
			{
				name:      "with agent_id 2",
				params:    CountParams{AgentID: &agentID2},
				wantCount: 4,
			},
			{
				name:      "with agent_id 4",
				params:    CountParams{AgentID: &agentID4},
				wantCount: 3,
			},
			{
				name:      "with agent and client",
				params:    CountParams{AgentID: &agentID4, ClientID: &clientID1},
				wantCount: 1,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())
				count, err := store.Count(ctx, tx, tc.params)
				if err != nil {
					t.Fatal(err)
				}

				if count != tc.wantCount {
					t.Fatalf("count expected:%d, got:%d", tc.wantCount, count)
				}
			})
		}
	})

	t.Run("List", func(t *testing.T) {
		agentID4 := agent.ID(4)
		clientID1 := client.ID(1)
		id4 := ID(4)

		tt := []struct {
			name    string
			params  ListParams
			wantIDS []ID
		}{
			{
				name:    "with limit",
				params:  ListParams{Limit: 5},
				wantIDS: []ID{7, 6, 5, 4, 3},
			},
			{
				name:    "with agentID",
				params:  ListParams{AgentID: &agentID4, Limit: 100},
				wantIDS: []ID{3, 2, 1},
			},
			{
				name:    "with clientID",
				params:  ListParams{ClientID: &clientID1, Limit: 100},
				wantIDS: []ID{7, 5, 4, 3},
			},
			{
				name:    "startingAfter 4",
				params:  ListParams{StartingAfterID: &id4, Limit: 100},
				wantIDS: []ID{3, 2, 1},
			},
			{
				name:    "endingAfter 4",
				params:  ListParams{EndingBeforeID: &id4, Limit: 100},
				wantIDS: []ID{7, 6, 5},
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())
				quotes, err := store.List(ctx, tx, tc.params)
				if err != nil {
					t.Fatal(err)
				}

				ids := make([]ID, len(quotes))
				for i, quote := range quotes {
					ids[i] = quote.ID
				}

				if !cmp.Equal(ids, tc.wantIDS) {
					t.Fatalf("ids wanted:%v+, got:%v+", tc.wantIDS, ids)
				}
			})
		}
	})

	t.Run("Get", func(t *testing.T) {
		tt := []struct {
			name string
			id   ID
			err  error
		}{
			{
				name: "found by id",
				id:   2,
			},
			{
				name: "not found",
				id:   999,
				err:  ErrQuoteNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())
				_, err = store.Get(ctx, tx, tc.id)
				if err != tc.err {
					t.Fatalf("expected error:%v, got:%v", tc.err, err)
				}
			})
		}
	})

	t.Run("GetByParentID", func(t *testing.T) {
		tt := []struct {
			name     string
			parentID ID
			err      error
		}{
			{
				name:     "found by parentId",
				parentID: 7,
			},
			{
				name:     "not found",
				parentID: 999,
				err:      ErrQuoteNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())
				_, err = store.GetByParentID(ctx, tx, tc.parentID)
				if err != tc.err {
					t.Fatalf("expected error:%v, got:%v", tc.err, err)
				}
			})
		}
	})

	t.Run("GetByUrlID", func(t *testing.T) {
		tt := []struct {
			name  string
			urlID URLID
			err   error
		}{
			{
				name:  "agent found by id",
				urlID: "6EuB5ntL0WaPOUPiNel8AalpUUe90unE",
			},
			{
				name:  "agent not found",
				urlID: "jhasdkjhgertkjhekfhsiisadfkbwkjehg",
				err:   ErrQuoteNotFound,
			},
		}
		for _, tc := range tt {
			t.Run(tc.name, func(t *testing.T) {
				tx, err := db.Begin(ctx)
				if err != nil {
					t.Fatalf("failed to begin transaction: %s", err)
				}
				defer tx.Rollback(ctx)

				store := NewPGStore(sqlc.New())
				_, err = store.GetByUrlID(ctx, tx, tc.urlID)
				if err != tc.err {
					t.Fatalf("expected error:%v, got:%v", tc.err, err)
				}
			})
		}
	})

	t.Run("Store", func(t *testing.T) {
		tx, err := db.Begin(ctx)
		if err != nil {
			t.Fatalf("failed to begin transaction: %s", err)
		}
		defer tx.Rollback(ctx)

		drugQuoteID := drug.QuoteID(5489)
		dentalQuoteID := dental.QuoteID(2)
		now := time.Now()

		quote := &Quote{
			ID:                           ID(999),
			URLID:                        "hkhksadhfkasdhfkqgkjhgkj4hg23k",
			ParentID:                     nil,
			AgentID:                      agent.ID(2),
			ClientID:                     client.ID(1),
			EffectiveDate:                common.NewDate(now),
			IrmaaBracketID:               irmaa.BracketID(1),
			DrugQuoteID:                  &drugQuoteID,
			DentalQuoteID:                &dentalQuoteID,
			HasMultiInsuredDiscount:      true,
			HasLivingWithSomeoneDiscount: true,
			SupplementalCarrierPlanTypes: []SupplementalCarrierPlanType{
				{common.NAIC("60380"), sup.PlanTypeG},
				{common.NAIC("60380"), sup.PlanTypeN},
			},
			CreatedAt: now,
			UpdatedAt: now,
		}

		store := NewPGStore(sqlc.New())

		// Insert
		if err := store.Store(ctx, tx, quote); err != nil {
			t.Fatal(err)
		}

		// Upsert
		if err := store.Store(ctx, tx, quote); err != nil {
			t.Fatal(err)
		}
	})
}

================
File: internal/domain/quote/store.go
================
package quote

import (
	"context"
	"errors"
	"fmt"

	sq "github.com/Masterminds/squirrel"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/client"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/dental"
	"github.com/medicareschoolcom/maxquote/internal/domain/drug"
	"github.com/medicareschoolcom/maxquote/internal/domain/irmaa"
	"github.com/medicareschoolcom/maxquote/internal/domain/sup"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
)

type ListParams struct {
	ClientID        *client.ID
	AgentID         *agent.ID
	StartingAfterID *ID
	EndingBeforeID  *ID
	Limit           int32
}

type CountParams struct {
	ClientID *client.ID
	AgentID  *agent.ID
}

type Store interface {
	NextID(context.Context, common.DB) (ID, error)
	Count(context.Context, common.DB, CountParams) (int64, error)
	List(context.Context, common.DB, ListParams) ([]*Quote, error)
	Get(context.Context, common.DB, ID) (*Quote, error)
	GetByParentID(context.Context, common.DB, ID) (*Quote, error)
	GetByUrlID(context.Context, common.DB, URLID) (*Quote, error)
	Store(context.Context, common.DB, *Quote) error
	Delete(context.Context, common.DB, ID) error
}

type PGStore struct {
	querier sqlc.Querier
}

var _ Store = new(PGStore)

func NewPGStore(querier sqlc.Querier) *PGStore {
	return &PGStore{querier: querier}
}

func (s *PGStore) NextID(ctx context.Context, tx common.DB) (ID, error) {
	i, err := s.querier.GetNextQuoteID(ctx, tx)
	if err != nil {
		return ID(0), fmt.Errorf("failed querier.GetNextQuoteID: %w", err)
	}
	return ID(i), nil
}

func (s *PGStore) Count(ctx context.Context, tx common.DB, params CountParams) (int64, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	b := psql.Select("COUNT(*)").
		From("quote").
		Where(sq.Eq{"parent_id": nil})

	if params.AgentID != nil {
		b = b.Where("agent_id = ?", *params.AgentID)
	}

	if params.ClientID != nil {
		b = b.Where("client_id = ?", *params.ClientID)
	}

	sql, args, err := b.ToSql()
	if err != nil {
		return 0, fmt.Errorf("failed to convert sql builder statement into string: %w", err)
	}

	row := tx.QueryRow(ctx, sql, args...)
	var count int64
	if err := row.Scan(&count); err != nil {
		return 0, fmt.Errorf("failed to scan row: %w", err)
	}
	return count, nil
}

func (s *PGStore) List(ctx context.Context, tx common.DB, params ListParams) ([]*Quote, error) {
	psql := sq.StatementBuilder.PlaceholderFormat(sq.Dollar)

	b := psql.
		Select(
			"id",
			"url_id",
			"parent_id",
			"agent_id",
			"client_id",
			"effective_date",
			"irmaa_bracket_id",
			"drug_quote_id",
			"dental_quote_id",
			"has_multi_insured_discount",
			"has_living_with_someone_discount",
			"created_at",
			"updated_at",
		).
		From("quote").
		Where(sq.Eq{"parent_id": nil}).
		Limit(uint64(params.Limit)).
		OrderBy("id DESC")

	if params.ClientID != nil {
		b = b.Where("client_id = ?", *params.ClientID)
	}

	if params.AgentID != nil {
		b = b.Where("agent_id = ?", *params.AgentID)
	}

	if params.StartingAfterID != nil {
		b = b.Where("id < ?", *params.StartingAfterID)
	}

	if params.EndingBeforeID != nil {
		b = b.Where("id > ?", *params.EndingBeforeID)
	}

	sql, args, err := b.ToSql()
	if err != nil {
		return nil, fmt.Errorf("failed to convert sql builder statement into string: %w", err)
	}

	rows, err := tx.Query(ctx, sql, args...)
	if err != nil {
		return nil, fmt.Errorf("failed tx.Query: %w", err)
	}
	defer rows.Close()

	var sqlcQuotes []*sqlc.Quote
	for rows.Next() {
		var i sqlc.Quote
		if err := rows.Scan(
			&i.ID,
			&i.UrlID,
			&i.ParentID,
			&i.AgentID,
			&i.ClientID,
			&i.EffectiveDate,
			&i.IrmaaBracketID,
			&i.DrugQuoteID,
			&i.DentalQuoteID,
			&i.HasMultiInsuredDiscount,
			&i.HasLivingWithSomeoneDiscount,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		sqlcQuotes = append(sqlcQuotes, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}

	quoteIDS := make([]int64, len(sqlcQuotes))
	for i, sqlcQuote := range sqlcQuotes {
		quoteIDS[i] = sqlcQuote.ID
	}

	supplementalCarrierPlanTypes, err := s.querier.ListQuoteSupplementalPlansByQuoteIDS(ctx, tx, quoteIDS)
	if err != nil {
		return nil, fmt.Errorf("failed querier.ListQuoteSupplementalPlansByQuoteIDS: %w", err)
	}

	quotes := make([]*Quote, len(sqlcQuotes))
	for i, sqlcQuote := range sqlcQuotes {
		quote, err := s.mapRowToQuote(sqlcQuote, supplementalCarrierPlanTypes)
		if err != nil {
			return nil, fmt.Errorf("failed mapRowToQuote: %w", err)
		}
		quotes[i] = quote
	}

	return quotes, nil
}

func (s *PGStore) Get(ctx context.Context, tx common.DB, id ID) (*Quote, error) {
	quoteRow, err := s.querier.GetQuote(ctx, tx, int64(id))
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrQuoteNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed querier.GetQuote: %w", err)
	}

	supplementalPlansRow, err := s.querier.ListQuoteSupplementalPlansByQuoteID(ctx, tx, quoteRow.ID)
	if err != nil {
		return nil, fmt.Errorf("failed querier.ListQuoteSupplementalPlansByQuoteID: %w", err)
	}

	quote, err := s.mapRowToQuote(quoteRow, supplementalPlansRow)
	if err != nil {
		return nil, fmt.Errorf("failed mapRowToQuote: %w", err)
	}

	return quote, nil
}

func (s *PGStore) GetByParentID(ctx context.Context, tx common.DB, parentID ID) (*Quote, error) {
	quoteRow, err := s.querier.GetQuoteByParentID(ctx, tx, pgtype.Int8{Int64: int64(parentID), Valid: true})
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrQuoteNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed querier.GetQuoteByParentID: %w", err)
	}

	supplementalPlansRow, err := s.querier.ListQuoteSupplementalPlansByQuoteID(ctx, tx, quoteRow.ID)
	if err != nil {
		return nil, fmt.Errorf("failed querier.ListQuoteSupplementalPlansByQuoteID: %w", err)
	}

	quote, err := s.mapRowToQuote(quoteRow, supplementalPlansRow)
	if err != nil {
		return nil, fmt.Errorf("failed mapRowToQuote: %w", err)
	}

	return quote, nil
}

func (s *PGStore) GetByUrlID(ctx context.Context, tx common.DB, urlID URLID) (*Quote, error) {
	quoteRow, err := s.querier.GetQuoteByUrlID(ctx, tx, string(urlID))
	if errors.Is(err, pgx.ErrNoRows) {
		return nil, ErrQuoteNotFound
	}
	if err != nil {
		return nil, fmt.Errorf("failed querier.GetQuoteByUrlID: %w", err)
	}

	supplementalPlansRow, err := s.querier.ListQuoteSupplementalPlansByQuoteID(ctx, tx, quoteRow.ID)
	if err != nil {
		return nil, fmt.Errorf("failed querier.ListQuoteSupplementalPlansByQuoteID: %w", err)
	}

	quote, err := s.mapRowToQuote(quoteRow, supplementalPlansRow)
	if err != nil {
		return nil, fmt.Errorf("failed mapRowToQuote: %w", err)
	}

	return quote, nil
}

func (s *PGStore) Store(ctx context.Context, tx common.DB, quote *Quote) error {
	// Store quote
	var params sqlc.UpsertQuoteParams
	params.ID = int64(quote.ID)
	params.UrlID = string(quote.URLID)
	if quote.ParentID != nil {
		params.ParentID = pgtype.Int8{Int64: int64(*quote.ParentID), Valid: true}
	}

	params.AgentID = int64(quote.AgentID)
	params.ClientID = int64(quote.ClientID)
	params.EffectiveDate = pgtype.Date{Time: quote.EffectiveDate.Time(), Valid: true}
	params.IrmaaBracketID = int64(quote.IrmaaBracketID)
	if quote.DrugQuoteID != nil {
		params.DrugQuoteID = pgtype.Int8{Int64: int64(*quote.DrugQuoteID), Valid: true}
	}
	if quote.DentalQuoteID != nil {
		params.DentalQuoteID = pgtype.Int8{Int64: int64(*quote.DentalQuoteID), Valid: true}
	}
	params.HasMultiInsuredDiscount = quote.HasMultiInsuredDiscount
	params.HasLivingWithSomeoneDiscount = quote.HasLivingWithSomeoneDiscount
	params.CreatedAt = pgtype.Timestamptz{Time: quote.CreatedAt, Valid: true}
	params.UpdatedAt = pgtype.Timestamptz{Time: quote.UpdatedAt, Valid: true}

	err := s.querier.UpsertQuote(ctx, tx, params)
	if err != nil {
		return fmt.Errorf("failed querier.UpsertQuote: %w", err)
	}

	// Delete existing SupplementalCarrierPlanTypes
	err = s.querier.DeleteQuoteSupplementalPlansByQuoteID(ctx, tx, int64(quote.ID))
	if err != nil {
		return fmt.Errorf("failed querier.DeleteQuoteSupplementalPlansByQuoteID: %w", err)
	}

	// Insert new SupplementalCarrierPlanTypes
	var insertParams []sqlc.InsertQuoteSupplementalPlanParams
	for _, supPlan := range quote.SupplementalCarrierPlanTypes {
		insertParam := sqlc.InsertQuoteSupplementalPlanParams{
			QuoteID:     int64(quote.ID),
			CarrierNaic: string(supPlan.CarrierNAIC),
			PlanType:    string(supPlan.PlanType),
		}
		insertParams = append(insertParams, insertParam)
	}
	_, err = s.querier.InsertQuoteSupplementalPlan(ctx, tx, insertParams)
	if err != nil {
		return fmt.Errorf("failed querier.InsertQuoteSupplementalPlan: %w", err)
	}

	return nil
}

func (s *PGStore) Delete(ctx context.Context, tx common.DB, id ID) error {
	err := s.querier.DeleteQuoteSupplementalPlansByQuoteID(ctx, tx, int64(id))
	if err != nil {
		return fmt.Errorf("failed querier.DeleteQuoteSupplementalPlansByQuoteID: %w", err)
	}

	err = s.querier.DeleteQuote(ctx, tx, int64(id))
	if err != nil {
		return fmt.Errorf("failed querier.DeleteQuote: %w", err)
	}

	return nil
}

func (s *PGStore) mapRowToQuote(quoteRow *sqlc.Quote, supplementalCarrierPlanTypeRows []*sqlc.QuoteSupplementalCarrierPlanType) (*Quote, error) {
	var q Quote
	q.ID = ID(quoteRow.ID)
	q.URLID = URLID(quoteRow.UrlID)
	if quoteRow.ParentID.Valid {
		q.ParentID = (*ID)(&quoteRow.ParentID.Int64)
	}
	q.AgentID = agent.ID(quoteRow.AgentID)
	q.ClientID = client.ID(quoteRow.ClientID)
	q.EffectiveDate = common.NewDate(quoteRow.EffectiveDate.Time)
	q.IrmaaBracketID = irmaa.BracketID(quoteRow.IrmaaBracketID)
	if quoteRow.DrugQuoteID.Valid {
		q.DrugQuoteID = (*drug.QuoteID)(&quoteRow.DrugQuoteID.Int64)
	}
	if quoteRow.DentalQuoteID.Valid {
		q.DentalQuoteID = (*dental.QuoteID)(&quoteRow.DentalQuoteID.Int64)
	}
	q.HasMultiInsuredDiscount = quoteRow.HasMultiInsuredDiscount
	q.HasLivingWithSomeoneDiscount = quoteRow.HasLivingWithSomeoneDiscount

	q.SupplementalCarrierPlanTypes = []SupplementalCarrierPlanType{}
	for _, row := range supplementalCarrierPlanTypeRows {
		if row.QuoteID == quoteRow.ID {
			var supplementalCarrierPlanType SupplementalCarrierPlanType
			supplementalCarrierPlanType.CarrierNAIC = common.NAIC(row.CarrierNaic)

			switch row.PlanType {
			case "F":
				supplementalCarrierPlanType.PlanType = sup.PlanTypeF
			case "G":
				supplementalCarrierPlanType.PlanType = sup.PlanTypeG
			case "N":
				supplementalCarrierPlanType.PlanType = sup.PlanTypeN
			default:
				return nil, fmt.Errorf("unknown QuoteSupplementalCarrierPlanType.PlanType: %s", row.PlanType)
			}

			q.SupplementalCarrierPlanTypes = append(q.SupplementalCarrierPlanTypes, supplementalCarrierPlanType)
		}
	}

	q.CreatedAt = quoteRow.CreatedAt.Time
	q.UpdatedAt = quoteRow.UpdatedAt.Time
	return &q, nil
}

================
File: internal/domain/quote/urlid_gen_test.go
================
package quote

import "testing"

func TestNanoQuoteURLIDGenerator_Generate(t *testing.T) {
	idLen := 8
	generator := NewNanoQuoteURLIDGenerator(idLen)
	urlID, err := generator.Generate()
	if err != nil {
		t.Fatalf("failed to generate urlid: %s", err)
	}

	idLenGot := len(urlID)

	if idLenGot != idLen {
		t.Fatalf("len expected: %d, got: %d", idLen, idLenGot)
	}
}

================
File: internal/domain/quote/urlid_gen.go
================
package quote

import (
	"fmt"

	nanoid "github.com/matoous/go-nanoid"
)

type URLIDGenerator interface {
	Generate() (URLID, error)
}

const nanoIDCharSet = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"

type NanoQuoteURLIDGenerator struct {
	length int
}

func NewNanoQuoteURLIDGenerator(length int) *NanoQuoteURLIDGenerator {
	return &NanoQuoteURLIDGenerator{length: length}
}

func (g *NanoQuoteURLIDGenerator) Generate() (URLID, error) {
	urlID, err := nanoid.Generate(nanoIDCharSet, g.length)
	if err != nil {
		return "", fmt.Errorf("failed nanoid.Generate: %w", err)
	}
	return URLID(urlID), nil
}

================
File: internal/domain/sup/store_test.go
================
package sup

import (
	"context"
	"net/http"
	"os"
	"testing"

	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
)

func TestCSGQuoteStore_List(t *testing.T) {
	tt := []struct {
		name           string
		zipCode        geo.ZipCode
		countyName     geo.CountyName
		stateAlphaCode geo.StateAlphaCode
		age            int
		gender         common.Gender
		isTobaccoUser  bool
		planTypes      []PlanType
		effectiveDate  string
		naics          []common.NAIC
		expected       int
	}{
		{
			name:           "2025-03-01 all carriers",
			zipCode:        "90210",
			countyName:     "Los Angeles County",
			stateAlphaCode: "CA",
			age:            69,
			gender:         common.GenderMale,
			isTobaccoUser:  false,
			planTypes:      []PlanType{PlanTypeF, PlanTypeG, PlanTypeN},
			effectiveDate:  "2025-01-01",
			naics:          []common.NAIC{"60380", "62825", "82538"},
			expected:       3,
		},
		{
			name:           "2025-03-01 single carrier",
			zipCode:        "90210",
			countyName:     "Los Angeles County",
			stateAlphaCode: "CA",
			age:            69,
			gender:         common.GenderMale,
			isTobaccoUser:  false,
			planTypes:      []PlanType{PlanTypeF, PlanTypeG, PlanTypeN},
			effectiveDate:  "2025-03-01",
			naics:          []common.NAIC{"82538"},
			expected:       3,
		},
	}
	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			ctx := context.Background()

			apiKey := os.Getenv("TEST_CSG_CACHE_API_KEY")
			if apiKey == "" {
				t.Skip("set TEST_CSG_CACHE_API_KEY to run this test")
			}

			baseURL := os.Getenv("TEST_CSG_CACHE_BASE_URL")
			if baseURL == "" {
				t.Skip("set TEST_CSG_CACHE_BASE_URL to run this test")
			}

			store := NewCSGQuoteStore(apiKey, baseURL, &http.Client{})

			effectiveDate, err := common.ParseDate(tc.effectiveDate)
			if err != nil {
				t.Fatal(err)
			}

			quotes, err := store.List(ctx, ListParams{
				ZipCode:        tc.zipCode,
				StateAlphaCode: tc.stateAlphaCode,
				CountyName:     tc.countyName,
				Age:            tc.age,
				Gender:         tc.gender,
				IsTobaccoUser:  tc.isTobaccoUser,
				PlanTypes:      tc.planTypes,
				EffectiveDate:  effectiveDate,
				NAICs:          tc.naics,
			})
			if err != nil {
				t.Fatal(err)
			}

			got := len(quotes)
			if got != tc.expected {
				t.Fatalf("num of quotes, got:%d, expected:%d", got, tc.expected)
			}
		})
	}
}

================
File: internal/domain/sup/store.go
================
package sup

import (
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"sort"
	"strconv"
	"strings"

	set "github.com/deckarep/golang-set/v2"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
	"github.com/medicareschoolcom/maxquote/internal/sqlc"
)

type ListParams struct {
	ZipCode        geo.ZipCode
	CountyName     geo.CountyName
	StateAlphaCode geo.StateAlphaCode
	Age            int
	Gender         common.Gender
	IsTobaccoUser  bool
	PlanTypes      []PlanType
	EffectiveDate  common.Date
	CarrierGroup   CarrierGroup
	NAICs          []common.NAIC
}

type QuoteStore interface {
	List(context.Context, ListParams) ([]*Quote, error)
}

type CSGQuoteStore struct {
	apiKey     string
	baseURL    string
	httpClient *http.Client
}

var _ QuoteStore = new(CSGQuoteStore)

func NewCSGQuoteStore(apiKey, baseURL string, httpClient *http.Client) *CSGQuoteStore {
	return &CSGQuoteStore{
		apiKey:     apiKey,
		baseURL:    baseURL,
		httpClient: httpClient,
	}
}

func (s *CSGQuoteStore) List(ctx context.Context, params ListParams) ([]*Quote, error) {
	type cgsQuote struct {
		Age              int    `json:"age"`
		Gender           string `json:"gender"`
		Plan             string `json:"plan"`
		Tobacco          int    `json:"tobacco"`
		Rate             int    `json:"rate"`
		DiscountRate     int    `json:"discount_rate"`
		DiscountCategory string `json:"discount_category"`
	}

	type cgsCarrier struct {
		NAIC            string     `json:"naic"`
		CompanyName     string     `json:"company_name"`
		CompanyNameFull string     `json:"company_name_full"`
		Quotes          []cgsQuote `json:"quotes"`
	}

	url := s.baseURL + "/quotes/"
	req, err := http.NewRequest(http.MethodGet, url, nil)
	if err != nil {
		return nil, err
	}

	// Create request query
	q := req.URL.Query()
	q.Add("zip_code", string(params.ZipCode))
	q.Add("state", string(params.StateAlphaCode))
	q.Add("county", string(params.CountyName))
	q.Add("age", strconv.Itoa(params.Age))

	if params.IsTobaccoUser {
		q.Add("tobacco", "true")
	} else {
		q.Add("tobacco", "false")
	}

	switch params.Gender {
	case common.GenderMale:
		q.Add("gender", "M")
	case common.GenderFemale:
		q.Add("gender", "F")
	default:
		return nil, fmt.Errorf("unknown gender: %s", params.Gender)
	}

	switch params.CarrierGroup {
	case Supported:
		q.Add("carriers", "supported")
	case All:
		q.Add("carriers", "all")
	default:
		return nil, fmt.Errorf("unsupported carrierGroup: %s", params.CarrierGroup)
	}

	for _, planType := range params.PlanTypes {
		q.Add("plans", string(planType))
	}

	for _, naic := range params.NAICs {
		q.Add("naic", string(naic))
	}

	q.Add("effective_date", params.EffectiveDate.String())

	req.URL.RawQuery = q.Encode()

	// Assign access token
	req.Header.Set("X-API-Key", s.apiKey)
	req.Header.Set("Content-Type", "application/json")

	// Assign context to request
	req = req.WithContext(ctx)

	// Make request
	res, err := s.httpClient.Do(req)
	if err != nil {
		return nil, fmt.Errorf("failed to execute http request: %w", err)
	}
	defer res.Body.Close()

	// Read response body
	body, err := io.ReadAll(res.Body)
	if err != nil {
		return nil, fmt.Errorf("failed to read response body: %w", err)
	}

	switch res.StatusCode {
	case http.StatusOK:
		var carriers []*cgsCarrier
		if err := json.Unmarshal(body, &carriers); err != nil {
			return nil, fmt.Errorf("failed to decode json response body: %w", err)
		}

		// map incoming quote data to domain quotes
		domainQuotes := []*Quote{}
		for _, carrier := range carriers {
			for _, q := range carrier.Quotes {
				var domainQuote Quote
				domainQuote.Carrier.NAIC = common.NAIC(carrier.NAIC)
				domainQuote.Carrier.Name = carrier.CompanyName
				domainQuote.PlanType = PlanType(q.Plan)
				domainQuote.MonthlyRate = currency.Currency(q.Rate) * currency.Cent
				domainQuote.StateAlphaCode = params.StateAlphaCode

				// Apply discount rate to correct discount type
				discountRate := currency.Currency(q.DiscountRate) * currency.Cent

				if len(strings.TrimSpace(q.DiscountCategory)) > 0 {
					discountCatagories := strings.Split(q.DiscountCategory, "/")
					for _, discountCatagory := range discountCatagories {
						discountCatagory = strings.TrimSpace(discountCatagory)
						switch discountCatagory {
						case "Multi-Insured":
							domainQuote.MultiInsuredDiscountMonthlyRate = &discountRate
						case "Roommate":
							domainQuote.LivingWithSomeoneDiscountMonthlyRate = &discountRate
						default:
							return nil, fmt.Errorf("unknown discount category: %s", discountCatagory)
						}
					}
				}

				domainQuotes = append(domainQuotes, &domainQuote)
			}
		}

		// Sort quotes by carrier naic and plan type
		sort.Slice(domainQuotes, func(i, j int) bool {
			if domainQuotes[i].Carrier.NAIC == domainQuotes[j].Carrier.NAIC {
				return domainQuotes[i].PlanType > domainQuotes[j].PlanType
			}
			return domainQuotes[i].Carrier.NAIC > domainQuotes[j].Carrier.NAIC
		})

		// Return quotes
		return domainQuotes, nil

	default:
		return nil, fmt.Errorf("bad response, status code:%d, body:%s", res.StatusCode, string(body))
	}
}

// func (s *CGSQuoteStore) ListByCarrierPlanTypes(ctx context.Context, params sup.ListByCarrierPlanTypesParams) ([]*sup.Quote, error) {
// 	planTypes := set.NewSet[sup.PlanType]()
// 	for _, carrierPlanType := range params.CarrierPlanTypes {
// 		planTypes.Add(carrierPlanType.PlanType)
// 	}

// 	naics := set.NewSet[common.NAIC]()
// 	for _, carrierPlanType := range params.CarrierPlanTypes {
// 		naics.Add(carrierPlanType.CarrierNAIC)
// 	}

// 	quotes, err := s.List(ctx, sup.ListParams{
// 		ZipCode:        params.ZipCode,
// 		CountyName:     params.CountyName,
// 		StateAlphaCode: params.StateAlphaCode,
// 		Age:            params.Age,
// 		Gender:         params.Gender,
// 		IsTobaccoUser:  params.IsTobaccoUser,
// 		PlanTypes:      planTypes.ToSlice(),
// 		EffectiveDate:  params.EffectiveDate,
// 		CarrierGroup:   params.CarrierGroup,
// 		NAICs:          naics.ToSlice(),
// 	})
// 	if err != nil {
// 		return nil, err
// 	}

// 	keys := set.NewSet[string]()
// 	for _, carrierPlanType := range params.CarrierPlanTypes {
// 		key := string(carrierPlanType.CarrierNAIC) + string(carrierPlanType.PlanType)
// 		keys.Add(key)
// 	}

// 	filteredQuotes := []*sup.Quote{}
// 	for _, quote := range quotes {
// 		key := string(quote.Carrier.NAIC) + string(quote.PlanType)
// 		if keys.ContainsOne(key) {
// 			filteredQuotes = append(filteredQuotes, quote)
// 		}
// 	}

// 	return filteredQuotes, nil
// }

type PGQuoteStore struct {
	quoteStore QuoteStore
	db         common.DB
	queries    *sqlc.Queries
}

var _ QuoteStore = new(PGQuoteStore)

func NewPGQuoteStore(store QuoteStore, db common.DB) *PGQuoteStore {
	return &PGQuoteStore{
		quoteStore: store,
		db:         db,
		queries:    sqlc.New(),
	}
}

func (s *PGQuoteStore) List(ctx context.Context, params ListParams) ([]*Quote, error) {
	quotes, err := s.quoteStore.List(ctx, params)
	if err != nil {
		return nil, err
	}

	quotes, err = s.applyPreferredCarriers(ctx, quotes)
	if err != nil {
		return nil, fmt.Errorf("failed to applyPreferredCarriers: %w", err)
	}

	quotes, err = s.applyCarrierLogos(ctx, quotes)
	if err != nil {
		return nil, fmt.Errorf("failed to applyCarrierLogos: %w", err)
	}

	return quotes, nil
}

func (s *PGQuoteStore) applyPreferredCarriers(ctx context.Context, inQuotes []*Quote) ([]*Quote, error) {
	// Return when the quote slice is empty
	if len(inQuotes) == 0 {
		return inQuotes, nil
	}

	stateAlphaCode := string(inQuotes[0].StateAlphaCode)

	preferredCarrierRows, err := s.queries.ListPreferredSupplementalCarriersByStateAlphaCode(ctx, s.db, stateAlphaCode)
	if err != nil {
		return nil, fmt.Errorf("failed to list preferred supplemental carriers by state alpha code: %w", err)
	}

	// Create a set of carrier naic's
	preferredCarriers := set.NewSet[common.NAIC]()
	for _, row := range preferredCarrierRows {
		preferredCarriers.Add(common.NAIC(row.Naic))
	}

	// For each quote with a naic that is in the preferred carrier set, mark as preferred
	quotes := []*Quote{}
	for _, quote := range inQuotes {
		if preferredCarriers.ContainsOne(quote.Carrier.NAIC) {
			quote.Carrier.IsPreferred = true
		}
		quotes = append(quotes, quote)
	}

	return quotes, nil
}

func (s *PGQuoteStore) applyCarrierLogos(ctx context.Context, inQuotes []*Quote) ([]*Quote, error) {
	// Return when the quote slice is empty
	if len(inQuotes) == 0 {
		return inQuotes, nil
	}

	// Collect quote naic's
	naics := make([]string, len(inQuotes))
	for i, quote := range inQuotes {
		naics[i] = string(quote.Carrier.NAIC)
	}

	// List supplemental carrier logos
	logoRows, err := s.queries.ListSupplementalCarrierLogosByNaics(ctx, s.db, naics)
	if err != nil {
		return nil, fmt.Errorf("failed to ListSupplementalCarrierLogosByNaics: %w", err)
	}

	// create a map of naic's and logo keys
	carrierLogos := map[string]string{}
	for _, row := range logoRows {
		carrierLogos[row.CarrierNaic] = row.Key
	}

	quotes := []*Quote{}
	for _, quote := range inQuotes {
		key, ok := carrierLogos[string(quote.Carrier.NAIC)]
		if ok {
			quote.Carrier.LogoKey = &key
		}
		quotes = append(quotes, quote)
	}

	return quotes, nil
}

================
File: internal/domain/sup/sup.go
================
package sup

import (
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/currency"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
)

type QuoteKey string

type PlanType string

const (
	PlanTypeF PlanType = "F"
	PlanTypeG PlanType = "G"
	PlanTypeN PlanType = "N"
)

type CarrierGroup string

const (
	Supported CarrierGroup = "Supported"
	All       CarrierGroup = "All"
)

type Quote struct {
	Carrier                              Carrier
	PlanType                             PlanType
	MonthlyRate                          currency.Currency
	MultiInsuredDiscountMonthlyRate      *currency.Currency
	LivingWithSomeoneDiscountMonthlyRate *currency.Currency
	StateAlphaCode                       geo.StateAlphaCode
}

type Carrier struct {
	NAIC        common.NAIC
	Name        string
	IsPreferred bool
	LogoKey     *string
}

================
File: internal/handlers/frontend/testdata/css/main.css
================
css/main.css

================
File: internal/handlers/frontend/testdata/index.html
================
index.html

================
File: internal/handlers/frontend/testdata/root-main.css
================
root-main.css

================
File: internal/handlers/frontend/frontend_test.go
================
package frontend

import (
	"net/http"
	"net/http/httptest"
	"os"
	"sort"
	"strings"
	"testing"
)

func TestServe(t *testing.T) {
	tt := []struct {
		name       string
		url        string
		statusCode int
		body       string
		headers    string
	}{
		{
			name:       "root path renders index.html",
			url:        "http://www.example.com",
			statusCode: 200,
			body:       "index.html",
			headers:    "Accept-Ranges:bytes Cache-Control:no-cache, no-store, no-transform, must-revalidate, private, max-age=0 Content-Length:11 Content-Type:text/html; charset=utf-8 Expires:Thu, 01 Jan 1970 00:00:00 GMT Pragma:no-cache X-Accel-Expires:0",
		}, {
			name:       "slash path renders index.html",
			url:        "http://www.example.com/",
			statusCode: 200,
			body:       "index.html",
			headers:    "Accept-Ranges:bytes Cache-Control:no-cache, no-store, no-transform, must-revalidate, private, max-age=0 Content-Length:11 Content-Type:text/html; charset=utf-8 Expires:Thu, 01 Jan 1970 00:00:00 GMT Pragma:no-cache X-Accel-Expires:0",
		}, {
			name:       "redirects index.html to root",
			url:        "http://www.example.com/index.html",
			statusCode: 301,
			body:       "",
			headers:    "Location:/",
		}, {
			name:       "redirects index.html to root with query string",
			url:        "http://www.example.com/index.html?key1=value",
			statusCode: 301,
			body:       "",
			headers:    "Location:/?key1=value",
		},
		{
			name:       "serve non index file",
			url:        "http://www.example.com/css/main.css",
			statusCode: 200,
			body:       "css/main.css",
			headers:    "Accept-Ranges:bytes Content-Length:13 Content-Type:text/css; charset=utf-8",
		},
		{
			name:       "serve root non-index file",
			url:        "http://www.example.com/root-main.css",
			statusCode: 200,
			body:       "root-main.css",
			headers:    "Accept-Ranges:bytes Content-Length:14 Content-Type:text/css; charset=utf-8",
		},
		{
			name:       "serves index on file not found",
			url:        "http://www.example.com/doesnotexist.txt",
			statusCode: 200,
			body:       "index.html",
			headers:    "Accept-Ranges:bytes Cache-Control:no-cache, no-store, no-transform, must-revalidate, private, max-age=0 Content-Length:11 Content-Type:text/html; charset=utf-8 Expires:Thu, 01 Jan 1970 00:00:00 GMT Pragma:no-cache X-Accel-Expires:0",
		},
		{
			name:       "serves index on directory listing",
			url:        "http://www.example.com/css/",
			statusCode: 200,
			body:       "index.html",
			headers:    "Accept-Ranges:bytes Cache-Control:no-cache, no-store, no-transform, must-revalidate, private, max-age=0 Content-Length:11 Content-Type:text/html; charset=utf-8 Expires:Thu, 01 Jan 1970 00:00:00 GMT Pragma:no-cache X-Accel-Expires:0",
		},
	}

	for _, tc := range tt {
		t.Run(tc.name, func(t *testing.T) {
			fsys := os.DirFS("testdata")
			h := Serve(fsys)

			r, err := http.NewRequest(http.MethodGet, tc.url, nil)
			if err != nil {
				t.Fatal(err)
			}
			w := httptest.NewRecorder()
			h.ServeHTTP(w, r)

			body := strings.TrimSpace(w.Body.String())
			statusCode := w.Result().StatusCode

			var headers []string
			for k, v := range w.Result().Header {
				if k == "Last-Modified" {
					continue
				}

				valueString := strings.Join(v, ",")
				headers = append(headers, k+":"+valueString)
			}
			sort.StringSlice(headers).Sort()
			headerString := strings.Join(headers, " ")

			if statusCode != tc.statusCode {
				t.Errorf("statusCode expected: %d, got: %d", tc.statusCode, w.Code)
			}

			if body != tc.body {
				t.Errorf("body expected: %s, got: %s", tc.body, body)
			}

			if headerString != tc.headers {
				t.Errorf("headers expected: %s, got: %s", tc.headers, headerString)
			}
		})
	}

}

================
File: internal/handlers/frontend/frontend.go
================
package frontend

import (
	"bytes"
	"io"
	"io/fs"
	"net/http"

	"path"
	"path/filepath"
	"strings"
	"time"
)

const indexPage = "index.html"

// Unix epoch time
var epoch = time.Unix(0, 0).UTC().Format(http.TimeFormat)

// Taken from https://github.com/mytrile/nocache
var noCacheHeaders = map[string]string{
	"Expires":         epoch,
	"Cache-Control":   "no-cache, no-store, no-transform, must-revalidate, private, max-age=0",
	"Pragma":          "no-cache",
	"X-Accel-Expires": "0",
}

var etagHeaders = []string{
	"ETag",
	"If-Modified-Since",
	"If-Match",
	"If-None-Match",
	"If-Range",
	"If-Unmodified-Since",
}

// Serve a single-page application from the filesystem. Requests for `index.html` will be redirected to the root path.
// Requests for the root path or non-existent files will render the `index.html` page. When the index page is rendered,
// headers are set to prevent caching by upstream servers.
func Serve(fsys fs.FS) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		// Normalize and clean the path
		upath := r.URL.Path
		upath = strings.TrimPrefix(upath, "/")
		upath = path.Clean(upath)

		// Serve index page on root path
		if upath == "." {
			serveIndex(fsys, w, r)
			return
		}

		// Redirect to root on /index.html path
		if upath == indexPage {
			localRedirect(w, r, "/")
			return
		}

		// Serve non-index.html file
		f, err := fsys.Open(upath)
		if err != nil {
			serveIndex(fsys, w, r)
			return
		}
		defer f.Close()

		fstat, err := f.Stat()
		if err != nil {
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			return
		}

		// If the path is a directory, display the index html page instead
		if fstat.IsDir() {
			serveIndex(fsys, w, r)
			return
		}

		b, err := io.ReadAll(f)
		if err != nil {
			http.Error(w, http.StatusText(http.StatusInternalServerError), http.StatusInternalServerError)
			return
		}

		http.ServeContent(w, r, filepath.Base(upath), fstat.ModTime(), bytes.NewReader(b))
	})
}

// serveIndex sets headers to prevent caching by upstream servers.
func serveIndex(fsys fs.FS, w http.ResponseWriter, r *http.Request) {
	b, err := fs.ReadFile(fsys, indexPage)
	if err != nil {
		http.Error(w, http.StatusText(http.StatusNotFound), http.StatusNotFound)
		return
	}

	// Delete any ETag headers that may have been set
	for _, v := range etagHeaders {
		if r.Header.Get(v) != "" {
			r.Header.Del(v)
		}
	}

	// Set NoCache headers
	for k, v := range noCacheHeaders {
		w.Header().Set(k, v)
	}

	http.ServeContent(w, r, indexPage, time.Unix(0, 0), bytes.NewReader(b))
}

// localRedirect gives a Moved Permanently response.
// It does not convert relative paths to absolute paths like Redirect does.
func localRedirect(w http.ResponseWriter, r *http.Request, newPath string) {
	if q := r.URL.RawQuery; q != "" {
		newPath += "?" + q
	}
	w.Header().Set("Location", newPath)
	w.WriteHeader(http.StatusMovedPermanently)
}

================
File: internal/handlers/oauth/google/google.go
================
package google

import (
	"crypto/rand"
	"encoding/base64"
	"errors"
	"io"
	"log/slog"
	"net/http"

	"github.com/alexedwards/scs/v2"
	"github.com/coreos/go-oidc/v3/oidc"
	"github.com/go-chi/httplog/v2"
	"github.com/medicareschoolcom/maxquote/internal/config"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/session"
	"golang.org/x/oauth2"
)

const (
	sessionKeyState       = "oauth_google_state"
	sessionKeyNonce       = "oauth_google_nonce"
	sessionKeyRedirectURI = "redirect_uri"
)

func Login(
	c *config.Config,
	provider *oidc.Provider,
	sessionManager *scs.SessionManager,
	logger *httplog.Logger,
) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		state, err := randString(16)
		if err != nil {
			logger.Error("failed to create state random string", slog.Any("error", err))
			http.Error(w, "Internal error", http.StatusInternalServerError)
			return
		}
		nonce, err := randString(16)
		if err != nil {
			logger.Error("failed to create nonce random string", slog.Any("error", err))
			http.Error(w, "Internal error", http.StatusInternalServerError)
			return
		}

		sessionManager.Put(r.Context(), sessionKeyState, state)
		sessionManager.Put(r.Context(), sessionKeyNonce, nonce)
		sessionManager.Put(r.Context(), sessionKeyRedirectURI, r.FormValue("redirect_uri"))

		oauth2Config := newOAuth2Config(c, provider)
		url := oauth2Config.AuthCodeURL(state, oidc.Nonce(nonce))
		http.Redirect(w, r, url, http.StatusFound)
	})
}

func Callback(
	c *config.Config,
	provider *oidc.Provider,
	sessionManager *scs.SessionManager,
	db common.DB,
	agentRepository agent.Store,
	logger *httplog.Logger,
) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		state := sessionManager.PopString(r.Context(), sessionKeyState)
		if state == "" {
			http.Error(w, "state not found", http.StatusBadRequest)
			return
		}
		if r.URL.Query().Get("state") != state {
			http.Error(w, "state did not match", http.StatusBadRequest)
			return
		}

		oauthConfig := newOAuth2Config(c, provider)

		oauth2Token, err := oauthConfig.Exchange(r.Context(), r.URL.Query().Get("code"))
		if err != nil {
			logger.Error("failed to exchange oidc token", slog.Any("error", err))
			http.Error(w, "Internal error", http.StatusInternalServerError)
			return
		}
		rawIDToken, ok := oauth2Token.Extra("id_token").(string)
		if !ok {
			logger.Error("No id_token field in oauth2 token")
			http.Error(w, "Internal error", http.StatusInternalServerError)
			return
		}

		verifier := provider.Verifier(&oidc.Config{
			ClientID: c.OAuth.ClientID,
		})
		idToken, err := verifier.Verify(r.Context(), rawIDToken)
		if err != nil {
			logger.Error("failed to verify ID Token", slog.Any("error", err))
			http.Error(w, "Internal error", http.StatusInternalServerError)
			return
		}

		nonce := sessionManager.PopString(r.Context(), sessionKeyNonce)
		if nonce == "" {
			http.Error(w, "Nonce not found", http.StatusBadRequest)
			return
		}
		if idToken.Nonce != nonce {
			http.Error(w, "Nonce did not match", http.StatusBadRequest)
			return
		}

		var claims struct {
			Email         string `json:"email"`
			EmailVerified bool   `json:"email_verified"`
		}
		if err := idToken.Claims(&claims); err != nil {
			logger.Error("failed to unmarshal ID Token claims", slog.Any("error", err))
			http.Error(w, "Internal error", http.StatusInternalServerError)
			return
		}

		u, err := agentRepository.GetByEmail(r.Context(), db, common.Email(claims.Email))
		if errors.Is(err, agent.ErrAgentNotFound) {
			http.Error(w, http.StatusText(http.StatusUnauthorized), http.StatusUnauthorized)
			return
		}
		if err != nil {
			logger.Error("failed to get user by email", slog.Any("error", err))
			http.Error(w, "Internal error", http.StatusInternalServerError)
			return
		}

		sessionManager.Put(r.Context(), session.KeyAgentID, int64(u.ID))

		redirectURI := sessionManager.PopString(r.Context(), sessionKeyRedirectURI)
		if redirectURI == "" {
			redirectURI = "/"
		}

		http.Redirect(w, r, redirectURI, http.StatusSeeOther)
	})
}

func newOAuth2Config(c *config.Config, provider *oidc.Provider) *oauth2.Config {
	return &oauth2.Config{
		ClientID:     c.OAuth.ClientID,
		ClientSecret: c.OAuth.ClientSecret,
		Endpoint:     provider.Endpoint(),
		RedirectURL:  c.OAuth.RedirectURL,
		Scopes:       []string{oidc.ScopeOpenID, "profile", "email"},
	}
}

func randString(nByte int) (string, error) {
	b := make([]byte, nByte)
	if _, err := io.ReadFull(rand.Reader, b); err != nil {
		return "", err
	}
	return base64.RawURLEncoding.EncodeToString(b), nil
}

================
File: internal/maxquoteserver/dashboard.go
================
package rpc

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"strconv"
	"strings"

	"github.com/alexedwards/scs/v2"
	set "github.com/deckarep/golang-set/v2"
	"github.com/go-chi/httplog/v2"
	"github.com/medicareschoolcom/maxquote/internal/config"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/client"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/dental"
	"github.com/medicareschoolcom/maxquote/internal/domain/drug"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
	"github.com/medicareschoolcom/maxquote/internal/domain/irmaa"
	"github.com/medicareschoolcom/maxquote/internal/domain/quote"
	"github.com/medicareschoolcom/maxquote/internal/domain/sup"
	proto "github.com/medicareschoolcom/maxquote/rpc/maxquote"
)

const searchClientsLimit = 8

type DashboardServer struct {
	db                     common.DB
	logger                 *httplog.Logger
	sessionManager         *scs.SessionManager
	agentStore             agent.Store
	countyStore            geo.CountyStore
	zipCodeCountyStore     geo.ZipCodeCountyStore
	clientStore            client.Store
	irmaaBracketStore      irmaa.BracketStore
	drugQuoteStore         drug.QuoteStore
	supplementalQuoteStore sup.QuoteStore
	dentalQuoteStore       dental.QuoteStore
	quoteStore             quote.Store
	quoteURLIDGen          quote.URLIDGenerator
	quoteEmailNotifier     quote.EmailNotifier
	quoteSMSNotifier       quote.SMSNotifier
	clock                  common.Clock
	config                 *config.Config
}

func NewDashboardServer(
	db common.DB,
	logger *httplog.Logger,
	sessionManager *scs.SessionManager,
	agentStore agent.Store,
	countyStore geo.CountyStore,
	zipCodeCountyStore geo.ZipCodeCountyStore,
	clientStore client.Store,
	irmaaBracketStore irmaa.BracketStore,
	drugQuoteStore drug.QuoteStore,
	supplementalQuoteStore sup.QuoteStore,
	dentalQuoteStore dental.QuoteStore,
	quoteStore quote.Store,
	quoteURLIDGen quote.URLIDGenerator,
	quoteEmailNotifier quote.EmailNotifier,
	quoteSMSNotifier quote.SMSNotifier,
	clock common.Clock,
	config *config.Config,
) *DashboardServer {
	return &DashboardServer{
		db:                     db,
		logger:                 logger,
		sessionManager:         sessionManager,
		agentStore:             agentStore,
		countyStore:            countyStore,
		zipCodeCountyStore:     zipCodeCountyStore,
		clientStore:            clientStore,
		irmaaBracketStore:      irmaaBracketStore,
		drugQuoteStore:         drugQuoteStore,
		supplementalQuoteStore: supplementalQuoteStore,
		dentalQuoteStore:       dentalQuoteStore,
		quoteStore:             quoteStore,
		quoteURLIDGen:          quoteURLIDGen,
		quoteEmailNotifier:     quoteEmailNotifier,
		quoteSMSNotifier:       quoteSMSNotifier,
		clock:                  clock,
		config:                 config,
	}
}

var _ proto.Dashboard = new(DashboardServer)

// Agent

func (s *DashboardServer) WhoAmI(ctx context.Context) (*proto.Agent, error) {
	a, ok := getAgent(ctx)
	if !ok {
		return nil, proto.ErrUnauthorized
	}

	return mapAgentToRPCAgent(a), nil
}

func (s *DashboardServer) SignOut(ctx context.Context) error {
	if err := s.sessionManager.Destroy(ctx); err != nil {
		return s.errInternal(ctx, "failed to destroy session", err)
	}
	return nil
}

// Global search

func (s *DashboardServer) Search(ctx context.Context, searchTerm string) ([]*proto.SearchResult, error) {
	searchTerm = strings.TrimSpace(searchTerm)
	if searchTerm == "" {
		return []*proto.SearchResult{}, nil
	}

	// When the searchTerm is a number, assume it is a Quote ID, and search for a matching quote.
	if quoteID, err := strconv.Atoi(searchTerm); err == nil {
		quote_, err := s.quoteStore.Get(ctx, s.db, quote.ID(quoteID))
		if errors.Is(err, quote.ErrQuoteNotFound) {
			return []*proto.SearchResult{}, nil
		}
		if err != nil {
			return nil, s.errInternal(ctx, "failed to get quote", err)
		}

		client_, err := s.clientStore.Get(ctx, s.db, quote_.ClientID)
		if err != nil {
			return nil, s.errInternal(ctx, "failed clientStore.Get", err)
		}

		results := []*proto.SearchResult{{
			Type:                 proto.SearchResultType_Quote,
			PrimaryDescription:   fmt.Sprintf("%06d", quote_.ID),
			SecondaryDescription: client_.Name.String(),
			Id:                   int64(quote_.ID),
		}}
		return results, nil
	}

	// When the search terms is not a number, assume it is a client name or email, and search for
	// matching clients.
	clients, err := s.clientStore.Search(ctx, s.db, searchTerm, searchClientsLimit)
	if err != nil {
		return nil, s.errInternal(ctx, "failed to search clients", err)
	}

	results := make([]*proto.SearchResult, len(clients))
	for i, client_ := range clients {
		var email string
		if client_.Email != nil {
			email = string(*client_.Email)
		}

		results[i] = &proto.SearchResult{
			Type:                 proto.SearchResultType_Client,
			PrimaryDescription:   client_.Name.String(),
			SecondaryDescription: email,
			Id:                   int64(client_.ID),
		}
	}

	return results, nil
}

// County

func (s *DashboardServer) ListCountiesByZipCode(ctx context.Context, zipCode_ string) ([]*proto.County, error) {
	zipCode, err := geo.NewZipCode(zipCode_)
	if err != nil {
		return nil, s.errInvalidArgument("invalid zipCode")
	}

	zipCodeCounties, err := s.zipCodeCountyStore.ListByZipCode(ctx, s.db, zipCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed zipCodeCountyStore.ListByZipCode", err)
	}

	fipsCodes := make([]geo.CountyFIPSCode, len(zipCodeCounties))
	for i, zipCodeCounty := range zipCodeCounties {
		fipsCodes[i] = zipCodeCounty.CountyFIPSCode
	}

	counties, err := s.countyStore.ListByFIPSCodes(ctx, s.db, fipsCodes)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.ListByFIPSCodes", err)
	}

	view := make([]*proto.County, len(counties))
	for i, county := range counties {
		view[i] = mapCountyToRPCCounty(county)
	}
	return view, nil
}

// Client

func (s *DashboardServer) SearchClients(ctx context.Context, searchTerm string) ([]*proto.Client, error) {
	clients, err := s.clientStore.Search(ctx, s.db, searchTerm, searchClientsLimit)
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Search: %w", err)
	}

	fipsCodes := set.NewSet[geo.CountyFIPSCode]()
	for _, client_ := range clients {
		fipsCodes.Add(client_.CountyFIPSCode)
	}

	counties, err := s.countyStore.ListByFIPSCodes(ctx, s.db, fipsCodes.ToSlice())
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.ListByFIPSCodes: %w", err)
	}

	// View
	today := s.clock.Today()
	views := []*proto.Client{}
	for _, client_ := range clients {
		for _, county := range counties {
			if client_.CountyFIPSCode == county.FIPSCode {
				views = append(views, mapClientToRPCClient(client_, county, today))
				break
			}
		}
	}
	return views, nil
}

func (s *DashboardServer) GetClient(ctx context.Context, id int64) (*proto.Client, error) {
	client_, err := s.clientStore.Get(ctx, s.db, client.ID(id))
	if errors.Is(err, client.ErrClientNotFound) {
		return nil, proto.ErrEntityNotFound
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Get", err)
	}

	county, err := s.countyStore.Get(ctx, s.db, client_.CountyFIPSCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	view := mapClientToRPCClient(client_, county, s.clock.Today())

	return view, nil
}

func (s *DashboardServer) IsClientEmailTaken(ctx context.Context, email_ string, excludedID_ *int64) (bool, error) {
	email, err := common.NewEmail(email_)
	if err != nil {
		return false, s.errInvalidArgument("email invalid")
	}

	client_, err := s.clientStore.GetByEmail(ctx, s.db, email)
	if errors.Is(err, client.ErrClientNotFound) {
		return false, nil
	}
	if err != nil {
		return false, s.errInternal(ctx, "failed clientStore.GetByEmail", err)
	}

	if excludedID_ != nil && client_.ID == client.ID(*excludedID_) {
		return false, nil
	}

	return true, nil
}

func (s *DashboardServer) CreateClient(ctx context.Context, params *proto.CreateClientParams) (*proto.Client, error) {
	tx, err := s.db.Begin(ctx)
	if err != nil {
		return nil, s.errInternal(ctx, "failed to begin transaction", err)
	}
	defer tx.Rollback(ctx)

	id, err := s.clientStore.NextID(ctx, tx)
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.NextID", err)
	}

	name, err := common.NewPersonName(params.FirstName, params.LastName)
	if err != nil {
		return nil, s.errInvalidArgument(err.Error())
	}

	dateOfBirth, err := common.ParseDate(params.DateOfBirth)
	if err != nil {
		return nil, s.errInvalidArgument(err.Error())
	}

	var gender common.Gender
	switch params.Gender {
	case proto.Gender_Male:
		gender = common.GenderMale
	case proto.Gender_Female:
		gender = common.GenderFemale
	default:
		return nil, s.errInvalidArgument("invalid gender")
	}

	zipCode, err := geo.NewZipCode(params.ZipCode)
	if err != nil {
		return nil, s.errInvalidArgument(err.Error())
	}

	countyFipsCode, err := geo.NewCountyFIPSCode(params.CountyFipsCode)
	if err != nil {
		return nil, s.errInvalidArgument(err.Error())
	}

	county, err := s.countyStore.Get(ctx, tx, countyFipsCode)
	if errors.Is(err, geo.ErrCountyNotFound) {
		return nil, s.errInvalidArgument("countyFipsCode invalid")
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	var phone *common.Phone
	if params.Phone != nil {
		p, err := common.NewPhone(*params.Phone)
		if err != nil {
			return nil, s.errInvalidArgument(err.Error())
		}
		phone = &p
	}

	var email *common.Email
	if params.Email != nil {
		e, err := common.NewEmail(*params.Email)
		if err != nil {
			return nil, s.errInvalidArgument(err.Error())
		}
		email = &e
	}

	isTobaccoUser := params.IsTobaccoUser

	now := s.clock.Now()

	client_ := &client.Client{
		ID:             id,
		Name:           name,
		DateOfBirth:    dateOfBirth,
		Gender:         gender,
		ZipCode:        zipCode,
		CountyFIPSCode: county.FIPSCode,
		Phone:          phone,
		Email:          email,
		IsTobaccoUser:  isTobaccoUser,
		CreatedAt:      now,
		UpdatedAt:      now,
	}

	if err := s.clientStore.Store(ctx, tx, client_); err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Store", err)
	}

	err = tx.Commit(ctx)
	if err != nil {
		return nil, s.errInternal(ctx, "failed tx.Commit: %w", err)
	}

	// View
	view := mapClientToRPCClient(client_, county, s.clock.Today())
	return view, nil
}

func (s *DashboardServer) UpdateClient(ctx context.Context, params *proto.UpdateClientParams) (*proto.Client, error) {
	tx, err := s.db.Begin(ctx)
	if err != nil {
		return nil, s.errInternal(ctx, "failed to begin transaction", err)
	}
	defer tx.Rollback(ctx)

	clientID := client.ID(params.Id)

	client_, err := s.clientStore.Get(ctx, tx, clientID)
	if errors.Is(err, client.ErrClientNotFound) {
		return nil, proto.ErrEntityNotFound
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Get", err)
	}

	client_.Name, err = common.NewPersonName(params.FirstName, params.LastName)
	if err != nil {
		return nil, s.errInvalidArgument("invalid name")
	}

	client_.DateOfBirth, err = common.ParseDate(params.DateOfBirth)
	if err != nil {
		return nil, s.errInvalidArgument("invalid date of birth")
	}

	switch params.Gender {
	case proto.Gender_Male:
		client_.Gender = common.GenderMale
	case proto.Gender_Female:
		client_.Gender = common.GenderFemale
	default:
		return nil, s.errInvalidArgument("invalid gender")
	}

	client_.ZipCode, err = geo.NewZipCode(params.ZipCode)
	if err != nil {
		return nil, s.errInvalidArgument("invalid zip code")
	}

	countyFipsCode, err := geo.NewCountyFIPSCode(params.CountyFipsCode)
	if err != nil {
		return nil, s.errInvalidArgument("invalid county fips code")
	}

	county, err := s.countyStore.Get(ctx, tx, countyFipsCode)
	if errors.Is(err, geo.ErrCountyNotFound) {
		return nil, s.errInvalidArgument("county fips code not found")
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	client_.CountyFIPSCode = county.FIPSCode

	if params.Email != nil {
		email, err := common.NewEmail(*params.Email)
		if err != nil {
			return nil, s.errInvalidArgument("invalid email")
		}
		client_.Email = &email
	}

	if params.Phone != nil {
		phone, err := common.NewPhone(*params.Phone)
		if err != nil {
			return nil, s.errInvalidArgument("invalid phone")
		}
		client_.Phone = &phone
	}

	client_.IsTobaccoUser = params.IsTobaccoUser

	client_.UpdatedAt = s.clock.Now()

	if err := s.clientStore.Store(ctx, tx, client_); err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Store", err)
	}

	err = tx.Commit(ctx)
	if err != nil {
		return nil, s.errInternal(ctx, "failed tx.Commit: %w", err)
	}

	// Get view
	view := mapClientToRPCClient(client_, county, s.clock.Today())
	return view, nil
}

// Irmaa bracket

func (s *DashboardServer) ListIrmaaBracketsByEffectiveDate(ctx context.Context, effectiveDate_ string) ([]*proto.IrmaaBracket, error) {
	effectiveDate, err := common.ParseDate(effectiveDate_)
	if err != nil {
		return nil, s.errInvalidArgument("effective date invalid")
	}

	year := effectiveDate.Year()

	irmaaBrackets, err := s.irmaaBracketStore.ListLatestByYear(ctx, s.db, year)
	if err != nil {
		return nil, s.errInternal(ctx, "failed to list recent irmaa brackets by year", err)
	}

	views := make([]*proto.IrmaaBracket, len(irmaaBrackets))
	for i, irmaaBracket := range irmaaBrackets {
		views[i], err = mapIRMAABracketToRPCIRMAABracket(irmaaBracket)
		if err != nil {
			return nil, s.errInternal(ctx, "failed mapIRMAABracketToRPCIRMAABracket", err)
		}
	}

	return views, nil
}

// Drug quote

func (s *DashboardServer) ListDrugQuotesByClientIdAndEffectiveDate(ctx context.Context, clientId_ int64, effectiveDate_ string) ([]*proto.DrugQuote, error) {
	effectiveDate, err := common.ParseDate(effectiveDate_)
	if err != nil {
		return nil, s.errInvalidArgument("effective date invalid")
	}

	clientID := client.ID(clientId_)
	client_, err := s.clientStore.Get(ctx, s.db, clientID)
	if errors.Is(err, client.ErrClientNotFound) {
		return nil, s.errInvalidArgument("client ID not found")
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Get", err)
	}

	clientCounty, err := s.countyStore.Get(ctx, s.db, client_.CountyFIPSCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	drugQuotes, err := s.drugQuoteStore.ListByLatestYearAndState(ctx, s.db, effectiveDate.Year(), clientCounty.StateAlphaCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed to list drug quotes by latest contract year and state alpha code", err)
	}

	drugQuoteViews := make([]*proto.DrugQuote, len(drugQuotes))
	for i, drugQuote := range drugQuotes {
		drugQuoteViews[i] = mapDrugQuoteToRPCDrugQuote(drugQuote)
	}

	return drugQuoteViews, nil
}

// Dental quote

func (s *DashboardServer) ListDentalQuotesByClientId(ctx context.Context, _clientId int64) ([]*proto.DentalQuote, error) {
	client_, err := s.clientStore.Get(ctx, s.db, client.ID(_clientId))
	if errors.Is(err, client.ErrClientNotFound) {
		return nil, proto.ErrEntityNotFound
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Get", err)
	}

	clientCounty, err := s.countyStore.Get(ctx, s.db, client_.CountyFIPSCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	dentalQuotes, err := s.dentalQuoteStore.ListByStateAlphaCode(ctx, s.db, clientCounty.StateAlphaCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed to list dental quotes", err)
	}

	quoteViews := make([]*proto.DentalQuote, len(dentalQuotes))
	for i, quote := range dentalQuotes {
		quoteViews[i] = mapDentalQuoteToRPCDentalQuote(quote)
	}

	return quoteViews, nil
}

// Supplemental quote

func (s *DashboardServer) ListSupplementalQuotesByClientIdAndEffectiveDate(ctx context.Context, clientId_ int64, effectiveDate_ string, plans []proto.SupplementalPlanType, carrierGroup_ proto.CarrierGroup) ([]*proto.SupplementalQuote, error) {
	effectiveDate, err := common.ParseDate(effectiveDate_)
	if err != nil {
		return nil, s.errInvalidArgument("effectiveDate invalid")
	}

	var carrierGroup sup.CarrierGroup
	switch carrierGroup_ {
	case proto.CarrierGroup_Supported:
		carrierGroup = sup.Supported
	case proto.CarrierGroup_All:
		carrierGroup = sup.All
	default:
		return nil, s.errInvalidArgument("carrierGroup invalid")
	}

	planTypes := []sup.PlanType{}
	for _, plan := range plans {
		switch plan {
		case proto.SupplementalPlanType_F:
			planTypes = append(planTypes, sup.PlanTypeF)
		case proto.SupplementalPlanType_G:
			planTypes = append(planTypes, sup.PlanTypeG)
		case proto.SupplementalPlanType_N:
			planTypes = append(planTypes, sup.PlanTypeN)
		}
	}
	if len(planTypes) == 0 {
		return []*proto.SupplementalQuote{}, nil
	}

	clientID := client.ID(clientId_)
	client_, err := s.clientStore.Get(ctx, s.db, clientID)
	if errors.Is(err, client.ErrClientNotFound) {
		return nil, proto.ErrEntityNotFound
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed to get client", err)
	}

	clientCounty, err := s.countyStore.Get(ctx, s.db, client_.CountyFIPSCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	supplementalQuotes, err := s.supplementalQuoteStore.List(ctx, sup.ListParams{
		ZipCode:        client_.ZipCode,
		CountyName:     clientCounty.Name,
		StateAlphaCode: clientCounty.StateAlphaCode,
		Age:            effectiveDate.YearsSince(client_.DateOfBirth.StartOfMonth()), // Special rule: for the entire month of the client's 65th birthday, return sup quotes for age 65 only.
		Gender:         client_.Gender,
		IsTobaccoUser:  client_.IsTobaccoUser,
		PlanTypes:      planTypes,
		EffectiveDate:  effectiveDate,
		CarrierGroup:   carrierGroup,
		NAICs:          []common.NAIC{},
	})
	if err != nil {
		return nil, s.errInternal(ctx, "failed supplementalQuoteStore.List", err)
	}

	views := make([]*proto.SupplementalQuote, len(supplementalQuotes))
	for i, supplementalQuote := range supplementalQuotes {
		views[i] = mapSupplementalQuoteToRPCSupplementalQuote(s.config, supplementalQuote)
	}

	return views, nil
}

func (s *DashboardServer) ListSupplementalQuotesForQuote(ctx context.Context, quoteId int64) ([]*proto.SupplementalQuote, error) {
	quote_, err := s.quoteStore.Get(ctx, s.db, quote.ID(quoteId))
	if errors.Is(err, quote.ErrQuoteNotFound) {
		return nil, proto.ErrEntityNotFound
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed to get quote", err)
	}

	rollingEffectiveDate := quote_.RollingEffectiveDate(s.clock)

	client_, err := s.clientStore.Get(ctx, s.db, quote_.ClientID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Get", err)
	}

	clientCounty, err := s.countyStore.Get(ctx, s.db, client_.CountyFIPSCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	supplementalQuotes, err := s.supplementalQuoteStore.List(ctx, sup.ListParams{
		ZipCode:        client_.ZipCode,
		CountyName:     clientCounty.Name,
		StateAlphaCode: clientCounty.StateAlphaCode,
		Age:            rollingEffectiveDate.YearsSince(client_.DateOfBirth.StartOfMonth()), // Special rule: for the entire month of the client's 65th birthday, return sup quotes for age 65 only.
		Gender:         client_.Gender,
		IsTobaccoUser:  client_.IsTobaccoUser,
		EffectiveDate:  rollingEffectiveDate,
		CarrierGroup:   sup.Supported,
		PlanTypes:      quote_.SupplementalPlanTypes(),
		NAICs:          quote_.SupplementalCarrierNAICS(),
	})
	if err != nil {
		return nil, s.errInternal(ctx, "failed supplementalQuoteStore.List", err)
	}

	views := []*proto.SupplementalQuote{}
	for _, supplementalQuote := range supplementalQuotes {
		for _, supPlan := range quote_.SupplementalCarrierPlanTypes {
			if supPlan.CarrierNAIC == supplementalQuote.Carrier.NAIC && supPlan.PlanType == supplementalQuote.PlanType {
				view := mapSupplementalQuoteToRPCSupplementalQuote(s.config, supplementalQuote)
				views = append(views, view)
				break
			}
		}
	}
	return views, nil
}

// Quote

func (s *DashboardServer) ListQuotes(ctx context.Context, params *proto.ListQuotesParams) (*proto.ListQuotesResponse, error) {
	limit := params.Limit
	if limit > 100 {
		limit = 100
	} else if limit < 1 {
		limit = 1
	}

	queryLimit := limit + 1

	agent_, ok := getAgent(ctx)
	if !ok {
		return nil, proto.ErrUnauthorized
	}

	listParams := quote.ListParams{AgentID: &agent_.ID, Limit: queryLimit}
	if params.StartingAfter != nil {
		listParams.StartingAfterID = (*quote.ID)(params.StartingAfter)
	} else if params.EndingBefore != nil {
		listParams.EndingBeforeID = (*quote.ID)(params.EndingBefore)
	}

	quotes, err := s.quoteStore.List(ctx, s.db, listParams)
	if err != nil {
		return nil, s.errInternal(ctx, "failed quoteStore.List", err)
	}

	totalCount, err := s.quoteStore.Count(ctx, s.db, quote.CountParams{AgentID: &agent_.ID})
	if err != nil {
		return nil, s.errInternal(ctx, "failed to count quotes", err)
	}

	hasMore := false
	if len(quotes) > int(limit) {
		hasMore = true
		quotes = quotes[:len(quotes)-1]
	}

	// Get associated clients
	var clientIDS []client.ID
	for _, quote_ := range quotes {
		clientIDS = append(clientIDS, quote_.ClientID)
	}

	clients, err := s.clientStore.ListByIDS(ctx, s.db, clientIDS)
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.ListByIDS", err)
	}

	// Get associated client counties
	var countyFipsCodes []geo.CountyFIPSCode
	for _, client_ := range clients {
		countyFipsCodes = append(countyFipsCodes, client_.CountyFIPSCode)
	}

	clientCounties, err := s.countyStore.ListByFIPSCodes(ctx, s.db, countyFipsCodes)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.ListByFIPSCodes", err)
	}

	// Build response
	today := s.clock.Today()
	var quoteViews []*proto.ShortQuote
	for _, quote_ := range quotes {
	clientLoop:
		for _, client_ := range clients {
			for _, clientCounty := range clientCounties {
				if quote_.ClientID == client_.ID && client_.CountyFIPSCode == clientCounty.FIPSCode {
					quoteView := mapQuoteToRPCShortQuote(quote_, agent_, client_, clientCounty, today)
					quoteViews = append(quoteViews, quoteView)
					break clientLoop
				}
			}
		}
	}

	response := &proto.ListQuotesResponse{
		Data:       quoteViews,
		TotalCount: int32(totalCount),
		HasMore:    hasMore,
	}

	return response, nil
}

func (s *DashboardServer) GetQuote(ctx context.Context, id int64) (*proto.Quote, error) {
	// Get quote
	quoteID := quote.ID(id)
	quote_, err := s.quoteStore.Get(ctx, s.db, quoteID)
	if errors.Is(err, quote.ErrQuoteNotFound) {
		return nil, proto.ErrEntityNotFound
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed quoteStore.Get", err)
	}

	rollingEffectiveDate := quote_.RollingEffectiveDate(s.clock)

	// Important! Agents can only view their own quotes.
	agent_, ok := getAgent(ctx)
	if !ok {
		return nil, proto.ErrUnauthorized
	}
	if quote_.AgentID != agent_.ID {
		return nil, proto.ErrEntityNotFound
	}

	// Get client
	client_, err := s.clientStore.Get(ctx, s.db, quote_.ClientID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Get", err)
	}

	// Get client county
	clientCounty, err := s.countyStore.Get(ctx, s.db, client_.CountyFIPSCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	// Get effective irmaa bracket
	irmaaBracket, err := s.irmaaBracketStore.Get(ctx, s.db, quote_.IrmaaBracketID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed irmaaBracketStore.Get", err)
	}

	effectiveIRMAABracket, err := s.irmaaBracketStore.GetEffective(ctx, s.db, rollingEffectiveDate.Year(), irmaaBracket.FilingType, irmaaBracket.Average())
	if err != nil {
		return nil, s.errInternal(ctx, "failed irmaaBracketStore.GetEffective", err)
	}

	// Get effective drug quote
	var effectiveDrugQuote *drug.Quote
	if quote_.DrugQuoteID != nil {
		drugQuote, err := s.drugQuoteStore.Get(ctx, s.db, *quote_.DrugQuoteID)
		if err != nil {
			return nil, s.errInternal(ctx, "failed drugQuoteStore.Get", err)
		}

		effectiveDrugQuote_, err := s.drugQuoteStore.GetEffective(ctx, s.db, rollingEffectiveDate.Year(), drugQuote.ContractID, drugQuote.PlanID, clientCounty.StateAlphaCode)
		if errors.Is(err, drug.ErrQuoteNotFound) {
			// Do nothing. This is okay
		} else if err != nil {
			return nil, s.errInternal(ctx, "failed drugQuoteStore.GetEffective", err)
		} else {
			effectiveDrugQuote = effectiveDrugQuote_
		}
	}

	// Get effective dental quote
	var effectiveDentalQuote *dental.Quote
	if quote_.DentalQuoteID != nil {
		dentalQuote, err := s.dentalQuoteStore.Get(ctx, s.db, *quote_.DentalQuoteID)
		if err != nil {
			return nil, s.errInternal(ctx, "failed dentalQuoteStore.Get", err)
		}
		effectiveDentalQuote_, err := s.dentalQuoteStore.GetEffective(ctx, s.db, dentalQuote.CarrierNaic, dentalQuote.AnnualBenefit, clientCounty.StateAlphaCode)
		if errors.Is(err, dental.ErrQuoteNotFound) {
			// Do nothing. This is okay
		} else if err != nil {
			return nil, s.errInternal(ctx, "failed dentalQuoteStore.GetEffective", err)
		} else {
			effectiveDentalQuote = effectiveDentalQuote_
		}
	}

	view, err := mapQuoteToRPCQuote(rollingEffectiveDate, quote_, agent_, client_, clientCounty, effectiveIRMAABracket, effectiveDrugQuote, effectiveDentalQuote, s.clock.Today())
	if err != nil {
		return nil, s.errInternal(ctx, "failed mapDomainQuoteToView", err)
	}

	return view, nil
}

func (s *DashboardServer) GetSpouseQuote(ctx context.Context, id int64) (*proto.Quote, error) {
	quote_, err := s.quoteStore.GetByParentID(ctx, s.db, quote.ID(id))
	if errors.Is(err, quote.ErrQuoteNotFound) {
		return nil, proto.ErrEntityNotFound
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed quoteStore.Get", err)
	}

	view, err := s.GetQuote(ctx, int64(quote_.ID))
	if err != nil {
		return nil, err
	}

	view.ParentId = (*int64)(&quote_.ID)

	return view, nil
}

func (s *DashboardServer) CreateQuote(ctx context.Context, clientParams *proto.CreateQuoteParams, spouseParams *proto.CreateQuoteParams) (*proto.Quote, error) {
	tx, err := s.db.Begin(ctx)
	if err != nil {
		return nil, s.errInternal(ctx, "failed to begin transaction", err)
	}
	defer tx.Rollback(ctx)

	agent_, ok := getAgent(ctx)
	if !ok {
		return nil, proto.ErrUnauthorized
	}

	//
	// STORE CLIENT QUOTE
	//

	var clientQuote *quote.Quote
	{
		id, err := s.quoteStore.NextID(ctx, tx)
		if err != nil {
			return nil, s.errInternal(ctx, "failed quoteStore.NextID", err)
		}

		urlID, err := s.quoteURLIDGen.Generate()
		if err != nil {
			return nil, s.errInternal(ctx, "failed quoteURLIDGen.Generate", err)
		}

		client_, err := s.clientStore.Get(ctx, tx, client.ID(clientParams.ClientId))
		if errors.Is(err, client.ErrClientNotFound) {
			return nil, s.errInvalidArgument("clientquote clientID invalid")
		}
		if err != nil {
			return nil, s.errInternal(ctx, "failed clientStore.Get", err)
		}

		effectiveDate, err := common.ParseDate(clientParams.EffectiveDate)
		if err != nil {
			return nil, s.errInvalidArgument("clientquote effectiveDate invalid")
		}

		irmaaBracket, err := s.irmaaBracketStore.Get(ctx, tx, irmaa.BracketID(clientParams.IrmaaBracketId))
		if errors.Is(err, irmaa.ErrBracketNotFound) {
			return nil, s.errInvalidArgument("clientquote irmaaBracketId invalid")
		}
		if err != nil {
			return nil, s.errInternal(ctx, "failed irmaaBracketStore.Get", err)
		}

		now := s.clock.Now()

		quote_ := quote.New(id, urlID, agent_.ID, client_.ID, effectiveDate, irmaaBracket.ID, now)

		if clientParams.DrugQuoteId != nil {
			drugQuote, err := s.drugQuoteStore.Get(ctx, tx, drug.QuoteID(*clientParams.DrugQuoteId))
			if errors.Is(err, drug.ErrQuoteNotFound) {
				return nil, s.errInvalidArgument("clientquote drugQuoteId invalid")
			}
			if err != nil {
				return nil, s.errInternal(ctx, "failed drugQuoteStore.Get", err)
			}

			quote_.DrugQuoteID = &drugQuote.ID
		}

		if clientParams.DentalQuoteId != nil {
			dentalQuote, err := s.dentalQuoteStore.Get(ctx, tx, dental.QuoteID(*clientParams.DentalQuoteId))
			if errors.Is(err, drug.ErrQuoteNotFound) {
				return nil, s.errInvalidArgument("clientquote dentalQuoteId invalid")
			}
			if err != nil {
				return nil, s.errInternal(ctx, "failed dentalQuoteStore.Get", err)
			}

			quote_.DentalQuoteID = &dentalQuote.ID
		}

		quote_.HasMultiInsuredDiscount = clientParams.HasMultiInsuredDiscount
		quote_.HasLivingWithSomeoneDiscount = clientParams.HasLivingWithSomeoneDiscount

		for _, cupplementalCarrierPlanTypes := range clientParams.SupplementalCarrierPlanTypes {

			carrierNAIC := common.NAIC(cupplementalCarrierPlanTypes.CarrierNaic)

			var planType sup.PlanType
			switch cupplementalCarrierPlanTypes.PlanType {
			case proto.SupplementalPlanType_F:
				planType = sup.PlanTypeF
			case proto.SupplementalPlanType_G:
				planType = sup.PlanTypeG
			case proto.SupplementalPlanType_N:
				planType = sup.PlanTypeN
			default:
				return nil, s.errInvalidArgument(fmt.Sprintf("invalid supplemental plan type: %s", cupplementalCarrierPlanTypes.PlanType))
			}

			quoteSupCarrierPlanType := quote.SupplementalCarrierPlanType{
				CarrierNAIC: carrierNAIC,
				PlanType:    planType,
			}

			quote_.SupplementalCarrierPlanTypes = append(quote_.SupplementalCarrierPlanTypes, quoteSupCarrierPlanType)
		}

		if err := s.quoteStore.Store(ctx, tx, quote_); err != nil {
			return nil, s.errInternal(ctx, "failed to store client quote", err)
		}

		clientQuote = quote_
	}

	//
	// STORE SPOUSE QUOTE
	//

	if spouseParams != nil {
		id, err := s.quoteStore.NextID(ctx, tx)
		if err != nil {
			return nil, s.errInternal(ctx, "failed quoteStore.NextID", err)
		}

		urlID, err := s.quoteURLIDGen.Generate()
		if err != nil {
			return nil, s.errInternal(ctx, "failed quoteURLIDGen.Generate", err)
		}

		client_, err := s.clientStore.Get(ctx, tx, client.ID(spouseParams.ClientId))
		if errors.Is(err, client.ErrClientNotFound) {
			return nil, s.errInvalidArgument("spouseQuote clientID invalid")
		}
		if err != nil {
			return nil, s.errInternal(ctx, "failed clientStore.Get", err)
		}

		effectiveDate, err := common.ParseDate(spouseParams.EffectiveDate)
		if err != nil {
			return nil, s.errInvalidArgument("spouseQuote effectiveDate invalid")
		}

		irmaaBracket, err := s.irmaaBracketStore.Get(ctx, tx, irmaa.BracketID(spouseParams.IrmaaBracketId))
		if errors.Is(err, irmaa.ErrBracketNotFound) {
			return nil, s.errInvalidArgument("spouseQuote irmaaBracketId invalid")
		}
		if err != nil {
			return nil, s.errInternal(ctx, "failed irmaaBracketStore.Get", err)
		}

		now := s.clock.Now()

		quote_ := quote.New(id, urlID, agent_.ID, client_.ID, effectiveDate, irmaaBracket.ID, now)

		quote_.ParentID = &clientQuote.ID

		if spouseParams.DrugQuoteId != nil {
			drugQuote, err := s.drugQuoteStore.Get(ctx, tx, drug.QuoteID(*spouseParams.DrugQuoteId))
			if errors.Is(err, drug.ErrQuoteNotFound) {
				return nil, s.errInvalidArgument("spouseQuote drugQuoteId invalid")
			}
			if err != nil {
				return nil, s.errInternal(ctx, "failed drugQuoteStore.Get", err)
			}

			quote_.DrugQuoteID = &drugQuote.ID
		}

		if spouseParams.DentalQuoteId != nil {
			dentalQuote, err := s.dentalQuoteStore.Get(ctx, tx, dental.QuoteID(*spouseParams.DentalQuoteId))
			if errors.Is(err, drug.ErrQuoteNotFound) {
				return nil, s.errInvalidArgument("spouseQuote dentalQuoteId invalid")
			}
			if err != nil {
				return nil, s.errInternal(ctx, "failed dentalQuoteStore.Get", err)
			}

			quote_.DentalQuoteID = &dentalQuote.ID
		}

		quote_.HasMultiInsuredDiscount = spouseParams.HasMultiInsuredDiscount
		quote_.HasLivingWithSomeoneDiscount = spouseParams.HasLivingWithSomeoneDiscount

		for _, cupplementalCarrierPlanTypes := range spouseParams.SupplementalCarrierPlanTypes {

			carrierNAIC := common.NAIC(cupplementalCarrierPlanTypes.CarrierNaic)

			var planType sup.PlanType
			switch cupplementalCarrierPlanTypes.PlanType {
			case proto.SupplementalPlanType_F:
				planType = sup.PlanTypeF
			case proto.SupplementalPlanType_G:
				planType = sup.PlanTypeG
			case proto.SupplementalPlanType_N:
				planType = sup.PlanTypeN
			default:
				return nil, s.errInvalidArgument(fmt.Sprintf("invalid supplemental plan type: %s", cupplementalCarrierPlanTypes.PlanType))
			}

			quoteSupCarrierPlanType := quote.SupplementalCarrierPlanType{
				CarrierNAIC: carrierNAIC,
				PlanType:    planType,
			}

			quote_.SupplementalCarrierPlanTypes = append(quote_.SupplementalCarrierPlanTypes, quoteSupCarrierPlanType)
		}

		if err := s.quoteStore.Store(ctx, tx, quote_); err != nil {
			return nil, s.errInternal(ctx, "failed to store spouse quote", err)
		}
	}

	//
	//  COMMIT & RESPONSE
	//
	if err := tx.Commit(ctx); err != nil {
		return nil, s.errInternal(ctx, "failed to commit transaction", err)
	}

	return s.GetQuote(ctx, int64(clientQuote.ID))
}

func (s *DashboardServer) UpdateQuote(ctx context.Context, clientParams *proto.UpdateQuoteParams, spouseParams *proto.UpdateSpouseQuoteParams) (*proto.Quote, error) {
	//
	//  TRANSACTION BEGIN
	//

	tx, err := s.db.Begin(ctx)
	if err != nil {
		return nil, s.errInternal(ctx, "failed to begin transaction", err)
	}
	defer tx.Rollback(ctx)

	agent_, ok := getAgent(ctx)
	if !ok {
		return nil, proto.ErrUnauthorized
	}

	//
	// UPDATE CLIENT QUOTE
	//

	{
		// GET quote
		quoteID := quote.ID(clientParams.Id)
		quote_, err := s.quoteStore.Get(ctx, tx, quoteID)
		if errors.Is(err, quote.ErrQuoteNotFound) {
			return nil, proto.ErrEntityNotFound
		}
		if err != nil {
			return nil, s.errInternal(ctx, "[client] failed quoteStore.Get", err)
		}

		// Authorize agent for quote
		if quote_.AgentID != agent_.ID {
			return nil, proto.ErrEntityNotFound
		}

		// Update effectiveDate
		quote_.EffectiveDate, err = common.ParseDate(clientParams.EffectiveDate)
		if err != nil {
			return nil, s.errInvalidArgument("[client] effectiveDate invalid")
		}

		// Update clientID
		client_, err := s.clientStore.Get(ctx, tx, client.ID(clientParams.ClientId))
		if errors.Is(err, client.ErrClientNotFound) {
			return nil, s.errInvalidArgument("clientquote clientId invalid")
		}
		if err != nil {
			return nil, s.errInternal(ctx, "[client] failed clientStore.Get", err)
		}
		quote_.ClientID = client_.ID

		// Update irmaaBracketID
		irmaaBracket, err := s.irmaaBracketStore.Get(ctx, tx, irmaa.BracketID(clientParams.IrmaaBracketId))
		if errors.Is(err, irmaa.ErrBracketNotFound) {
			return nil, s.errInvalidArgument("[client] irmaaBracketId invalid")
		}
		if err != nil {
			return nil, s.errInternal(ctx, "[client] failed irmaaBracketStore.Get", err)
		}
		quote_.IrmaaBracketID = irmaaBracket.ID

		// Update drugQuoteID
		if clientParams.DrugQuoteId != nil {
			drugQuote, err := s.drugQuoteStore.Get(ctx, tx, drug.QuoteID(*clientParams.DrugQuoteId))
			if errors.Is(err, drug.ErrQuoteNotFound) {
				return nil, s.errInvalidArgument("[client] drugQuoteId invalid")
			}
			if err != nil {
				return nil, s.errInternal(ctx, "[client] failed drugQuoteStore.Get", err)
			}

			quote_.DrugQuoteID = &drugQuote.ID
		}

		// Update dentalQuoteID
		if clientParams.DentalQuoteId != nil {
			dentalQuote, err := s.dentalQuoteStore.Get(ctx, tx, dental.QuoteID(*clientParams.DentalQuoteId))
			if errors.Is(err, drug.ErrQuoteNotFound) {
				return nil, s.errInvalidArgument("[client] dentalQuoteId invalid")
			}
			if err != nil {
				return nil, s.errInternal(ctx, "[client] failed dentalQuoteStore.Get", err)
			}

			quote_.DentalQuoteID = &dentalQuote.ID
		}

		// Update supplementalCarrierPlanTypes
		quote_.SupplementalCarrierPlanTypes = []quote.SupplementalCarrierPlanType{}
		for _, supplementalCarrierPlanTypes := range clientParams.SupplementalCarrierPlanTypes {

			carrierNAIC := common.NAIC(supplementalCarrierPlanTypes.CarrierNaic)

			var planType sup.PlanType
			switch supplementalCarrierPlanTypes.PlanType {
			case proto.SupplementalPlanType_F:
				planType = sup.PlanTypeF
			case proto.SupplementalPlanType_G:
				planType = sup.PlanTypeG
			case proto.SupplementalPlanType_N:
				planType = sup.PlanTypeN
			default:
				return nil, s.errInvalidArgument(fmt.Sprintf("[client] invalid supplemental plan type: %s", supplementalCarrierPlanTypes.PlanType))
			}

			quoteSupCarrierPlanType := quote.SupplementalCarrierPlanType{
				CarrierNAIC: carrierNAIC,
				PlanType:    planType,
			}

			quote_.SupplementalCarrierPlanTypes = append(quote_.SupplementalCarrierPlanTypes, quoteSupCarrierPlanType)
		}

		// Update discounts
		quote_.HasMultiInsuredDiscount = clientParams.HasMultiInsuredDiscount
		quote_.HasLivingWithSomeoneDiscount = clientParams.HasLivingWithSomeoneDiscount

		// Update timestamp
		quote_.UpdatedAt = s.clock.Now()

		// Store quote
		if err := s.quoteStore.Store(ctx, tx, quote_); err != nil {
			return nil, s.errInternal(ctx, "[client] failed quoteStore.Store", err)
		}
	}

	//
	// SPOUSE QUOTE
	//

	if spouseParams == nil {

		//
		// DELETE EXISTING SPOUSE QUOTE
		//

		quote_, err := s.quoteStore.GetByParentID(ctx, tx, quote.ID(clientParams.Id))
		if errors.Is(err, quote.ErrQuoteNotFound) {
			// Do nothing. There is no spouse quote to delete
		} else if err != nil {
			return nil, s.errInternal(ctx, "[spouse] failed quoteStore.GetByParentID", err)
		} else {
			err = s.quoteStore.Delete(ctx, tx, quote_.ID)
			if err != nil {
				return nil, s.errInternal(ctx, "[spouse] failed quoteStore.Delete", err)
			}
		}

	} else {

		//
		// UPDATE/CREATE SPOUSE QUOTE
		//

		// GET quote
		quote_, err := s.quoteStore.GetByParentID(ctx, tx, quote.ID(clientParams.Id))
		if errors.Is(err, quote.ErrQuoteNotFound) {
			// Create new quote.
			// An existing quote does not yet exist.
			quote_ = &quote.Quote{}
			quote_.ID, err = s.quoteStore.NextID(ctx, tx)
			if err != nil {
				return nil, s.errInternal(ctx, "[spouse] failed quoteStore.NextID", err)
			}
			quote_.URLID, err = s.quoteURLIDGen.Generate()
			if err != nil {
				return nil, s.errInternal(ctx, "[spouse] failed quoteURLIDGen.Generate", err)
			}
			parentID := quote.ID(clientParams.Id)
			quote_.ParentID = &parentID
			quote_.AgentID = agent_.ID
			quote_.CreatedAt = s.clock.Now()

		} else if err != nil {
			return nil, s.errInternal(ctx, "[spouse] failed quoteStore.Get", err)
		}

		// Authorize agent for quote
		if quote_.AgentID != agent_.ID {
			return nil, proto.ErrEntityNotFound
		}

		// Update effectiveDate
		quote_.EffectiveDate, err = common.ParseDate(spouseParams.EffectiveDate)
		if err != nil {
			return nil, s.errInvalidArgument("[spouse] effectiveDate invalid")
		}

		// Update clientID
		client_, err := s.clientStore.Get(ctx, tx, client.ID(spouseParams.ClientId))
		if errors.Is(err, client.ErrClientNotFound) {
			return nil, s.errInvalidArgument("[spouse] spousequote clientId invalid")
		}
		if err != nil {
			return nil, s.errInternal(ctx, "[spouse] failed clientStore.Get", err)
		}
		quote_.ClientID = client_.ID

		// Update irmaaBracketID
		irmaaBracket, err := s.irmaaBracketStore.Get(ctx, tx, irmaa.BracketID(spouseParams.IrmaaBracketId))
		if errors.Is(err, irmaa.ErrBracketNotFound) {
			return nil, s.errInvalidArgument("[spouse] irmaaBracketId invalid")
		}
		if err != nil {
			return nil, s.errInternal(ctx, "[spouse] failed irmaaBracketStore.Get", err)
		}
		quote_.IrmaaBracketID = irmaaBracket.ID

		// Update drugQuoteID
		if spouseParams.DrugQuoteId != nil {
			drugQuote, err := s.drugQuoteStore.Get(ctx, tx, drug.QuoteID(*spouseParams.DrugQuoteId))
			if errors.Is(err, drug.ErrQuoteNotFound) {
				return nil, s.errInvalidArgument("[spouse] drugQuoteId invalid")
			}
			if err != nil {
				return nil, s.errInternal(ctx, "[spouse] failed drugQuoteStore.Get", err)
			}

			quote_.DrugQuoteID = &drugQuote.ID
		}

		// Update dentalQuoteID
		if spouseParams.DentalQuoteId != nil {
			dentalQuote, err := s.dentalQuoteStore.Get(ctx, tx, dental.QuoteID(*spouseParams.DentalQuoteId))
			if errors.Is(err, drug.ErrQuoteNotFound) {
				return nil, s.errInvalidArgument("[spouse] dentalQuoteId invalid")
			}
			if err != nil {
				return nil, s.errInternal(ctx, "[spouse] failed dentalQuoteStore.Get", err)
			}

			quote_.DentalQuoteID = &dentalQuote.ID
		}

		// Update supplementalCarrierPlanTypes
		quote_.SupplementalCarrierPlanTypes = []quote.SupplementalCarrierPlanType{}
		for _, supplementalCarrierPlanTypes := range spouseParams.SupplementalCarrierPlanTypes {

			carrierNAIC := common.NAIC(supplementalCarrierPlanTypes.CarrierNaic)

			var planType sup.PlanType
			switch supplementalCarrierPlanTypes.PlanType {
			case proto.SupplementalPlanType_F:
				planType = sup.PlanTypeF
			case proto.SupplementalPlanType_G:
				planType = sup.PlanTypeG
			case proto.SupplementalPlanType_N:
				planType = sup.PlanTypeN
			default:
				return nil, s.errInvalidArgument(fmt.Sprintf("[spouse] invalid supplemental plan type: %s", supplementalCarrierPlanTypes.PlanType))
			}

			quoteSupCarrierPlanType := quote.SupplementalCarrierPlanType{
				CarrierNAIC: carrierNAIC,
				PlanType:    planType,
			}

			quote_.SupplementalCarrierPlanTypes = append(quote_.SupplementalCarrierPlanTypes, quoteSupCarrierPlanType)
		}

		// Update discounts
		quote_.HasMultiInsuredDiscount = spouseParams.HasMultiInsuredDiscount
		quote_.HasLivingWithSomeoneDiscount = spouseParams.HasLivingWithSomeoneDiscount

		// Update timestamp
		quote_.UpdatedAt = s.clock.Now()

		// Store quote
		if err := s.quoteStore.Store(ctx, tx, quote_); err != nil {
			return nil, s.errInternal(ctx, "[spouse] failed quoteStore.Store", err)
		}
	}

	//
	//  TRANSACTION COMMIT
	//
	if err := tx.Commit(ctx); err != nil {
		return nil, s.errInternal(ctx, "failed to commit transaction", err)
	}

	return s.GetQuote(ctx, clientParams.Id)
}

func (s *DashboardServer) SendQuote(ctx context.Context, id int64, emailOrPhone string) error {
	quoteID := quote.ID(id)
	quote_, err := s.quoteStore.Get(ctx, s.db, quoteID)
	if errors.Is(err, quote.ErrQuoteNotFound) {
		return proto.ErrEntityNotFound
	}
	if err != nil {
		return s.errInternal(ctx, "failed quoteStore.Get", err)
	}

	// Authorize agent for this quote
	agent_, ok := getAgent(ctx)
	if !ok {
		return proto.ErrUnauthorized
	}
	if quote_.AgentID != agent_.ID {
		return proto.ErrEntityNotFound
	}

	email, emailErr := common.NewEmail(emailOrPhone)
	phone, phoneErr := common.NewPhone(emailOrPhone)

	if emailErr == nil {
		if err := s.quoteEmailNotifier.SendQuote(ctx, quote_, agent_, email); err != nil {
			return s.errInternal(ctx, "failed to send quote by email", err)
		}
	} else if phoneErr == nil {
		if err := s.quoteSMSNotifier.SendQuote(ctx, quote_, agent_, phone); err != nil {
			return s.errInternal(ctx, "failed to send quote by text", err)
		}
	} else {
		return s.errInvalidArgument("email or phone invalid")
	}

	return nil
}

// Internal

func (s *DashboardServer) errInternal(ctx context.Context, message string, err error) proto.WebRPCError {
	s.logger.ErrorContext(ctx, message, slog.Any("error", err))
	return proto.ErrInternal
}

func (s *DashboardServer) errInvalidArgument(message string) proto.WebRPCError {
	rpcErr := proto.ErrInvalidArgument
	rpcErr.Message = message
	return rpcErr
}

================
File: internal/maxquoteserver/mapping.go
================
package rpc

import (
	"fmt"

	"github.com/medicareschoolcom/maxquote/internal/config"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/client"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/dental"
	"github.com/medicareschoolcom/maxquote/internal/domain/drug"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
	"github.com/medicareschoolcom/maxquote/internal/domain/irmaa"
	"github.com/medicareschoolcom/maxquote/internal/domain/quote"
	"github.com/medicareschoolcom/maxquote/internal/domain/sup"
	proto "github.com/medicareschoolcom/maxquote/rpc/maxquote"
)

func mapAgentToRPCAgent(a *agent.Agent) *proto.Agent {
	return &proto.Agent{
		Id:        int64(a.ID),
		FirstName: a.Name.First,
		LastName:  a.Name.Last,
		Email:     string(a.Email),
		Phone:     string(a.Phone),
		PhoneExt:  (*int32)(a.PhoneExt),
		CreatedAt: a.CreatedAt,
		UpdatedAt: a.UpdatedAt,
	}
}

func mapCountyToRPCCounty(county *geo.County) *proto.County {
	var view proto.County
	view.FipsCode = string(county.FIPSCode)
	view.Name = string(county.Name)
	view.StateAlphaCode = string(county.StateAlphaCode)
	return &view
}

func mapClientToRPCClient(client_ *client.Client, county *geo.County, today common.Date) *proto.Client {
	var view proto.Client
	view.Id = int64(client_.ID)
	view.FirstName = client_.Name.First
	view.LastName = client_.Name.Last
	view.DateOfBirth = client_.DateOfBirth.String()
	view.Age = int32(today.YearsSince(client_.DateOfBirth))
	view.Gender = proto.Gender(client_.Gender)
	view.ZipCode = string(client_.ZipCode)
	view.County = &proto.County{}
	view.County.FipsCode = string(county.FIPSCode)
	view.County.Name = string(county.Name)
	view.County.StateAlphaCode = string(county.StateAlphaCode)
	if client_.Email != nil {
		view.Email = (*string)(client_.Email)
	}
	if client_.Phone != nil {
		view.Phone = (*string)(client_.Phone)
	}
	view.IsTobaccoUser = client_.IsTobaccoUser
	view.CreatedAt = client_.CreatedAt
	view.UpdatedAt = client_.UpdatedAt
	return &view
}

func mapDentalQuoteToRPCDentalQuote(q *dental.Quote) *proto.DentalQuote {
	return &proto.DentalQuote{
		Id:                 int64(q.ID),
		StateAlphaCode:     string(q.StateAlphaCode),
		CarrierNaic:        string(q.CarrierNaic),
		CarrierName:        q.CarrierName,
		AnnualBenefitCents: q.AnnualBenefit.Cents(),
		MonthlyRateCents:   q.MonthlyRate.Cents(),
	}
}

func mapDrugQuoteToRPCDrugQuote(q *drug.Quote) *proto.DrugQuote {
	return &proto.DrugQuote{
		Id:               int64(q.ID),
		ContractYear:     int32(q.ContractYear),
		ContractId:       string(q.ContractID),
		PlanId:           int32(q.PlanID),
		StateAlphaCode:   string(q.StateAlphaCode),
		CompanyName:      string(q.CompanyName),
		PlanName:         string(q.PlanName),
		MonthlyRateCents: q.MonthlyRate.Cents(),
	}
}

func mapIRMAABracketToRPCIRMAABracket(irmaaBracket *irmaa.Bracket) (*proto.IrmaaBracket, error) {
	var view proto.IrmaaBracket
	view.Id = int64(irmaaBracket.ID)
	view.Year = int32(irmaaBracket.Year)

	switch irmaaBracket.FilingType {
	case irmaa.IndividualFiling:
		view.FilingType = proto.FilingType_Individual
	case irmaa.MarriedFilingJointly:
		view.FilingType = proto.FilingType_MarriedFilingJointly
	case irmaa.MarriedFilingSeparately:
		view.FilingType = proto.FilingType_MarriedFilingSeparately
	default:
		return nil, fmt.Errorf("unknown filing type: %v", irmaaBracket.FilingType)
	}

	view.FromCents = irmaaBracket.From.Cents()
	if irmaaBracket.To != nil {
		toCents := irmaaBracket.To.Cents()
		view.ToCents = &toCents
	}

	view.PartBIrmaaCents = irmaaBracket.PartBIRMAA.Cents()
	view.PartBMonthlyPremiumCents = irmaaBracket.PartBMonthlyPremium.Cents()
	view.PartDIrmaaCents = irmaaBracket.PartDIRMAA.Cents()

	return &view, nil
}

func mapQuoteToRPCShortQuote(quote_ *quote.Quote, agent_ *agent.Agent, client_ *client.Client, clientCounty *geo.County, today common.Date) *proto.ShortQuote {
	var view proto.ShortQuote
	view.Id = int64(quote_.ID)
	view.UrlId = string(quote_.URLID)
	view.Agent = mapAgentToRPCAgent(agent_)
	view.Client = mapClientToRPCClient(client_, clientCounty, today)
	view.EffectiveDate = quote_.EffectiveDate.Time()
	view.CreatedAt = quote_.CreatedAt
	view.UpdatedAt = quote_.UpdatedAt
	return &view
}

func mapQuoteToRPCQuote(
	effectiveDate common.Date,
	quote_ *quote.Quote,
	agent_ *agent.Agent,
	client_ *client.Client,
	clientCounty *geo.County,
	irmaaBracket *irmaa.Bracket,
	drugQuote *drug.Quote,
	dentalQuote *dental.Quote,
	today common.Date,
) (*proto.Quote, error) {
	var (
		view proto.Quote
		err  error
	)

	view.Id = int64(quote_.ID)
	view.UrlId = string(quote_.URLID)
	view.Agent = mapAgentToRPCAgent(agent_)
	view.Client = mapClientToRPCClient(client_, clientCounty, today)
	view.EffectiveDate = effectiveDate.Time()
	view.IrmaaBracket, err = mapIRMAABracketToRPCIRMAABracket(irmaaBracket)
	if err != nil {
		return nil, fmt.Errorf("failed mapDomainIrmaaBracketToView: %w", err)
	}
	if drugQuote != nil {
		view.DrugQuote = mapDrugQuoteToRPCDrugQuote(drugQuote)
	}
	if dentalQuote != nil {
		view.DentalQuote = mapDentalQuoteToRPCDentalQuote(dentalQuote)
	}

	view.SupplementalCarrierPlanTypes = []*proto.SupplementalCarrierPlanType{}
	for _, scpt := range quote_.SupplementalCarrierPlanTypes {
		var planType proto.SupplementalPlanType
		switch scpt.PlanType {
		case sup.PlanTypeF:
			planType = proto.SupplementalPlanType_F
		case sup.PlanTypeG:
			planType = proto.SupplementalPlanType_G
		case sup.PlanTypeN:
			planType = proto.SupplementalPlanType_N
		default:
			return nil, fmt.Errorf("unknown supplemental plan type: %w", err)
		}

		view.SupplementalCarrierPlanTypes = append(view.SupplementalCarrierPlanTypes, &proto.SupplementalCarrierPlanType{
			CarrierNaic: string(scpt.CarrierNAIC),
			PlanType:    planType,
		})
	}

	view.HasMultiInsuredDiscount = quote_.HasMultiInsuredDiscount
	view.HasLivingWithSomeoneDiscount = quote_.HasLivingWithSomeoneDiscount
	view.CreatedAt = quote_.CreatedAt
	view.UpdatedAt = quote_.UpdatedAt

	return &view, nil
}

func mapSupplementalQuoteToRPCSupplementalQuote(c *config.Config, supQuote *sup.Quote) *proto.SupplementalQuote {
	var view proto.SupplementalQuote

	view.Carrier = &proto.Carrier{}
	view.Carrier.Naic = string(supQuote.Carrier.NAIC)
	view.Carrier.Name = supQuote.Carrier.Name
	view.Carrier.IsPreferred = supQuote.Carrier.IsPreferred

	if supQuote.Carrier.LogoKey != nil {
		logoUrl := c.Storage.StaticBaseURL + "/" + string(*supQuote.Carrier.LogoKey)
		view.Carrier.LogoUrl = &logoUrl
	}

	switch supQuote.PlanType {
	case sup.PlanTypeF:
		view.PlanType = proto.SupplementalPlanType_F
	case sup.PlanTypeG:
		view.PlanType = proto.SupplementalPlanType_G
	case sup.PlanTypeN:
		view.PlanType = proto.SupplementalPlanType_N
	}

	view.MonthlyRateCents = supQuote.MonthlyRate.Cents()

	if supQuote.MultiInsuredDiscountMonthlyRate != nil {
		cents := supQuote.MultiInsuredDiscountMonthlyRate.Cents()
		view.MultiInsuredDiscountRateCents = &cents
	}

	if supQuote.LivingWithSomeoneDiscountMonthlyRate != nil {
		cents := supQuote.LivingWithSomeoneDiscountMonthlyRate.Cents()
		view.LivingWithSomeoneDiscountRateCents = &cents
	}

	return &view
}

================
File: internal/maxquoteserver/middleware.go
================
package rpc

import (
	"context"
	"errors"
	"log/slog"
	"net/http"

	"github.com/alexedwards/scs/v2"
	"github.com/go-chi/httplog/v2"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/session"
	proto "github.com/medicareschoolcom/maxquote/rpc/maxquote"
)

type agentKey struct{}

// withAgent assigns an agent to a context
func withAgent(ctx context.Context, a *agent.Agent) context.Context {
	return context.WithValue(ctx, agentKey{}, a)
}

// getAgent retreives an agent from a context. The second returned argment will
// be false if the contact does not contain an agent.
func getAgent(ctx context.Context) (*agent.Agent, bool) {
	a, ok := ctx.Value(agentKey{}).(*agent.Agent)
	return a, ok
}

func RequireAgent(
	sessionManager scs.SessionManager,
	agentStore agent.Store,
	logger *httplog.Logger,
	db common.DB,
) func(http.Handler) http.Handler {
	return func(next http.Handler) http.Handler {
		return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			// Get the agent id from session storage
			id64 := sessionManager.GetInt64(r.Context(), session.KeyAgentID)
			if id64 == 0 {
				proto.RespondWithError(w, proto.ErrUnauthorized)
				return
			}

			// Fetch the agent from the repository
			agentID := agent.ID(id64)
			a, err := agentStore.Get(r.Context(), db, agentID)
			if errors.Is(err, agent.ErrAgentNotFound) {
				proto.RespondWithError(w, proto.ErrEntityNotFound)
				return
			}
			if err != nil {
				logger.ErrorContext(r.Context(), "failed to get agent", slog.Any("error", err))
				proto.RespondWithError(w, proto.ErrInternal)
				return
			}

			ctx := r.Context()

			// Assign agent to logging output
			httplog.LogEntrySetField(ctx, "agent", slog.Int64Value(int64(a.ID)))

			// Assign agent to context
			ctx = withAgent(ctx, a)

			// Pass to next handler
			next.ServeHTTP(w, r.WithContext(ctx))
		})
	}
}

================
File: internal/maxquoteserver/public.go
================
package rpc

import (
	"context"
	"errors"
	"log/slog"

	"github.com/go-chi/httplog/v2"
	"github.com/medicareschoolcom/maxquote/internal/config"
	"github.com/medicareschoolcom/maxquote/internal/domain/agent"
	"github.com/medicareschoolcom/maxquote/internal/domain/client"
	"github.com/medicareschoolcom/maxquote/internal/domain/common"
	"github.com/medicareschoolcom/maxquote/internal/domain/dental"
	"github.com/medicareschoolcom/maxquote/internal/domain/drug"
	"github.com/medicareschoolcom/maxquote/internal/domain/geo"
	"github.com/medicareschoolcom/maxquote/internal/domain/irmaa"
	"github.com/medicareschoolcom/maxquote/internal/domain/quote"
	"github.com/medicareschoolcom/maxquote/internal/domain/sup"
	proto "github.com/medicareschoolcom/maxquote/rpc/maxquote"
)

type PublicServer struct {
	db                     common.DB
	logger                 *httplog.Logger
	agentStore             agent.Store
	clientStore            client.Store
	countyStore            geo.CountyStore
	irmaaBracketStore      irmaa.BracketStore
	drugQuoteStore         drug.QuoteStore
	supplementalQuoteStore sup.QuoteStore
	dentalQuoteStore       dental.QuoteStore
	quoteStore             quote.Store
	clock                  common.Clock
	config                 *config.Config
}

func NewPublicServer(
	db common.DB,
	logger *httplog.Logger,
	agentStore agent.Store,
	clientStore client.Store,
	countyStore geo.CountyStore,
	irmaaBracketStore irmaa.BracketStore,
	drugQuoteStore drug.QuoteStore,
	supplementalQuoteStore sup.QuoteStore,
	dentalQuoteStore dental.QuoteStore,
	quoteStore quote.Store,
	clock common.Clock,
	config *config.Config,
) *PublicServer {
	return &PublicServer{
		db:                     db,
		logger:                 logger,
		agentStore:             agentStore,
		clientStore:            clientStore,
		countyStore:            countyStore,
		irmaaBracketStore:      irmaaBracketStore,
		drugQuoteStore:         drugQuoteStore,
		supplementalQuoteStore: supplementalQuoteStore,
		dentalQuoteStore:       dentalQuoteStore,
		quoteStore:             quoteStore,
		clock:                  clock,
		config:                 config,
	}
}

var _ proto.Public = new(PublicServer)

func (s *PublicServer) GetQuote(ctx context.Context, urlID_ string) (*proto.Quote, error) {
	// Get quote
	quoteURLID, err := quote.NewURLID(urlID_)
	if err != nil {
		return nil, s.errInvalidArgument("urlId invalid")
	}

	quote_, err := s.quoteStore.GetByUrlID(ctx, s.db, quoteURLID)
	if errors.Is(err, quote.ErrQuoteNotFound) {
		return nil, proto.ErrEntityNotFound
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed quoteStore.GetByUrlID", err)
	}

	rollingEffectiveDate := quote_.RollingEffectiveDate(s.clock)

	// Get agent
	agent_, err := s.agentStore.Get(ctx, s.db, quote_.AgentID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed agentStore.Get", err)
	}

	// Get client
	client_, err := s.clientStore.Get(ctx, s.db, quote_.ClientID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Get", err)
	}

	// Get client county
	clientCounty, err := s.countyStore.Get(ctx, s.db, client_.CountyFIPSCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	// Get effective irmaa bracket
	irmaaBracket, err := s.irmaaBracketStore.Get(ctx, s.db, quote_.IrmaaBracketID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed irmaaBracketStore.Get", err)
	}

	effectiveIRMAABracket, err := s.irmaaBracketStore.GetEffective(ctx, s.db, rollingEffectiveDate.Year(), irmaaBracket.FilingType, irmaaBracket.Average())
	if err != nil {
		return nil, s.errInternal(ctx, "failed irmaaBracketStore.GetEffective", err)
	}

	// Get effective drug quote
	var effectiveDrugQuote *drug.Quote
	if quote_.DrugQuoteID != nil {
		drugQuote, err := s.drugQuoteStore.Get(ctx, s.db, *quote_.DrugQuoteID)
		if err != nil {
			return nil, s.errInternal(ctx, "failed drugQuoteStore.Get", err)
		}

		effectiveDrugQuote_, err := s.drugQuoteStore.GetEffective(ctx, s.db, rollingEffectiveDate.Year(), drugQuote.ContractID, drugQuote.PlanID, clientCounty.StateAlphaCode)
		if errors.Is(err, drug.ErrQuoteNotFound) {
			// Do nothing. This is okay
		} else if err != nil {
			return nil, s.errInternal(ctx, "failed drugQuoteStore.GetEffective", err)
		} else {
			effectiveDrugQuote = effectiveDrugQuote_
		}
	}

	// Get effective dental quote
	var effectiveDentalQuote *dental.Quote
	if quote_.DentalQuoteID != nil {
		dentalQuote, err := s.dentalQuoteStore.Get(ctx, s.db, *quote_.DentalQuoteID)
		if err != nil {
			return nil, s.errInternal(ctx, "failed dentalQuoteStore.Get", err)
		}
		effectiveDentalQuote_, err := s.dentalQuoteStore.GetEffective(ctx, s.db, dentalQuote.CarrierNaic, dentalQuote.AnnualBenefit, clientCounty.StateAlphaCode)
		if errors.Is(err, dental.ErrQuoteNotFound) {
			// Do nothing. This is okay
		} else if err != nil {
			return nil, s.errInternal(ctx, "failed dentalQuoteStore.GetEffective", err)
		} else {
			effectiveDentalQuote = effectiveDentalQuote_
		}
	}

	view, err := mapQuoteToRPCQuote(rollingEffectiveDate, quote_, agent_, client_, clientCounty, effectiveIRMAABracket, effectiveDrugQuote, effectiveDentalQuote, s.clock.Today())
	if err != nil {
		return nil, s.errInternal(ctx, "failed mapDomainQuoteToView", err)
	}

	return view, nil
}

func (s *PublicServer) GetSpouseQuote(ctx context.Context, urlID_ string) (*proto.Quote, error) {
	var quote_ *quote.Quote
	{
		// Get client quote
		quoteURLID, err := quote.NewURLID(urlID_)
		if err != nil {
			return nil, s.errInvalidArgument("urlId invalid")
		}

		clientQuote, err := s.quoteStore.GetByUrlID(ctx, s.db, quoteURLID)
		if errors.Is(err, quote.ErrQuoteNotFound) {
			return nil, proto.ErrEntityNotFound
		}
		if err != nil {
			return nil, s.errInternal(ctx, "failed quoteStore.GetByUrlID", err)
		}

		// Get spouse quote
		spouseQuote, err := s.quoteStore.GetByParentID(ctx, s.db, clientQuote.ID)
		if errors.Is(err, quote.ErrQuoteNotFound) {
			return nil, proto.ErrEntityNotFound
		}
		if err != nil {
			return nil, s.errInternal(ctx, "failed quoteStore.GetByUrlID", err)
		}

		quote_ = spouseQuote
	}

	rollingEffectiveDate := quote_.RollingEffectiveDate(s.clock)

	// Get agent
	agent_, err := s.agentStore.Get(ctx, s.db, quote_.AgentID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed agentStore.Get", err)
	}

	// Get client
	client_, err := s.clientStore.Get(ctx, s.db, quote_.ClientID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Get", err)
	}

	// Get client county
	clientCounty, err := s.countyStore.Get(ctx, s.db, client_.CountyFIPSCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	// Get effective irmaa bracket
	irmaaBracket, err := s.irmaaBracketStore.Get(ctx, s.db, quote_.IrmaaBracketID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed irmaaBracketStore.Get", err)
	}

	effectiveIRMAABracket, err := s.irmaaBracketStore.GetEffective(ctx, s.db, rollingEffectiveDate.Year(), irmaaBracket.FilingType, irmaaBracket.Average())
	if err != nil {
		return nil, s.errInternal(ctx, "failed irmaaBracketStore.GetEffective", err)
	}

	// Get effective drug quote
	var effectiveDrugQuote *drug.Quote
	if quote_.DrugQuoteID != nil {
		drugQuote, err := s.drugQuoteStore.Get(ctx, s.db, *quote_.DrugQuoteID)
		if err != nil {
			return nil, s.errInternal(ctx, "failed drugQuoteStore.Get", err)
		}

		effectiveDrugQuote_, err := s.drugQuoteStore.GetEffective(ctx, s.db, rollingEffectiveDate.Year(), drugQuote.ContractID, drugQuote.PlanID, clientCounty.StateAlphaCode)
		if errors.Is(err, drug.ErrQuoteNotFound) {
			// Do nothing. This is okay
		} else if err != nil {
			return nil, s.errInternal(ctx, "failed drugQuoteStore.GetEffective", err)
		} else {
			effectiveDrugQuote = effectiveDrugQuote_
		}
	}

	// Get effective dental quote
	var effectiveDentalQuote *dental.Quote
	if quote_.DentalQuoteID != nil {
		dentalQuote, err := s.dentalQuoteStore.Get(ctx, s.db, *quote_.DentalQuoteID)
		if err != nil {
			return nil, s.errInternal(ctx, "failed dentalQuoteStore.Get", err)
		}
		effectiveDentalQuote_, err := s.dentalQuoteStore.GetEffective(ctx, s.db, dentalQuote.CarrierNaic, dentalQuote.AnnualBenefit, clientCounty.StateAlphaCode)
		if errors.Is(err, dental.ErrQuoteNotFound) {
			// Do nothing. This is okay
		} else if err != nil {
			return nil, s.errInternal(ctx, "failed dentalQuoteStore.GetEffective", err)
		} else {
			effectiveDentalQuote = effectiveDentalQuote_
		}
	}

	view, err := mapQuoteToRPCQuote(rollingEffectiveDate, quote_, agent_, client_, clientCounty, effectiveIRMAABracket, effectiveDrugQuote, effectiveDentalQuote, s.clock.Today())
	if err != nil {
		return nil, s.errInternal(ctx, "failed mapDomainQuoteToView", err)
	}

	return view, nil
}

func (s *PublicServer) ListSupplementalQuotesForQuote(ctx context.Context, urlID string) ([]*proto.SupplementalQuote, error) {
	quoteURLID, err := quote.NewURLID(urlID)
	if err != nil {
		return nil, s.errInvalidArgument("urlId invalid")
	}

	quote_, err := s.quoteStore.GetByUrlID(ctx, s.db, quoteURLID)
	if errors.Is(err, quote.ErrQuoteNotFound) {
		return nil, proto.ErrEntityNotFound
	}
	if err != nil {
		return nil, s.errInternal(ctx, "failed quoteStore.GetByUrlID", err)
	}

	rollingEffectiveDate := quote_.RollingEffectiveDate(s.clock)

	client_, err := s.clientStore.Get(ctx, s.db, quote_.ClientID)
	if err != nil {
		return nil, s.errInternal(ctx, "failed clientStore.Get", err)
	}

	clientCounty, err := s.countyStore.Get(ctx, s.db, client_.CountyFIPSCode)
	if err != nil {
		return nil, s.errInternal(ctx, "failed countyStore.Get", err)
	}

	supplementalQuotes, err := s.supplementalQuoteStore.List(ctx, sup.ListParams{
		ZipCode:        client_.ZipCode,
		CountyName:     clientCounty.Name,
		StateAlphaCode: clientCounty.StateAlphaCode,
		Age:            rollingEffectiveDate.YearsSince(client_.DateOfBirth.StartOfMonth()), // Special rule: for the entire month of the client's 65th birthday, return sup quotes for age 65 only.
		Gender:         client_.Gender,
		IsTobaccoUser:  client_.IsTobaccoUser,
		PlanTypes:      quote_.SupplementalPlanTypes(),
		EffectiveDate:  rollingEffectiveDate,
		CarrierGroup:   sup.Supported,
		NAICs:          quote_.SupplementalCarrierNAICS(),
	})
	if err != nil {
		return nil, s.errInternal(ctx, "failed supplementalQuoteStore.List", err)
	}

	views := []*proto.SupplementalQuote{}
	for _, supplementalQuote := range supplementalQuotes {
		for _, supPlan := range quote_.SupplementalCarrierPlanTypes {
			if supPlan.CarrierNAIC == supplementalQuote.Carrier.NAIC && supPlan.PlanType == supplementalQuote.PlanType {
				view := mapSupplementalQuoteToRPCSupplementalQuote(s.config, supplementalQuote)
				views = append(views, view)
				break
			}
		}
	}
	return views, nil

}

func (s *PublicServer) errInternal(ctx context.Context, message string, err error) proto.WebRPCError {
	s.logger.ErrorContext(ctx, message, slog.Any("error", err))
	return proto.ErrInternal
}

func (s *PublicServer) errInvalidArgument(message string) proto.WebRPCError {
	rpcErr := proto.ErrInvalidArgument
	rpcErr.Message = message
	return rpcErr
}

================
File: internal/postgres/postgres.go
================
package postgres

import (
	"context"
	"fmt"

	pgxdecimal "github.com/jackc/pgx-shopspring-decimal"
	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

func NewPool(ctx context.Context, connString string) (*pgxpool.Pool, error) {
	config, err := pgxpool.ParseConfig(connString)
	if err != nil {
		return nil, fmt.Errorf("failed to parse database config: %w", err)
	}
	config.AfterConnect = func(ctx context.Context, conn *pgx.Conn) error {
		pgxdecimal.Register(conn.TypeMap())
		return nil
	}

	pool, err := pgxpool.NewWithConfig(context.Background(), config)
	if err != nil {
		return nil, fmt.Errorf("failed to open database connection pool: %w", err)
	}

	return pool, nil
}

================
File: internal/session/session.go
================
package session

const KeyAgentID = "session.agentid"

================
File: internal/sqlc/agent.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: agent.sql

package sqlc

import (
	"context"
)

const getAgent = `-- name: GetAgent :one
SELECT id, first_name, last_name, email, phone, phone_ext, created_at, updated_at FROM agent WHERE id = $1
`

func (q *Queries) GetAgent(ctx context.Context, db DBTX, id int64) (*Agent, error) {
	row := db.QueryRow(ctx, getAgent, id)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.PhoneExt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getAgentByEmail = `-- name: GetAgentByEmail :one
SELECT id, first_name, last_name, email, phone, phone_ext, created_at, updated_at FROM agent WHERE email = $1
`

func (q *Queries) GetAgentByEmail(ctx context.Context, db DBTX, email string) (*Agent, error) {
	row := db.QueryRow(ctx, getAgentByEmail, email)
	var i Agent
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.Email,
		&i.Phone,
		&i.PhoneExt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

================
File: internal/sqlc/client.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: client.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteClient = `-- name: DeleteClient :exec
DELETE FROM client WHERE id = $1
`

func (q *Queries) DeleteClient(ctx context.Context, db DBTX, id int64) error {
	_, err := db.Exec(ctx, deleteClient, id)
	return err
}

const getClient = `-- name: GetClient :one
SELECT id, first_name, last_name, date_of_birth, gender, zip_code, county_fips_code, phone, email, is_tobacco_user, created_at, updated_at FROM client WHERE id = $1
`

func (q *Queries) GetClient(ctx context.Context, db DBTX, id int64) (*Client, error) {
	row := db.QueryRow(ctx, getClient, id)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Gender,
		&i.ZipCode,
		&i.CountyFipsCode,
		&i.Phone,
		&i.Email,
		&i.IsTobaccoUser,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getClientByEmail = `-- name: GetClientByEmail :one
SELECT id, first_name, last_name, date_of_birth, gender, zip_code, county_fips_code, phone, email, is_tobacco_user, created_at, updated_at FROM client WHERE email = $1
`

func (q *Queries) GetClientByEmail(ctx context.Context, db DBTX, email pgtype.Text) (*Client, error) {
	row := db.QueryRow(ctx, getClientByEmail, email)
	var i Client
	err := row.Scan(
		&i.ID,
		&i.FirstName,
		&i.LastName,
		&i.DateOfBirth,
		&i.Gender,
		&i.ZipCode,
		&i.CountyFipsCode,
		&i.Phone,
		&i.Email,
		&i.IsTobaccoUser,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getNextClientID = `-- name: GetNextClientID :one
SELECT nextval('client_id_seq')
`

func (q *Queries) GetNextClientID(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, getNextClientID)
	var nextval int64
	err := row.Scan(&nextval)
	return nextval, err
}

const listClientsByIDS = `-- name: ListClientsByIDS :many
SELECT id, first_name, last_name, date_of_birth, gender, zip_code, county_fips_code, phone, email, is_tobacco_user, created_at, updated_at
FROM client
WHERE id = ANY($1::BIGINT[])
ORDER BY id
`

func (q *Queries) ListClientsByIDS(ctx context.Context, db DBTX, dollar_1 []int64) ([]*Client, error) {
	rows, err := db.Query(ctx, listClientsByIDS, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Gender,
			&i.ZipCode,
			&i.CountyFipsCode,
			&i.Phone,
			&i.Email,
			&i.IsTobaccoUser,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchClients = `-- name: SearchClients :many
SELECT id, first_name, last_name, date_of_birth, gender, zip_code, county_fips_code, phone, email, is_tobacco_user, created_at, updated_at
FROM client
WHERE first_name || ' ' || last_name ILIKE '%' || $1 || '%'
    OR email LIKE '%' || $1 || '%'
ORDER BY (first_name || ' ' || last_name)
LIMIT $2
`

type SearchClientsParams struct {
	Column1 pgtype.Text
	Limit   int32
}

func (q *Queries) SearchClients(ctx context.Context, db DBTX, arg SearchClientsParams) ([]*Client, error) {
	rows, err := db.Query(ctx, searchClients, arg.Column1, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*Client
	for rows.Next() {
		var i Client
		if err := rows.Scan(
			&i.ID,
			&i.FirstName,
			&i.LastName,
			&i.DateOfBirth,
			&i.Gender,
			&i.ZipCode,
			&i.CountyFipsCode,
			&i.Phone,
			&i.Email,
			&i.IsTobaccoUser,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertClient = `-- name: UpsertClient :exec
INSERT INTO client (id, first_name, last_name, date_of_birth, gender, zip_code, county_fips_code, phone, email, is_tobacco_user, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT (id)
DO UPDATE SET
    first_name = $2,
    last_name = $3,
    date_of_birth = $4,
    gender = $5,
    zip_code = $6,
    county_fips_code = $7,
    phone = $8,
    email = $9,
    is_tobacco_user = $10,
    created_at = $11,
    updated_at = $12
`

type UpsertClientParams struct {
	ID             int64
	FirstName      string
	LastName       string
	DateOfBirth    pgtype.Date
	Gender         string
	ZipCode        string
	CountyFipsCode string
	Phone          pgtype.Text
	Email          pgtype.Text
	IsTobaccoUser  bool
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
}

func (q *Queries) UpsertClient(ctx context.Context, db DBTX, arg UpsertClientParams) error {
	_, err := db.Exec(ctx, upsertClient,
		arg.ID,
		arg.FirstName,
		arg.LastName,
		arg.DateOfBirth,
		arg.Gender,
		arg.ZipCode,
		arg.CountyFipsCode,
		arg.Phone,
		arg.Email,
		arg.IsTobaccoUser,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

================
File: internal/sqlc/copyfrom.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: copyfrom.go

package sqlc

import (
	"context"
)

// iteratorForInsertQuoteSupplementalPlan implements pgx.CopyFromSource.
type iteratorForInsertQuoteSupplementalPlan struct {
	rows                 []InsertQuoteSupplementalPlanParams
	skippedFirstNextCall bool
}

func (r *iteratorForInsertQuoteSupplementalPlan) Next() bool {
	if len(r.rows) == 0 {
		return false
	}
	if !r.skippedFirstNextCall {
		r.skippedFirstNextCall = true
		return true
	}
	r.rows = r.rows[1:]
	return len(r.rows) > 0
}

func (r iteratorForInsertQuoteSupplementalPlan) Values() ([]interface{}, error) {
	return []interface{}{
		r.rows[0].QuoteID,
		r.rows[0].CarrierNaic,
		r.rows[0].PlanType,
	}, nil
}

func (r iteratorForInsertQuoteSupplementalPlan) Err() error {
	return nil
}

func (q *Queries) InsertQuoteSupplementalPlan(ctx context.Context, db DBTX, arg []InsertQuoteSupplementalPlanParams) (int64, error) {
	return db.CopyFrom(ctx, []string{"quote_supplemental_carrier_plan_type"}, []string{"quote_id", "carrier_naic", "plan_type"}, &iteratorForInsertQuoteSupplementalPlan{rows: arg})
}

================
File: internal/sqlc/county.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: county.sql

package sqlc

import (
	"context"
)

const getCounty = `-- name: GetCounty :one
SELECT fips_code, name, state_alpha_code FROM county WHERE fips_code = $1
`

func (q *Queries) GetCounty(ctx context.Context, db DBTX, fipsCode string) (*County, error) {
	row := db.QueryRow(ctx, getCounty, fipsCode)
	var i County
	err := row.Scan(&i.FipsCode, &i.Name, &i.StateAlphaCode)
	return &i, err
}

const listCountiesByFIPSCodes = `-- name: ListCountiesByFIPSCodes :many
SELECT fips_code, name, state_alpha_code
FROM county
WHERE fips_code = ANY($1::TEXT[])
ORDER BY fips_code
`

func (q *Queries) ListCountiesByFIPSCodes(ctx context.Context, db DBTX, dollar_1 []string) ([]*County, error) {
	rows, err := db.Query(ctx, listCountiesByFIPSCodes, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*County
	for rows.Next() {
		var i County
		if err := rows.Scan(&i.FipsCode, &i.Name, &i.StateAlphaCode); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertCounty = `-- name: UpsertCounty :exec
INSERT INTO county (fips_code, name, state_alpha_code)
VALUES ($1, $2, $3)
ON CONFLICT (fips_code)
DO UPDATE SET
  name = EXCLUDED.name,
  state_alpha_code = EXCLUDED.state_alpha_code
`

type UpsertCountyParams struct {
	FipsCode       string
	Name           string
	StateAlphaCode string
}

func (q *Queries) UpsertCounty(ctx context.Context, db DBTX, arg UpsertCountyParams) error {
	_, err := db.Exec(ctx, upsertCounty, arg.FipsCode, arg.Name, arg.StateAlphaCode)
	return err
}

================
File: internal/sqlc/db.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
	CopyFrom(ctx context.Context, tableName pgx.Identifier, columnNames []string, rowSrc pgx.CopyFromSource) (int64, error)
}

func New() *Queries {
	return &Queries{}
}

type Queries struct {
}

================
File: internal/sqlc/dental_quote.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: dental_quote.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getDentalQuote = `-- name: GetDentalQuote :one
SELECT
    dental_quote.id, dental_quote.state_alpha_code, dental_quote.carrier_naic, dental_quote.annual_benefit_cents, dental_quote.monthly_rate_cents, dental_quote.created_at,
    dental_carrier.name AS carrier_name
FROM dental_quote
INNER JOIN dental_carrier ON dental_quote.carrier_naic = dental_carrier.naic
WHERE dental_quote.id = $1
`

type GetDentalQuoteRow struct {
	ID                 int64
	StateAlphaCode     string
	CarrierNaic        string
	AnnualBenefitCents int32
	MonthlyRateCents   int32
	CreatedAt          pgtype.Timestamptz
	CarrierName        string
}

func (q *Queries) GetDentalQuote(ctx context.Context, db DBTX, id int64) (*GetDentalQuoteRow, error) {
	row := db.QueryRow(ctx, getDentalQuote, id)
	var i GetDentalQuoteRow
	err := row.Scan(
		&i.ID,
		&i.StateAlphaCode,
		&i.CarrierNaic,
		&i.AnnualBenefitCents,
		&i.MonthlyRateCents,
		&i.CreatedAt,
		&i.CarrierName,
	)
	return &i, err
}

const getEffectiveDentalQuote = `-- name: GetEffectiveDentalQuote :one
SELECT
    dental_quote.id, dental_quote.state_alpha_code, dental_quote.carrier_naic, dental_quote.annual_benefit_cents, dental_quote.monthly_rate_cents, dental_quote.created_at,
    dental_carrier.name AS carrier_name
FROM dental_quote
INNER JOIN dental_carrier ON dental_quote.carrier_naic = dental_carrier.naic
WHERE dental_quote.state_alpha_code = $1 AND dental_quote.carrier_naic = $2 AND dental_quote.annual_benefit_cents = $3
`

type GetEffectiveDentalQuoteParams struct {
	StateAlphaCode     string
	CarrierNaic        string
	AnnualBenefitCents int32
}

type GetEffectiveDentalQuoteRow struct {
	ID                 int64
	StateAlphaCode     string
	CarrierNaic        string
	AnnualBenefitCents int32
	MonthlyRateCents   int32
	CreatedAt          pgtype.Timestamptz
	CarrierName        string
}

func (q *Queries) GetEffectiveDentalQuote(ctx context.Context, db DBTX, arg GetEffectiveDentalQuoteParams) (*GetEffectiveDentalQuoteRow, error) {
	row := db.QueryRow(ctx, getEffectiveDentalQuote, arg.StateAlphaCode, arg.CarrierNaic, arg.AnnualBenefitCents)
	var i GetEffectiveDentalQuoteRow
	err := row.Scan(
		&i.ID,
		&i.StateAlphaCode,
		&i.CarrierNaic,
		&i.AnnualBenefitCents,
		&i.MonthlyRateCents,
		&i.CreatedAt,
		&i.CarrierName,
	)
	return &i, err
}

const listDentalQuotesByStateAlphaCode = `-- name: ListDentalQuotesByStateAlphaCode :many
SELECT
    dental_quote.id, dental_quote.state_alpha_code, dental_quote.carrier_naic, dental_quote.annual_benefit_cents, dental_quote.monthly_rate_cents, dental_quote.created_at,
    dental_carrier.name AS carrier_name
FROM dental_quote
INNER JOIN dental_carrier ON dental_quote.carrier_naic = dental_carrier.naic
WHERE dental_quote.state_alpha_code = $1
ORDER BY
    dental_quote.state_alpha_code,
    dental_quote.carrier_naic,
    dental_quote.annual_benefit_cents
`

type ListDentalQuotesByStateAlphaCodeRow struct {
	ID                 int64
	StateAlphaCode     string
	CarrierNaic        string
	AnnualBenefitCents int32
	MonthlyRateCents   int32
	CreatedAt          pgtype.Timestamptz
	CarrierName        string
}

func (q *Queries) ListDentalQuotesByStateAlphaCode(ctx context.Context, db DBTX, stateAlphaCode string) ([]*ListDentalQuotesByStateAlphaCodeRow, error) {
	rows, err := db.Query(ctx, listDentalQuotesByStateAlphaCode, stateAlphaCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListDentalQuotesByStateAlphaCodeRow
	for rows.Next() {
		var i ListDentalQuotesByStateAlphaCodeRow
		if err := rows.Scan(
			&i.ID,
			&i.StateAlphaCode,
			&i.CarrierNaic,
			&i.AnnualBenefitCents,
			&i.MonthlyRateCents,
			&i.CreatedAt,
			&i.CarrierName,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

================
File: internal/sqlc/drug_quote.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: drug_quote.sql

package sqlc

import (
	"context"
)

const getDrugQuote = `-- name: GetDrugQuote :one
SELECT id, contract_year, contract_id, plan_id, state_alpha_code, company_name, plan_name, monthly_rate_cents, created_at, updated_at FROM drug_quote WHERE id = $1
`

func (q *Queries) GetDrugQuote(ctx context.Context, db DBTX, id int64) (*DrugQuote, error) {
	row := db.QueryRow(ctx, getDrugQuote, id)
	var i DrugQuote
	err := row.Scan(
		&i.ID,
		&i.ContractYear,
		&i.ContractID,
		&i.PlanID,
		&i.StateAlphaCode,
		&i.CompanyName,
		&i.PlanName,
		&i.MonthlyRateCents,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getEffectiveDrugQuote = `-- name: GetEffectiveDrugQuote :one
SELECT id, contract_year, contract_id, plan_id, state_alpha_code, company_name, plan_name, monthly_rate_cents, created_at, updated_at
FROM drug_quote
WHERE
    contract_year = $1 AND
    contract_id = $2 AND
    plan_id = $3 AND
    state_alpha_code = $4
`

type GetEffectiveDrugQuoteParams struct {
	ContractYear   int32
	ContractID     string
	PlanID         int32
	StateAlphaCode string
}

func (q *Queries) GetEffectiveDrugQuote(ctx context.Context, db DBTX, arg GetEffectiveDrugQuoteParams) (*DrugQuote, error) {
	row := db.QueryRow(ctx, getEffectiveDrugQuote,
		arg.ContractYear,
		arg.ContractID,
		arg.PlanID,
		arg.StateAlphaCode,
	)
	var i DrugQuote
	err := row.Scan(
		&i.ID,
		&i.ContractYear,
		&i.ContractID,
		&i.PlanID,
		&i.StateAlphaCode,
		&i.CompanyName,
		&i.PlanName,
		&i.MonthlyRateCents,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const listDrugQuotesByLatestYearAndState = `-- name: ListDrugQuotesByLatestYearAndState :many
SELECT d1.id, d1.contract_year, d1.contract_id, d1.plan_id, d1.state_alpha_code, d1.company_name, d1.plan_name, d1.monthly_rate_cents, d1.created_at, d1.updated_at
FROM drug_quote d1
WHERE
    d1.contract_year =
        ( SELECT MAX(d2.contract_year)
        FROM drug_quote d2
        WHERE d2.contract_year <= $1
        )
    AND d1.state_alpha_code = $2
    ORDER BY (d1.company_name, d1.monthly_rate_cents)
`

type ListDrugQuotesByLatestYearAndStateParams struct {
	ContractYear   int32
	StateAlphaCode string
}

func (q *Queries) ListDrugQuotesByLatestYearAndState(ctx context.Context, db DBTX, arg ListDrugQuotesByLatestYearAndStateParams) ([]*DrugQuote, error) {
	rows, err := db.Query(ctx, listDrugQuotesByLatestYearAndState, arg.ContractYear, arg.StateAlphaCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*DrugQuote
	for rows.Next() {
		var i DrugQuote
		if err := rows.Scan(
			&i.ID,
			&i.ContractYear,
			&i.ContractID,
			&i.PlanID,
			&i.StateAlphaCode,
			&i.CompanyName,
			&i.PlanName,
			&i.MonthlyRateCents,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

================
File: internal/sqlc/irmaa_bracket.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: irmaa_bracket.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const getEffectiveIrmaaBracket = `-- name: GetEffectiveIrmaaBracket :one
SELECT
    i1.id, i1.year, i1.filing_type, i1.from_cents, i1.part_b_irmaa_cents, i1.part_b_monthly_premium_cents, i1.part_d_irmaa_cents, i1.created_at, i1.updated_at,
    ( 	SELECT COALESCE(min(i2.from_cents),0)::INTEGER as to_cents
  		FROM irmaa_bracket i2
  		WHERE i2.year = i1.year
  		AND i2.filing_type = i1.filing_type
  		AND i2.from_cents > i1.from_cents
   	)
FROM irmaa_bracket i1
WHERE i1.year =
    (   SELECT MAX(i3.year)
        FROM irmaa_bracket i3
        WHERE i3.year <= $1
    )
AND i1.filing_type = $2
AND i1.from_cents <= $3
ORDER BY i1.year, i1.filing_type, i1.from_cents DESC
LIMIT 1
`

type GetEffectiveIrmaaBracketParams struct {
	Year       int32
	FilingType string
	FromCents  int32
}

type GetEffectiveIrmaaBracketRow struct {
	ID                       int64
	Year                     int32
	FilingType               string
	FromCents                int32
	PartBIrmaaCents          int32
	PartBMonthlyPremiumCents int32
	PartDIrmaaCents          int32
	CreatedAt                pgtype.Timestamptz
	UpdatedAt                pgtype.Timestamptz
	ToCents                  int32
}

func (q *Queries) GetEffectiveIrmaaBracket(ctx context.Context, db DBTX, arg GetEffectiveIrmaaBracketParams) (*GetEffectiveIrmaaBracketRow, error) {
	row := db.QueryRow(ctx, getEffectiveIrmaaBracket, arg.Year, arg.FilingType, arg.FromCents)
	var i GetEffectiveIrmaaBracketRow
	err := row.Scan(
		&i.ID,
		&i.Year,
		&i.FilingType,
		&i.FromCents,
		&i.PartBIrmaaCents,
		&i.PartBMonthlyPremiumCents,
		&i.PartDIrmaaCents,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ToCents,
	)
	return &i, err
}

const getIrmaaBracket = `-- name: GetIrmaaBracket :one
SELECT
    i1.id, i1.year, i1.filing_type, i1.from_cents, i1.part_b_irmaa_cents, i1.part_b_monthly_premium_cents, i1.part_d_irmaa_cents, i1.created_at, i1.updated_at,
    ( 	SELECT COALESCE(min(i2.from_cents),0)::INTEGER as to_cents
  		FROM irmaa_bracket i2
  		WHERE i2.year = i1.year
  		AND i2.filing_type = i1.filing_type
  		AND i2.from_cents > i1.from_cents
   	)
FROM irmaa_bracket i1
WHERE i1.id = $1
`

type GetIrmaaBracketRow struct {
	ID                       int64
	Year                     int32
	FilingType               string
	FromCents                int32
	PartBIrmaaCents          int32
	PartBMonthlyPremiumCents int32
	PartDIrmaaCents          int32
	CreatedAt                pgtype.Timestamptz
	UpdatedAt                pgtype.Timestamptz
	ToCents                  int32
}

func (q *Queries) GetIrmaaBracket(ctx context.Context, db DBTX, id int64) (*GetIrmaaBracketRow, error) {
	row := db.QueryRow(ctx, getIrmaaBracket, id)
	var i GetIrmaaBracketRow
	err := row.Scan(
		&i.ID,
		&i.Year,
		&i.FilingType,
		&i.FromCents,
		&i.PartBIrmaaCents,
		&i.PartBMonthlyPremiumCents,
		&i.PartDIrmaaCents,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ToCents,
	)
	return &i, err
}

const listLatestIrmaaBracketsByYear = `-- name: ListLatestIrmaaBracketsByYear :many
SELECT
    i1.id, i1.year, i1.filing_type, i1.from_cents, i1.part_b_irmaa_cents, i1.part_b_monthly_premium_cents, i1.part_d_irmaa_cents, i1.created_at, i1.updated_at,
    ( 	SELECT COALESCE(min(i2.from_cents),0)::INTEGER as to_cents
		FROM irmaa_bracket i2
		WHERE i2.year = i1.year
		AND i2.filing_type = i1.filing_type
		AND i2.from_cents > i1.from_cents
	)
FROM irmaa_bracket i1
WHERE i1.year =
    (   SELECT MAX(i3.year)
        FROM irmaa_bracket i3
        WHERE i3.year <= $1
    )
ORDER BY i1.year, i1.filing_type, i1.from_cents
`

type ListLatestIrmaaBracketsByYearRow struct {
	ID                       int64
	Year                     int32
	FilingType               string
	FromCents                int32
	PartBIrmaaCents          int32
	PartBMonthlyPremiumCents int32
	PartDIrmaaCents          int32
	CreatedAt                pgtype.Timestamptz
	UpdatedAt                pgtype.Timestamptz
	ToCents                  int32
}

func (q *Queries) ListLatestIrmaaBracketsByYear(ctx context.Context, db DBTX, year int32) ([]*ListLatestIrmaaBracketsByYearRow, error) {
	rows, err := db.Query(ctx, listLatestIrmaaBracketsByYear, year)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListLatestIrmaaBracketsByYearRow
	for rows.Next() {
		var i ListLatestIrmaaBracketsByYearRow
		if err := rows.Scan(
			&i.ID,
			&i.Year,
			&i.FilingType,
			&i.FromCents,
			&i.PartBIrmaaCents,
			&i.PartBMonthlyPremiumCents,
			&i.PartDIrmaaCents,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ToCents,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

================
File: internal/sqlc/models.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package sqlc

import (
	"github.com/jackc/pgx/v5/pgtype"
)

type Agent struct {
	ID        int64
	FirstName string
	LastName  string
	Email     string
	Phone     string
	PhoneExt  pgtype.Int4
	CreatedAt pgtype.Timestamptz
	UpdatedAt pgtype.Timestamptz
}

type Client struct {
	ID             int64
	FirstName      string
	LastName       string
	DateOfBirth    pgtype.Date
	Gender         string
	ZipCode        string
	CountyFipsCode string
	Phone          pgtype.Text
	Email          pgtype.Text
	IsTobaccoUser  bool
	CreatedAt      pgtype.Timestamptz
	UpdatedAt      pgtype.Timestamptz
}

type County struct {
	FipsCode       string
	Name           string
	StateAlphaCode string
}

type DrugQuote struct {
	ID               int64
	ContractYear     int32
	ContractID       string
	PlanID           int32
	StateAlphaCode   string
	CompanyName      string
	PlanName         string
	MonthlyRateCents int32
	CreatedAt        pgtype.Timestamptz
	UpdatedAt        pgtype.Timestamptz
}

type PreferredSupplementalCarrier struct {
	Naic           string
	StateAlphaCode string
	CreatedAt      pgtype.Timestamptz
}

type Quote struct {
	ID                           int64
	UrlID                        string
	ParentID                     pgtype.Int8
	AgentID                      int64
	ClientID                     int64
	EffectiveDate                pgtype.Date
	IrmaaBracketID               int64
	DrugQuoteID                  pgtype.Int8
	DentalQuoteID                pgtype.Int8
	HasMultiInsuredDiscount      bool
	HasLivingWithSomeoneDiscount bool
	CreatedAt                    pgtype.Timestamptz
	UpdatedAt                    pgtype.Timestamptz
}

type QuoteSupplementalCarrierPlanType struct {
	QuoteID     int64
	CarrierNaic string
	PlanType    string
}

type ZipCodeCounty struct {
	ZipCode        string
	CountyFipsCode string
}

================
File: internal/sqlc/preferred_supplemental_carrier.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: preferred_supplemental_carrier.sql

package sqlc

import (
	"context"
)

const listPreferredSupplementalCarriersByStateAlphaCode = `-- name: ListPreferredSupplementalCarriersByStateAlphaCode :many
SELECT naic, state_alpha_code, created_at FROM preferred_supplemental_carrier WHERE state_alpha_code = $1 ORDER BY naic
`

func (q *Queries) ListPreferredSupplementalCarriersByStateAlphaCode(ctx context.Context, db DBTX, stateAlphaCode string) ([]*PreferredSupplementalCarrier, error) {
	rows, err := db.Query(ctx, listPreferredSupplementalCarriersByStateAlphaCode, stateAlphaCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*PreferredSupplementalCarrier
	for rows.Next() {
		var i PreferredSupplementalCarrier
		if err := rows.Scan(&i.Naic, &i.StateAlphaCode, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

================
File: internal/sqlc/querier.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

type Querier interface {
	DeleteClient(ctx context.Context, db DBTX, id int64) error
	DeleteQuote(ctx context.Context, db DBTX, id int64) error
	DeleteQuoteSupplementalPlansByQuoteID(ctx context.Context, db DBTX, quoteID int64) error
	GetAgent(ctx context.Context, db DBTX, id int64) (*Agent, error)
	GetAgentByEmail(ctx context.Context, db DBTX, email string) (*Agent, error)
	GetClient(ctx context.Context, db DBTX, id int64) (*Client, error)
	GetClientByEmail(ctx context.Context, db DBTX, email pgtype.Text) (*Client, error)
	GetCounty(ctx context.Context, db DBTX, fipsCode string) (*County, error)
	GetDentalQuote(ctx context.Context, db DBTX, id int64) (*GetDentalQuoteRow, error)
	GetDrugQuote(ctx context.Context, db DBTX, id int64) (*DrugQuote, error)
	GetEffectiveDentalQuote(ctx context.Context, db DBTX, arg GetEffectiveDentalQuoteParams) (*GetEffectiveDentalQuoteRow, error)
	GetEffectiveDrugQuote(ctx context.Context, db DBTX, arg GetEffectiveDrugQuoteParams) (*DrugQuote, error)
	GetEffectiveIrmaaBracket(ctx context.Context, db DBTX, arg GetEffectiveIrmaaBracketParams) (*GetEffectiveIrmaaBracketRow, error)
	GetIrmaaBracket(ctx context.Context, db DBTX, id int64) (*GetIrmaaBracketRow, error)
	GetNextClientID(ctx context.Context, db DBTX) (int64, error)
	GetNextQuoteID(ctx context.Context, db DBTX) (int64, error)
	GetQuote(ctx context.Context, db DBTX, id int64) (*Quote, error)
	GetQuoteByParentID(ctx context.Context, db DBTX, parentID pgtype.Int8) (*Quote, error)
	GetQuoteByUrlID(ctx context.Context, db DBTX, urlID string) (*Quote, error)
	InsertQuoteSupplementalPlan(ctx context.Context, db DBTX, arg []InsertQuoteSupplementalPlanParams) (int64, error)
	ListClientsByIDS(ctx context.Context, db DBTX, dollar_1 []int64) ([]*Client, error)
	ListCountiesByFIPSCodes(ctx context.Context, db DBTX, dollar_1 []string) ([]*County, error)
	ListDentalQuotesByStateAlphaCode(ctx context.Context, db DBTX, stateAlphaCode string) ([]*ListDentalQuotesByStateAlphaCodeRow, error)
	ListDrugQuotesByLatestYearAndState(ctx context.Context, db DBTX, arg ListDrugQuotesByLatestYearAndStateParams) ([]*DrugQuote, error)
	ListLatestIrmaaBracketsByYear(ctx context.Context, db DBTX, year int32) ([]*ListLatestIrmaaBracketsByYearRow, error)
	ListPreferredSupplementalCarriersByStateAlphaCode(ctx context.Context, db DBTX, stateAlphaCode string) ([]*PreferredSupplementalCarrier, error)
	ListQuoteSupplementalPlansByQuoteID(ctx context.Context, db DBTX, quoteID int64) ([]*QuoteSupplementalCarrierPlanType, error)
	ListQuoteSupplementalPlansByQuoteIDS(ctx context.Context, db DBTX, dollar_1 []int64) ([]*QuoteSupplementalCarrierPlanType, error)
	ListSupplementalCarrierLogosByNaics(ctx context.Context, db DBTX, dollar_1 []string) ([]*ListSupplementalCarrierLogosByNaicsRow, error)
	ListZipCodeCountiesByZipCode(ctx context.Context, db DBTX, zipCode string) ([]*ZipCodeCounty, error)
	SearchClients(ctx context.Context, db DBTX, arg SearchClientsParams) ([]*Client, error)
	UpsertClient(ctx context.Context, db DBTX, arg UpsertClientParams) error
	UpsertCounty(ctx context.Context, db DBTX, arg UpsertCountyParams) error
	UpsertQuote(ctx context.Context, db DBTX, arg UpsertQuoteParams) error
	UpsertZipCode(ctx context.Context, db DBTX, code string) error
	UpsertZipCodeCounty(ctx context.Context, db DBTX, arg UpsertZipCodeCountyParams) error
}

var _ Querier = (*Queries)(nil)

================
File: internal/sqlc/quote_supplemental_carrier_plan_type.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: quote_supplemental_carrier_plan_type.sql

package sqlc

import (
	"context"
)

const deleteQuoteSupplementalPlansByQuoteID = `-- name: DeleteQuoteSupplementalPlansByQuoteID :exec
DELETE FROM quote_supplemental_carrier_plan_type WHERE quote_id = $1
`

func (q *Queries) DeleteQuoteSupplementalPlansByQuoteID(ctx context.Context, db DBTX, quoteID int64) error {
	_, err := db.Exec(ctx, deleteQuoteSupplementalPlansByQuoteID, quoteID)
	return err
}

type InsertQuoteSupplementalPlanParams struct {
	QuoteID     int64
	CarrierNaic string
	PlanType    string
}

const listQuoteSupplementalPlansByQuoteID = `-- name: ListQuoteSupplementalPlansByQuoteID :many
SELECT quote_id, carrier_naic, plan_type
FROM quote_supplemental_carrier_plan_type
WHERE quote_id = $1
ORDER BY quote_id, carrier_naic, plan_type
`

func (q *Queries) ListQuoteSupplementalPlansByQuoteID(ctx context.Context, db DBTX, quoteID int64) ([]*QuoteSupplementalCarrierPlanType, error) {
	rows, err := db.Query(ctx, listQuoteSupplementalPlansByQuoteID, quoteID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*QuoteSupplementalCarrierPlanType
	for rows.Next() {
		var i QuoteSupplementalCarrierPlanType
		if err := rows.Scan(&i.QuoteID, &i.CarrierNaic, &i.PlanType); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listQuoteSupplementalPlansByQuoteIDS = `-- name: ListQuoteSupplementalPlansByQuoteIDS :many
SELECT quote_id, carrier_naic, plan_type
FROM quote_supplemental_carrier_plan_type
WHERE quote_id = ANY($1::BIGINT[])
ORDER BY quote_id, carrier_naic, plan_type
`

func (q *Queries) ListQuoteSupplementalPlansByQuoteIDS(ctx context.Context, db DBTX, dollar_1 []int64) ([]*QuoteSupplementalCarrierPlanType, error) {
	rows, err := db.Query(ctx, listQuoteSupplementalPlansByQuoteIDS, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*QuoteSupplementalCarrierPlanType
	for rows.Next() {
		var i QuoteSupplementalCarrierPlanType
		if err := rows.Scan(&i.QuoteID, &i.CarrierNaic, &i.PlanType); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

================
File: internal/sqlc/quote.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: quote.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteQuote = `-- name: DeleteQuote :exec
DELETE FROM quote WHERE id = $1
`

func (q *Queries) DeleteQuote(ctx context.Context, db DBTX, id int64) error {
	_, err := db.Exec(ctx, deleteQuote, id)
	return err
}

const getNextQuoteID = `-- name: GetNextQuoteID :one
SELECT nextval('quote_id_seq')
`

func (q *Queries) GetNextQuoteID(ctx context.Context, db DBTX) (int64, error) {
	row := db.QueryRow(ctx, getNextQuoteID)
	var nextval int64
	err := row.Scan(&nextval)
	return nextval, err
}

const getQuote = `-- name: GetQuote :one
SELECT id, url_id, parent_id, agent_id, client_id, effective_date, irmaa_bracket_id, drug_quote_id, dental_quote_id, has_multi_insured_discount, has_living_with_someone_discount, created_at, updated_at FROM quote WHERE id = $1
`

func (q *Queries) GetQuote(ctx context.Context, db DBTX, id int64) (*Quote, error) {
	row := db.QueryRow(ctx, getQuote, id)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.ParentID,
		&i.AgentID,
		&i.ClientID,
		&i.EffectiveDate,
		&i.IrmaaBracketID,
		&i.DrugQuoteID,
		&i.DentalQuoteID,
		&i.HasMultiInsuredDiscount,
		&i.HasLivingWithSomeoneDiscount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getQuoteByParentID = `-- name: GetQuoteByParentID :one
SELECT id, url_id, parent_id, agent_id, client_id, effective_date, irmaa_bracket_id, drug_quote_id, dental_quote_id, has_multi_insured_discount, has_living_with_someone_discount, created_at, updated_at FROM quote WHERE parent_id = $1
`

func (q *Queries) GetQuoteByParentID(ctx context.Context, db DBTX, parentID pgtype.Int8) (*Quote, error) {
	row := db.QueryRow(ctx, getQuoteByParentID, parentID)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.ParentID,
		&i.AgentID,
		&i.ClientID,
		&i.EffectiveDate,
		&i.IrmaaBracketID,
		&i.DrugQuoteID,
		&i.DentalQuoteID,
		&i.HasMultiInsuredDiscount,
		&i.HasLivingWithSomeoneDiscount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const getQuoteByUrlID = `-- name: GetQuoteByUrlID :one
SELECT id, url_id, parent_id, agent_id, client_id, effective_date, irmaa_bracket_id, drug_quote_id, dental_quote_id, has_multi_insured_discount, has_living_with_someone_discount, created_at, updated_at FROM quote WHERE url_id = $1
`

func (q *Queries) GetQuoteByUrlID(ctx context.Context, db DBTX, urlID string) (*Quote, error) {
	row := db.QueryRow(ctx, getQuoteByUrlID, urlID)
	var i Quote
	err := row.Scan(
		&i.ID,
		&i.UrlID,
		&i.ParentID,
		&i.AgentID,
		&i.ClientID,
		&i.EffectiveDate,
		&i.IrmaaBracketID,
		&i.DrugQuoteID,
		&i.DentalQuoteID,
		&i.HasMultiInsuredDiscount,
		&i.HasLivingWithSomeoneDiscount,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return &i, err
}

const upsertQuote = `-- name: UpsertQuote :exec
INSERT INTO quote (id, url_id, parent_id, agent_id, client_id, effective_date, irmaa_bracket_id, drug_quote_id, dental_quote_id, has_multi_insured_discount, has_living_with_someone_discount, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
ON CONFLICT (id)
DO UPDATE SET
    url_id = $2,
    parent_id = $3,
    agent_id = $4,
    client_id = $5,
    effective_date = $6,
    irmaa_bracket_id = $7,
    drug_quote_id = $8,
    dental_quote_id = $9,
    has_multi_insured_discount = $10,
    has_living_with_someone_discount = $11,
    created_at = $12,
    updated_at = $13
`

type UpsertQuoteParams struct {
	ID                           int64
	UrlID                        string
	ParentID                     pgtype.Int8
	AgentID                      int64
	ClientID                     int64
	EffectiveDate                pgtype.Date
	IrmaaBracketID               int64
	DrugQuoteID                  pgtype.Int8
	DentalQuoteID                pgtype.Int8
	HasMultiInsuredDiscount      bool
	HasLivingWithSomeoneDiscount bool
	CreatedAt                    pgtype.Timestamptz
	UpdatedAt                    pgtype.Timestamptz
}

func (q *Queries) UpsertQuote(ctx context.Context, db DBTX, arg UpsertQuoteParams) error {
	_, err := db.Exec(ctx, upsertQuote,
		arg.ID,
		arg.UrlID,
		arg.ParentID,
		arg.AgentID,
		arg.ClientID,
		arg.EffectiveDate,
		arg.IrmaaBracketID,
		arg.DrugQuoteID,
		arg.DentalQuoteID,
		arg.HasMultiInsuredDiscount,
		arg.HasLivingWithSomeoneDiscount,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

================
File: internal/sqlc/supplemental_carrier_logo.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: supplemental_carrier_logo.sql

package sqlc

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const listSupplementalCarrierLogosByNaics = `-- name: ListSupplementalCarrierLogosByNaics :many
SELECT
    supplemental_carrier_logo.carrier_naic,
    carrier_logo.key,
    supplemental_carrier_logo.created_at
FROM supplemental_carrier_logo
INNER JOIN carrier_logo ON supplemental_carrier_logo.carrier_logo_id = carrier_logo.id
WHERE supplemental_carrier_logo.carrier_naic = ANY($1::TEXT[])
`

type ListSupplementalCarrierLogosByNaicsRow struct {
	CarrierNaic string
	Key         string
	CreatedAt   pgtype.Timestamptz
}

func (q *Queries) ListSupplementalCarrierLogosByNaics(ctx context.Context, db DBTX, dollar_1 []string) ([]*ListSupplementalCarrierLogosByNaicsRow, error) {
	rows, err := db.Query(ctx, listSupplementalCarrierLogosByNaics, dollar_1)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ListSupplementalCarrierLogosByNaicsRow
	for rows.Next() {
		var i ListSupplementalCarrierLogosByNaicsRow
		if err := rows.Scan(&i.CarrierNaic, &i.Key, &i.CreatedAt); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

================
File: internal/sqlc/zip_code_county.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: zip_code_county.sql

package sqlc

import (
	"context"
)

const listZipCodeCountiesByZipCode = `-- name: ListZipCodeCountiesByZipCode :many
SELECT zip_code, county_fips_code
FROM zip_code_county
WHERE zip_code = $1
ORDER BY zip_code, county_fips_code
`

func (q *Queries) ListZipCodeCountiesByZipCode(ctx context.Context, db DBTX, zipCode string) ([]*ZipCodeCounty, error) {
	rows, err := db.Query(ctx, listZipCodeCountiesByZipCode, zipCode)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*ZipCodeCounty
	for rows.Next() {
		var i ZipCodeCounty
		if err := rows.Scan(&i.ZipCode, &i.CountyFipsCode); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertZipCodeCounty = `-- name: UpsertZipCodeCounty :exec
INSERT INTO zip_code_county (zip_code, county_fips_code) VALUES ($1, $2) ON CONFLICT (zip_code, county_fips_code) DO NOTHING
`

type UpsertZipCodeCountyParams struct {
	ZipCode        string
	CountyFipsCode string
}

func (q *Queries) UpsertZipCodeCounty(ctx context.Context, db DBTX, arg UpsertZipCodeCountyParams) error {
	_, err := db.Exec(ctx, upsertZipCodeCounty, arg.ZipCode, arg.CountyFipsCode)
	return err
}

================
File: internal/sqlc/zip_code.sql.go
================
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: zip_code.sql

package sqlc

import (
	"context"
)

const upsertZipCode = `-- name: UpsertZipCode :exec
INSERT INTO zip_code (code) VALUES ($1) ON CONFLICT (code) DO NOTHING
`

func (q *Queries) UpsertZipCode(ctx context.Context, db DBTX, code string) error {
	_, err := db.Exec(ctx, upsertZipCode, code)
	return err
}

================
File: rpc/maxquote/service.gen.go
================
// maxquote v1.0.0 f34af1b51e563b8f4f8183c601276d17c844215c
// --
// Code generated by webrpc-gen@v0.20.0 with golang generator. DO NOT EDIT.
//
// webrpc-gen -schema=rpc/maxquote/service.ridl -target=golang -pkg=rpc -server -out=rpc/maxquote/service.gen.go
package rpc

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"strings"
	"time"
)

// WebRPC description and code-gen version
func WebRPCVersion() string {
	return "v1"
}

// Schema version of your RIDL schema
func WebRPCSchemaVersion() string {
	return "v1.0.0"
}

// Schema hash generated from your RIDL schema
func WebRPCSchemaHash() string {
	return "f34af1b51e563b8f4f8183c601276d17c844215c"
}

//
// Common types
//

type CarrierGroup string

const (
	CarrierGroup_Supported CarrierGroup = "Supported"
	CarrierGroup_All       CarrierGroup = "All"
)

func (x CarrierGroup) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *CarrierGroup) UnmarshalText(b []byte) error {
	*x = CarrierGroup(string(b))
	return nil
}

func (x *CarrierGroup) Is(values ...CarrierGroup) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type Gender string

const (
	Gender_Male   Gender = "Male"
	Gender_Female Gender = "Female"
)

func (x Gender) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *Gender) UnmarshalText(b []byte) error {
	*x = Gender(string(b))
	return nil
}

func (x *Gender) Is(values ...Gender) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type FilingType string

const (
	FilingType_Individual              FilingType = "Individual"
	FilingType_MarriedFilingJointly    FilingType = "MarriedFilingJointly"
	FilingType_MarriedFilingSeparately FilingType = "MarriedFilingSeparately"
)

func (x FilingType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *FilingType) UnmarshalText(b []byte) error {
	*x = FilingType(string(b))
	return nil
}

func (x *FilingType) Is(values ...FilingType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SupplementalPlanType string

const (
	SupplementalPlanType_F SupplementalPlanType = "F"
	SupplementalPlanType_G SupplementalPlanType = "G"
	SupplementalPlanType_N SupplementalPlanType = "N"
)

func (x SupplementalPlanType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *SupplementalPlanType) UnmarshalText(b []byte) error {
	*x = SupplementalPlanType(string(b))
	return nil
}

func (x *SupplementalPlanType) Is(values ...SupplementalPlanType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type DiscountCategory string

const (
	DiscountCategory_MultiInsured      DiscountCategory = "MultiInsured"
	DiscountCategory_LivingWithSomeone DiscountCategory = "LivingWithSomeone"
)

func (x DiscountCategory) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *DiscountCategory) UnmarshalText(b []byte) error {
	*x = DiscountCategory(string(b))
	return nil
}

func (x *DiscountCategory) Is(values ...DiscountCategory) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type SearchResultType string

const (
	SearchResultType_Client SearchResultType = "Client"
	SearchResultType_Quote  SearchResultType = "Quote"
)

func (x SearchResultType) MarshalText() ([]byte, error) {
	return []byte(x), nil
}

func (x *SearchResultType) UnmarshalText(b []byte) error {
	*x = SearchResultType(string(b))
	return nil
}

func (x *SearchResultType) Is(values ...SearchResultType) bool {
	if x == nil {
		return false
	}
	for _, v := range values {
		if *x == v {
			return true
		}
	}
	return false
}

type County struct {
	FipsCode       string `json:"fipsCode"`
	Name           string `json:"name"`
	StateAlphaCode string `json:"stateAlphaCode"`
}

type Agent struct {
	Id        int64     `json:"id"`
	FirstName string    `json:"firstName"`
	LastName  string    `json:"lastName"`
	Email     string    `json:"email"`
	Phone     string    `json:"phone"`
	PhoneExt  *int32    `json:"phoneExt"`
	CreatedAt time.Time `json:"createdAt"`
	UpdatedAt time.Time `json:"updatedAt"`
}

type Client struct {
	Id            int64     `json:"id"`
	FirstName     string    `json:"firstName"`
	LastName      string    `json:"lastName"`
	DateOfBirth   string    `json:"dateOfBirth"`
	Age           int32     `json:"age"`
	Gender        Gender    `json:"gender"`
	ZipCode       string    `json:"zipCode"`
	County        *County   `json:"county"`
	Email         *string   `json:"email"`
	Phone         *string   `json:"phone"`
	IsTobaccoUser bool      `json:"isTobaccoUser"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

type IrmaaBracket struct {
	Id                       int64      `json:"id"`
	Year                     int32      `json:"year"`
	FilingType               FilingType `json:"filingType"`
	FromCents                int32      `json:"fromCents"`
	ToCents                  *int32     `json:"toCents"`
	PartBIrmaaCents          int32      `json:"partBIrmaaCents"`
	PartBMonthlyPremiumCents int32      `json:"partBMonthlyPremiumCents"`
	PartDIrmaaCents          int32      `json:"partDIrmaaCents"`
}

type Carrier struct {
	Naic        string  `json:"naic"`
	Name        string  `json:"name"`
	IsPreferred bool    `json:"isPreferred"`
	LogoUrl     *string `json:"logoUrl"`
}

type DrugQuote struct {
	Id               int64  `json:"id"`
	ContractYear     int32  `json:"contractYear"`
	ContractId       string `json:"contractId"`
	PlanId           int32  `json:"planId"`
	StateAlphaCode   string `json:"stateAlphaCode"`
	CompanyName      string `json:"companyName"`
	PlanName         string `json:"planName"`
	MonthlyRateCents int32  `json:"monthlyRateCents"`
}

type SupplementalQuote struct {
	Carrier                            *Carrier             `json:"carrier"`
	PlanType                           SupplementalPlanType `json:"planType"`
	MonthlyRateCents                   int32                `json:"monthlyRateCents"`
	MultiInsuredDiscountRateCents      *int32               `json:"multiInsuredDiscountRateCents"`
	LivingWithSomeoneDiscountRateCents *int32               `json:"livingWithSomeoneDiscountRateCents"`
}

type DentalQuote struct {
	Id                 int64  `json:"id"`
	StateAlphaCode     string `json:"stateAlphaCode"`
	CarrierNaic        string `json:"carrierNaic"`
	CarrierName        string `json:"carrierName"`
	AnnualBenefitCents int32  `json:"annualBenefitCents"`
	MonthlyRateCents   int32  `json:"monthlyRateCents"`
}

type Quote struct {
	Id                           int64                          `json:"id"`
	ParentId                     *int64                         `json:"parentId"`
	UrlId                        string                         `json:"urlId"`
	Agent                        *Agent                         `json:"agent"`
	Client                       *Client                        `json:"client"`
	EffectiveDate                time.Time                      `json:"effectiveDate"`
	IrmaaBracket                 *IrmaaBracket                  `json:"irmaaBracket"`
	DrugQuote                    *DrugQuote                     `json:"drugQuote"`
	DentalQuote                  *DentalQuote                   `json:"dentalQuote"`
	SupplementalCarrierPlanTypes []*SupplementalCarrierPlanType `json:"supplementalCarrierPlanTypes"`
	HasMultiInsuredDiscount      bool                           `json:"hasMultiInsuredDiscount"`
	HasLivingWithSomeoneDiscount bool                           `json:"hasLivingWithSomeoneDiscount"`
	CreatedAt                    time.Time                      `json:"createdAt"`
	UpdatedAt                    time.Time                      `json:"updatedAt"`
}

type ShortQuote struct {
	Id            int64     `json:"id"`
	UrlId         string    `json:"urlId"`
	Agent         *Agent    `json:"agent"`
	Client        *Client   `json:"client"`
	EffectiveDate time.Time `json:"effectiveDate"`
	CreatedAt     time.Time `json:"createdAt"`
	UpdatedAt     time.Time `json:"updatedAt"`
}

type SupplementalCarrierPlanType struct {
	CarrierNaic string               `json:"carrierNaic"`
	PlanType    SupplementalPlanType `json:"planType"`
}

type SearchResult struct {
	Type                 SearchResultType `json:"type"`
	PrimaryDescription   string           `json:"primaryDescription"`
	SecondaryDescription string           `json:"secondaryDescription"`
	Id                   int64            `json:"id"`
}

type CreateClientParams struct {
	FirstName      string  `json:"firstName"`
	LastName       string  `json:"lastName"`
	DateOfBirth    string  `json:"dateOfBirth"`
	Gender         Gender  `json:"gender"`
	ZipCode        string  `json:"zipCode"`
	CountyFipsCode string  `json:"countyFipsCode"`
	Email          *string `json:"email"`
	Phone          *string `json:"phone"`
	IsTobaccoUser  bool    `json:"isTobaccoUser"`
}

type UpdateClientParams struct {
	Id             int64   `json:"id"`
	FirstName      string  `json:"firstName"`
	LastName       string  `json:"lastName"`
	DateOfBirth    string  `json:"dateOfBirth"`
	Gender         Gender  `json:"gender"`
	ZipCode        string  `json:"zipCode"`
	CountyFipsCode string  `json:"countyFipsCode"`
	Email          *string `json:"email"`
	Phone          *string `json:"phone"`
	IsTobaccoUser  bool    `json:"isTobaccoUser"`
}

type CreateQuoteParams struct {
	ClientId                     int64                          `json:"clientId"`
	EffectiveDate                string                         `json:"effectiveDate"`
	IrmaaBracketId               int64                          `json:"irmaaBracketId"`
	DrugQuoteId                  *int64                         `json:"drugQuoteId"`
	DentalQuoteId                *int64                         `json:"dentalQuoteId"`
	SupplementalCarrierPlanTypes []*SupplementalCarrierPlanType `json:"supplementalCarrierPlanTypes"`
	HasMultiInsuredDiscount      bool                           `json:"hasMultiInsuredDiscount"`
	HasLivingWithSomeoneDiscount bool                           `json:"hasLivingWithSomeoneDiscount"`
}

type UpdateQuoteParams struct {
	Id                           int64                          `json:"id"`
	ClientId                     int64                          `json:"clientId"`
	EffectiveDate                string                         `json:"effectiveDate"`
	IrmaaBracketId               int64                          `json:"irmaaBracketId"`
	DrugQuoteId                  *int64                         `json:"drugQuoteId"`
	DentalQuoteId                *int64                         `json:"dentalQuoteId"`
	SupplementalCarrierPlanTypes []*SupplementalCarrierPlanType `json:"supplementalCarrierPlanTypes"`
	HasMultiInsuredDiscount      bool                           `json:"hasMultiInsuredDiscount"`
	HasLivingWithSomeoneDiscount bool                           `json:"hasLivingWithSomeoneDiscount"`
}

type UpdateSpouseQuoteParams struct {
	ClientId                     int64                          `json:"clientId"`
	EffectiveDate                string                         `json:"effectiveDate"`
	IrmaaBracketId               int64                          `json:"irmaaBracketId"`
	DrugQuoteId                  *int64                         `json:"drugQuoteId"`
	DentalQuoteId                *int64                         `json:"dentalQuoteId"`
	SupplementalCarrierPlanTypes []*SupplementalCarrierPlanType `json:"supplementalCarrierPlanTypes"`
	HasMultiInsuredDiscount      bool                           `json:"hasMultiInsuredDiscount"`
	HasLivingWithSomeoneDiscount bool                           `json:"hasLivingWithSomeoneDiscount"`
}

type ListQuotesParams struct {
	ClientId      *int64 `json:"clientId"`
	StartingAfter *int64 `json:"startingAfter"`
	EndingBefore  *int64 `json:"endingBefore"`
	Limit         int32  `json:"limit"`
}

type ListQuotesResponse struct {
	Data       []*ShortQuote `json:"data"`
	TotalCount int32         `json:"totalCount"`
	HasMore    bool          `json:"hasMore"`
}

type GetQuoteResponse struct {
	Quote       *Quote `json:"quote"`
	SpouseQuote *Quote `json:"spouseQuote"`
}

type PublicQuotePageData struct {
	Client *PublicQuoteClientData `json:"client"`
	Spouse *PublicQuoteClientData `json:"spouse"`
}

type PublicQuoteClientData struct {
	Quote        *Quote        `json:"quote"`
	IrmaaBracket *IrmaaBracket `json:"irmaaBracket"`
	DrugQuote    *DrugQuote    `json:"drugQuote"`
}

var (
	methods = map[string]method{
		"/rpc/Dashboard/WhoAmI": {
			Name:        "WhoAmI",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/SignOut": {
			Name:        "SignOut",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/Search": {
			Name:        "Search",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/ListCountiesByZipCode": {
			Name:        "ListCountiesByZipCode",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/SearchClients": {
			Name:        "SearchClients",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/GetClient": {
			Name:        "GetClient",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/IsClientEmailTaken": {
			Name:        "IsClientEmailTaken",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/CreateClient": {
			Name:        "CreateClient",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/UpdateClient": {
			Name:        "UpdateClient",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/ListIrmaaBracketsByEffectiveDate": {
			Name:        "ListIrmaaBracketsByEffectiveDate",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/ListDrugQuotesByClientIdAndEffectiveDate": {
			Name:        "ListDrugQuotesByClientIdAndEffectiveDate",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/ListDentalQuotesByClientId": {
			Name:        "ListDentalQuotesByClientId",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/ListSupplementalQuotesByClientIdAndEffectiveDate": {
			Name:        "ListSupplementalQuotesByClientIdAndEffectiveDate",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/ListSupplementalQuotesForQuote": {
			Name:        "ListSupplementalQuotesForQuote",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/ListQuotes": {
			Name:        "ListQuotes",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/GetQuote": {
			Name:        "GetQuote",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/GetSpouseQuote": {
			Name:        "GetSpouseQuote",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/CreateQuote": {
			Name:        "CreateQuote",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/UpdateQuote": {
			Name:        "UpdateQuote",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Dashboard/SendQuote": {
			Name:        "SendQuote",
			Service:     "Dashboard",
			Annotations: map[string]string{},
		},
		"/rpc/Public/GetQuote": {
			Name:        "GetQuote",
			Service:     "Public",
			Annotations: map[string]string{},
		},
		"/rpc/Public/GetSpouseQuote": {
			Name:        "GetSpouseQuote",
			Service:     "Public",
			Annotations: map[string]string{},
		},
		"/rpc/Public/ListSupplementalQuotesForQuote": {
			Name:        "ListSupplementalQuotesForQuote",
			Service:     "Public",
			Annotations: map[string]string{},
		},
	}
)

var WebRPCServices = map[string][]string{
	"Dashboard": {
		"WhoAmI",
		"SignOut",
		"Search",
		"ListCountiesByZipCode",
		"SearchClients",
		"GetClient",
		"IsClientEmailTaken",
		"CreateClient",
		"UpdateClient",
		"ListIrmaaBracketsByEffectiveDate",
		"ListDrugQuotesByClientIdAndEffectiveDate",
		"ListDentalQuotesByClientId",
		"ListSupplementalQuotesByClientIdAndEffectiveDate",
		"ListSupplementalQuotesForQuote",
		"ListQuotes",
		"GetQuote",
		"GetSpouseQuote",
		"CreateQuote",
		"UpdateQuote",
		"SendQuote",
	},
	"Public": {
		"GetQuote",
		"GetSpouseQuote",
		"ListSupplementalQuotesForQuote",
	},
}

//
// Server types
//

type Dashboard interface {
	// Agent
	WhoAmI(ctx context.Context) (*Agent, error)
	SignOut(ctx context.Context) error
	// Global search
	Search(ctx context.Context, term string) ([]*SearchResult, error)
	// County
	ListCountiesByZipCode(ctx context.Context, zipCode string) ([]*County, error)
	// Client
	SearchClients(ctx context.Context, term string) ([]*Client, error)
	GetClient(ctx context.Context, id int64) (*Client, error)
	IsClientEmailTaken(ctx context.Context, email string, excludeId *int64) (bool, error)
	CreateClient(ctx context.Context, params *CreateClientParams) (*Client, error)
	UpdateClient(ctx context.Context, params *UpdateClientParams) (*Client, error)
	// Irmaa bracket
	ListIrmaaBracketsByEffectiveDate(ctx context.Context, effectiveDate string) ([]*IrmaaBracket, error)
	// Drug quote
	ListDrugQuotesByClientIdAndEffectiveDate(ctx context.Context, clientId int64, effectiveDate string) ([]*DrugQuote, error)
	// Dental quote
	ListDentalQuotesByClientId(ctx context.Context, clientId int64) ([]*DentalQuote, error)
	// Supplemental quote
	ListSupplementalQuotesByClientIdAndEffectiveDate(ctx context.Context, clientId int64, effectiveDate string, plans []SupplementalPlanType, carrierGroup CarrierGroup) ([]*SupplementalQuote, error)
	ListSupplementalQuotesForQuote(ctx context.Context, quoteId int64) ([]*SupplementalQuote, error)
	// Quote
	ListQuotes(ctx context.Context, params *ListQuotesParams) (*ListQuotesResponse, error)
	GetQuote(ctx context.Context, id int64) (*Quote, error)
	GetSpouseQuote(ctx context.Context, id int64) (*Quote, error)
	CreateQuote(ctx context.Context, client *CreateQuoteParams, spouse *CreateQuoteParams) (*Quote, error)
	UpdateQuote(ctx context.Context, client *UpdateQuoteParams, spouse *UpdateSpouseQuoteParams) (*Quote, error)
	SendQuote(ctx context.Context, id int64, emailOrPhone string) error
}

type Public interface {
	GetQuote(ctx context.Context, urlId string) (*Quote, error)
	GetSpouseQuote(ctx context.Context, urlId string) (*Quote, error)
	ListSupplementalQuotesForQuote(ctx context.Context, urlId string) ([]*SupplementalQuote, error)
}

//
// Client types
//

type DashboardClient interface {
	// Agent
	WhoAmI(ctx context.Context) (*Agent, error)
	SignOut(ctx context.Context) error
	// Global search
	Search(ctx context.Context, term string) ([]*SearchResult, error)
	// County
	ListCountiesByZipCode(ctx context.Context, zipCode string) ([]*County, error)
	// Client
	SearchClients(ctx context.Context, term string) ([]*Client, error)
	GetClient(ctx context.Context, id int64) (*Client, error)
	IsClientEmailTaken(ctx context.Context, email string, excludeId *int64) (bool, error)
	CreateClient(ctx context.Context, params *CreateClientParams) (*Client, error)
	UpdateClient(ctx context.Context, params *UpdateClientParams) (*Client, error)
	// Irmaa bracket
	ListIrmaaBracketsByEffectiveDate(ctx context.Context, effectiveDate string) ([]*IrmaaBracket, error)
	// Drug quote
	ListDrugQuotesByClientIdAndEffectiveDate(ctx context.Context, clientId int64, effectiveDate string) ([]*DrugQuote, error)
	// Dental quote
	ListDentalQuotesByClientId(ctx context.Context, clientId int64) ([]*DentalQuote, error)
	// Supplemental quote
	ListSupplementalQuotesByClientIdAndEffectiveDate(ctx context.Context, clientId int64, effectiveDate string, plans []SupplementalPlanType, carrierGroup CarrierGroup) ([]*SupplementalQuote, error)
	ListSupplementalQuotesForQuote(ctx context.Context, quoteId int64) ([]*SupplementalQuote, error)
	// Quote
	ListQuotes(ctx context.Context, params *ListQuotesParams) (*ListQuotesResponse, error)
	GetQuote(ctx context.Context, id int64) (*Quote, error)
	GetSpouseQuote(ctx context.Context, id int64) (*Quote, error)
	CreateQuote(ctx context.Context, client *CreateQuoteParams, spouse *CreateQuoteParams) (*Quote, error)
	UpdateQuote(ctx context.Context, client *UpdateQuoteParams, spouse *UpdateSpouseQuoteParams) (*Quote, error)
	SendQuote(ctx context.Context, id int64, emailOrPhone string) error
}

type PublicClient interface {
	GetQuote(ctx context.Context, urlId string) (*Quote, error)
	GetSpouseQuote(ctx context.Context, urlId string) (*Quote, error)
	ListSupplementalQuotesForQuote(ctx context.Context, urlId string) ([]*SupplementalQuote, error)
}

//
// Server
//

type WebRPCServer interface {
	http.Handler
}

type dashboardServer struct {
	Dashboard
	OnError   func(r *http.Request, rpcErr *WebRPCError)
	OnRequest func(w http.ResponseWriter, r *http.Request) error
}

func NewDashboardServer(svc Dashboard) *dashboardServer {
	return &dashboardServer{
		Dashboard: svc,
	}
}

func (s *dashboardServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer func() {
		// In case of a panic, serve a HTTP 500 error and then panic.
		if rr := recover(); rr != nil {
			s.sendErrorJSON(w, r, ErrWebrpcServerPanic.WithCause(fmt.Errorf("%v", rr)))
			panic(rr)
		}
	}()

	ctx := r.Context()
	ctx = context.WithValue(ctx, HTTPResponseWriterCtxKey, w)
	ctx = context.WithValue(ctx, HTTPRequestCtxKey, r)
	ctx = context.WithValue(ctx, ServiceNameCtxKey, "Dashboard")

	r = r.WithContext(ctx)

	var handler func(ctx context.Context, w http.ResponseWriter, r *http.Request)
	switch r.URL.Path {
	case "/rpc/Dashboard/WhoAmI":
		handler = s.serveWhoAmIJSON
	case "/rpc/Dashboard/SignOut":
		handler = s.serveSignOutJSON
	case "/rpc/Dashboard/Search":
		handler = s.serveSearchJSON
	case "/rpc/Dashboard/ListCountiesByZipCode":
		handler = s.serveListCountiesByZipCodeJSON
	case "/rpc/Dashboard/SearchClients":
		handler = s.serveSearchClientsJSON
	case "/rpc/Dashboard/GetClient":
		handler = s.serveGetClientJSON
	case "/rpc/Dashboard/IsClientEmailTaken":
		handler = s.serveIsClientEmailTakenJSON
	case "/rpc/Dashboard/CreateClient":
		handler = s.serveCreateClientJSON
	case "/rpc/Dashboard/UpdateClient":
		handler = s.serveUpdateClientJSON
	case "/rpc/Dashboard/ListIrmaaBracketsByEffectiveDate":
		handler = s.serveListIrmaaBracketsByEffectiveDateJSON
	case "/rpc/Dashboard/ListDrugQuotesByClientIdAndEffectiveDate":
		handler = s.serveListDrugQuotesByClientIdAndEffectiveDateJSON
	case "/rpc/Dashboard/ListDentalQuotesByClientId":
		handler = s.serveListDentalQuotesByClientIdJSON
	case "/rpc/Dashboard/ListSupplementalQuotesByClientIdAndEffectiveDate":
		handler = s.serveListSupplementalQuotesByClientIdAndEffectiveDateJSON
	case "/rpc/Dashboard/ListSupplementalQuotesForQuote":
		handler = s.serveListSupplementalQuotesForQuoteJSON
	case "/rpc/Dashboard/ListQuotes":
		handler = s.serveListQuotesJSON
	case "/rpc/Dashboard/GetQuote":
		handler = s.serveGetQuoteJSON
	case "/rpc/Dashboard/GetSpouseQuote":
		handler = s.serveGetSpouseQuoteJSON
	case "/rpc/Dashboard/CreateQuote":
		handler = s.serveCreateQuoteJSON
	case "/rpc/Dashboard/UpdateQuote":
		handler = s.serveUpdateQuoteJSON
	case "/rpc/Dashboard/SendQuote":
		handler = s.serveSendQuoteJSON
	default:
		err := ErrWebrpcBadRoute.WithCause(fmt.Errorf("no WebRPC method defined for path %v", r.URL.Path))
		s.sendErrorJSON(w, r, err)
		return
	}

	if r.Method != "POST" {
		w.Header().Add("Allow", "POST") // RFC 9110.
		err := ErrWebrpcBadMethod.WithCause(fmt.Errorf("unsupported method %v (only POST is allowed)", r.Method))
		s.sendErrorJSON(w, r, err)
		return
	}

	contentType := r.Header.Get("Content-Type")
	if i := strings.Index(contentType, ";"); i >= 0 {
		contentType = contentType[:i]
	}
	contentType = strings.TrimSpace(strings.ToLower(contentType))

	switch contentType {
	case "application/json":
		if s.OnRequest != nil {
			if err := s.OnRequest(w, r); err != nil {
				rpcErr, ok := err.(WebRPCError)
				if !ok {
					rpcErr = ErrWebrpcEndpoint.WithCause(err)
				}
				s.sendErrorJSON(w, r, rpcErr)
				return
			}
		}

		handler(ctx, w, r)
	default:
		err := ErrWebrpcBadRequest.WithCause(fmt.Errorf("unsupported Content-Type %q (only application/json is allowed)", r.Header.Get("Content-Type")))
		s.sendErrorJSON(w, r, err)
	}
}

func (s *dashboardServer) serveWhoAmIJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "WhoAmI")

	// Call service method implementation.
	ret0, err := s.Dashboard.WhoAmI(ctx)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Agent `json:"agent"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveSignOutJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "SignOut")

	// Call service method implementation.
	err := s.Dashboard.SignOut(ctx)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

func (s *dashboardServer) serveSearchJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "Search")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"term"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.Search(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*SearchResult `json:"results"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveListCountiesByZipCodeJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ListCountiesByZipCode")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"zipCode"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.ListCountiesByZipCode(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*County `json:"counties"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveSearchClientsJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "SearchClients")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"term"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.SearchClients(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*Client `json:"clients"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveGetClientJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetClient")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int64 `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.GetClient(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Client `json:"client"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveIsClientEmailTakenJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "IsClientEmailTaken")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"email"`
		Arg1 *int64 `json:"excludeId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.IsClientEmailTaken(ctx, reqPayload.Arg0, reqPayload.Arg1)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 bool `json:"isTaken"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveCreateClientJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "CreateClient")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 *CreateClientParams `json:"params"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.CreateClient(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Client `json:"client"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveUpdateClientJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "UpdateClient")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 *UpdateClientParams `json:"params"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.UpdateClient(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Client `json:"client"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveListIrmaaBracketsByEffectiveDateJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ListIrmaaBracketsByEffectiveDate")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"effectiveDate"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.ListIrmaaBracketsByEffectiveDate(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*IrmaaBracket `json:"irmaaBrackets"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveListDrugQuotesByClientIdAndEffectiveDateJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ListDrugQuotesByClientIdAndEffectiveDate")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int64  `json:"clientId"`
		Arg1 string `json:"effectiveDate"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.ListDrugQuotesByClientIdAndEffectiveDate(ctx, reqPayload.Arg0, reqPayload.Arg1)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*DrugQuote `json:"quotes"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveListDentalQuotesByClientIdJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ListDentalQuotesByClientId")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int64 `json:"clientId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.ListDentalQuotesByClientId(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*DentalQuote `json:"quotes"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveListSupplementalQuotesByClientIdAndEffectiveDateJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ListSupplementalQuotesByClientIdAndEffectiveDate")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int64                  `json:"clientId"`
		Arg1 string                 `json:"effectiveDate"`
		Arg2 []SupplementalPlanType `json:"plans"`
		Arg3 CarrierGroup           `json:"carrierGroup"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.ListSupplementalQuotesByClientIdAndEffectiveDate(ctx, reqPayload.Arg0, reqPayload.Arg1, reqPayload.Arg2, reqPayload.Arg3)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*SupplementalQuote `json:"quotes"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveListSupplementalQuotesForQuoteJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ListSupplementalQuotesForQuote")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int64 `json:"quoteId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.ListSupplementalQuotesForQuote(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*SupplementalQuote `json:"quotes"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveListQuotesJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ListQuotes")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 *ListQuotesParams `json:"params"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.ListQuotes(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *ListQuotesResponse `json:"response"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveGetQuoteJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetQuote")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int64 `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.GetQuote(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Quote `json:"quote"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveGetSpouseQuoteJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetSpouseQuote")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int64 `json:"id"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.GetSpouseQuote(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Quote `json:"quote"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveCreateQuoteJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "CreateQuote")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 *CreateQuoteParams `json:"client"`
		Arg1 *CreateQuoteParams `json:"spouse"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.CreateQuote(ctx, reqPayload.Arg0, reqPayload.Arg1)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Quote `json:"quote"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveUpdateQuoteJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "UpdateQuote")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 *UpdateQuoteParams       `json:"client"`
		Arg1 *UpdateSpouseQuoteParams `json:"spouse"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Dashboard.UpdateQuote(ctx, reqPayload.Arg0, reqPayload.Arg1)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Quote `json:"quote"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *dashboardServer) serveSendQuoteJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "SendQuote")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 int64  `json:"id"`
		Arg1 string `json:"emailOrPhone"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	err = s.Dashboard.SendQuote(ctx, reqPayload.Arg0, reqPayload.Arg1)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write([]byte("{}"))
}

func (s *dashboardServer) sendErrorJSON(w http.ResponseWriter, r *http.Request, rpcErr WebRPCError) {
	if s.OnError != nil {
		s.OnError(r, &rpcErr)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(rpcErr.HTTPStatus)

	respBody, _ := json.Marshal(rpcErr)
	w.Write(respBody)
}

type publicServer struct {
	Public
	OnError   func(r *http.Request, rpcErr *WebRPCError)
	OnRequest func(w http.ResponseWriter, r *http.Request) error
}

func NewPublicServer(svc Public) *publicServer {
	return &publicServer{
		Public: svc,
	}
}

func (s *publicServer) ServeHTTP(w http.ResponseWriter, r *http.Request) {
	defer func() {
		// In case of a panic, serve a HTTP 500 error and then panic.
		if rr := recover(); rr != nil {
			s.sendErrorJSON(w, r, ErrWebrpcServerPanic.WithCause(fmt.Errorf("%v", rr)))
			panic(rr)
		}
	}()

	ctx := r.Context()
	ctx = context.WithValue(ctx, HTTPResponseWriterCtxKey, w)
	ctx = context.WithValue(ctx, HTTPRequestCtxKey, r)
	ctx = context.WithValue(ctx, ServiceNameCtxKey, "Public")

	r = r.WithContext(ctx)

	var handler func(ctx context.Context, w http.ResponseWriter, r *http.Request)
	switch r.URL.Path {
	case "/rpc/Public/GetQuote":
		handler = s.serveGetQuoteJSON
	case "/rpc/Public/GetSpouseQuote":
		handler = s.serveGetSpouseQuoteJSON
	case "/rpc/Public/ListSupplementalQuotesForQuote":
		handler = s.serveListSupplementalQuotesForQuoteJSON
	default:
		err := ErrWebrpcBadRoute.WithCause(fmt.Errorf("no WebRPC method defined for path %v", r.URL.Path))
		s.sendErrorJSON(w, r, err)
		return
	}

	if r.Method != "POST" {
		w.Header().Add("Allow", "POST") // RFC 9110.
		err := ErrWebrpcBadMethod.WithCause(fmt.Errorf("unsupported method %v (only POST is allowed)", r.Method))
		s.sendErrorJSON(w, r, err)
		return
	}

	contentType := r.Header.Get("Content-Type")
	if i := strings.Index(contentType, ";"); i >= 0 {
		contentType = contentType[:i]
	}
	contentType = strings.TrimSpace(strings.ToLower(contentType))

	switch contentType {
	case "application/json":
		if s.OnRequest != nil {
			if err := s.OnRequest(w, r); err != nil {
				rpcErr, ok := err.(WebRPCError)
				if !ok {
					rpcErr = ErrWebrpcEndpoint.WithCause(err)
				}
				s.sendErrorJSON(w, r, rpcErr)
				return
			}
		}

		handler(ctx, w, r)
	default:
		err := ErrWebrpcBadRequest.WithCause(fmt.Errorf("unsupported Content-Type %q (only application/json is allowed)", r.Header.Get("Content-Type")))
		s.sendErrorJSON(w, r, err)
	}
}

func (s *publicServer) serveGetQuoteJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetQuote")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"urlId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Public.GetQuote(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Quote `json:"quote"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *publicServer) serveGetSpouseQuoteJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "GetSpouseQuote")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"urlId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Public.GetSpouseQuote(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 *Quote `json:"quote"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *publicServer) serveListSupplementalQuotesForQuoteJSON(ctx context.Context, w http.ResponseWriter, r *http.Request) {
	ctx = context.WithValue(ctx, MethodNameCtxKey, "ListSupplementalQuotesForQuote")

	reqBody, err := io.ReadAll(r.Body)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to read request data: %w", err)))
		return
	}
	defer r.Body.Close()

	reqPayload := struct {
		Arg0 string `json:"urlId"`
	}{}
	if err := json.Unmarshal(reqBody, &reqPayload); err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadRequest.WithCause(fmt.Errorf("failed to unmarshal request data: %w", err)))
		return
	}

	// Call service method implementation.
	ret0, err := s.Public.ListSupplementalQuotesForQuote(ctx, reqPayload.Arg0)
	if err != nil {
		rpcErr, ok := err.(WebRPCError)
		if !ok {
			rpcErr = ErrWebrpcEndpoint.WithCause(err)
		}
		s.sendErrorJSON(w, r, rpcErr)
		return
	}

	respPayload := struct {
		Ret0 []*SupplementalQuote `json:"supplementalQuotes"`
	}{ret0}
	respBody, err := json.Marshal(respPayload)
	if err != nil {
		s.sendErrorJSON(w, r, ErrWebrpcBadResponse.WithCause(fmt.Errorf("failed to marshal json response: %w", err)))
		return
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(http.StatusOK)
	w.Write(respBody)
}

func (s *publicServer) sendErrorJSON(w http.ResponseWriter, r *http.Request, rpcErr WebRPCError) {
	if s.OnError != nil {
		s.OnError(r, &rpcErr)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(rpcErr.HTTPStatus)

	respBody, _ := json.Marshal(rpcErr)
	w.Write(respBody)
}

func RespondWithError(w http.ResponseWriter, err error) {
	rpcErr, ok := err.(WebRPCError)
	if !ok {
		rpcErr = ErrWebrpcEndpoint.WithCause(err)
	}

	w.Header().Set("Content-Type", "application/json")
	w.WriteHeader(rpcErr.HTTPStatus)

	respBody, _ := json.Marshal(rpcErr)
	w.Write(respBody)
}

//
// Helpers
//

type method struct {
	Name        string
	Service     string
	Annotations map[string]string
}

type contextKey struct {
	name string
}

func (k *contextKey) String() string {
	return "webrpc context value " + k.name
}

var (
	HTTPResponseWriterCtxKey = &contextKey{"HTTPResponseWriter"}

	HTTPRequestCtxKey = &contextKey{"HTTPRequest"}

	ServiceNameCtxKey = &contextKey{"ServiceName"}

	MethodNameCtxKey = &contextKey{"MethodName"}
)

func ServiceNameFromContext(ctx context.Context) string {
	service, _ := ctx.Value(ServiceNameCtxKey).(string)
	return service
}

func MethodNameFromContext(ctx context.Context) string {
	method, _ := ctx.Value(MethodNameCtxKey).(string)
	return method
}

func RequestFromContext(ctx context.Context) *http.Request {
	r, _ := ctx.Value(HTTPRequestCtxKey).(*http.Request)
	return r
}

func MethodCtx(ctx context.Context) (method, bool) {
	req := RequestFromContext(ctx)
	if req == nil {
		return method{}, false
	}

	m, ok := methods[req.URL.Path]
	if !ok {
		return method{}, false
	}

	return m, true
}

func ResponseWriterFromContext(ctx context.Context) http.ResponseWriter {
	w, _ := ctx.Value(HTTPResponseWriterCtxKey).(http.ResponseWriter)
	return w
}

//
// Errors
//

type WebRPCError struct {
	Name       string `json:"error"`
	Code       int    `json:"code"`
	Message    string `json:"msg"`
	Cause      string `json:"cause,omitempty"`
	HTTPStatus int    `json:"status"`
	cause      error
}

var _ error = WebRPCError{}

func (e WebRPCError) Error() string {
	if e.cause != nil {
		return fmt.Sprintf("%s %d: %s: %v", e.Name, e.Code, e.Message, e.cause)
	}
	return fmt.Sprintf("%s %d: %s", e.Name, e.Code, e.Message)
}

func (e WebRPCError) Is(target error) bool {
	if target == nil {
		return false
	}
	if rpcErr, ok := target.(WebRPCError); ok {
		return rpcErr.Code == e.Code
	}
	return errors.Is(e.cause, target)
}

func (e WebRPCError) Unwrap() error {
	return e.cause
}

func (e WebRPCError) WithCause(cause error) WebRPCError {
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

func (e WebRPCError) WithCausef(format string, args ...interface{}) WebRPCError {
	cause := fmt.Errorf(format, args...)
	err := e
	err.cause = cause
	err.Cause = cause.Error()
	return err
}

// Deprecated: Use .WithCause() method on WebRPCError.
func ErrorWithCause(rpcErr WebRPCError, cause error) WebRPCError {
	return rpcErr.WithCause(cause)
}

// Webrpc errors
var (
	ErrWebrpcEndpoint           = WebRPCError{Code: 0, Name: "WebrpcEndpoint", Message: "endpoint error", HTTPStatus: 400}
	ErrWebrpcRequestFailed      = WebRPCError{Code: -1, Name: "WebrpcRequestFailed", Message: "request failed", HTTPStatus: 400}
	ErrWebrpcBadRoute           = WebRPCError{Code: -2, Name: "WebrpcBadRoute", Message: "bad route", HTTPStatus: 404}
	ErrWebrpcBadMethod          = WebRPCError{Code: -3, Name: "WebrpcBadMethod", Message: "bad method", HTTPStatus: 405}
	ErrWebrpcBadRequest         = WebRPCError{Code: -4, Name: "WebrpcBadRequest", Message: "bad request", HTTPStatus: 400}
	ErrWebrpcBadResponse        = WebRPCError{Code: -5, Name: "WebrpcBadResponse", Message: "bad response", HTTPStatus: 500}
	ErrWebrpcServerPanic        = WebRPCError{Code: -6, Name: "WebrpcServerPanic", Message: "server panic", HTTPStatus: 500}
	ErrWebrpcInternalError      = WebRPCError{Code: -7, Name: "WebrpcInternalError", Message: "internal error", HTTPStatus: 500}
	ErrWebrpcClientDisconnected = WebRPCError{Code: -8, Name: "WebrpcClientDisconnected", Message: "client disconnected", HTTPStatus: 400}
	ErrWebrpcStreamLost         = WebRPCError{Code: -9, Name: "WebrpcStreamLost", Message: "stream lost", HTTPStatus: 400}
	ErrWebrpcStreamFinished     = WebRPCError{Code: -10, Name: "WebrpcStreamFinished", Message: "stream finished", HTTPStatus: 200}
)

// Schema errors
var (
	ErrEntityNotFound  = WebRPCError{Code: 100, Name: "EntityNotFound", Message: "entity not found", HTTPStatus: 404}
	ErrUnauthorized    = WebRPCError{Code: 101, Name: "Unauthorized", Message: "unauthorized", HTTPStatus: 401}
	ErrInvalidArgument = WebRPCError{Code: 102, Name: "InvalidArgument", Message: "invalid argument", HTTPStatus: 400}
	ErrInternal        = WebRPCError{Code: 103, Name: "Internal", Message: "internal", HTTPStatus: 500}
)

================
File: rpc/maxquote/service.ridl
================
webrpc = v1

name = maxquote
version = v1.0.0

enum CarrierGroup: string
    - Supported = "Supported"
    - All = "All"

enum Gender: string
    - Male = "Male"
    - Female = "Female"

enum FilingType: string
    - Individual = "Individual"
    - MarriedFilingJointly = "MarriedFilingJointly"
    - MarriedFilingSeparately = "MarriedFilingSeparately"

enum SupplementalPlanType: string
    - F = "F"
    - G = "G"
    - N = "N"

enum DiscountCategory: string
    - MultiInsured = "MultiInsured"
    - LivingWithSomeone = "LivingWithSomeone"

struct County
    - fipsCode: string
    - name: string
    - stateAlphaCode: string

struct Agent
    - id: int64
    - firstName: string
    - lastName: string
    - email: string
    - phone: string
    - phoneExt?: int32
    - createdAt: timestamp
    - updatedAt: timestamp

struct Client
    - id: int64
    - firstName: string
    - lastName: string
    - dateOfBirth: string
    - age: int32
    - gender: Gender
    - zipCode: string
    - county: County
    - email?: string
    - phone?: string
    - isTobaccoUser: bool
    - createdAt: timestamp
    - updatedAt: timestamp

struct IrmaaBracket
    - id: int64
    - year: int32
    - filingType: FilingType
    - fromCents: int32
    - toCents?: int32
    - partBIrmaaCents: int32
    - partBMonthlyPremiumCents: int32
    - partDIrmaaCents: int32

struct Carrier
    - naic: string
    - name: string
    - isPreferred: bool
    - logoUrl?: string

struct DrugQuote
    - id: int64
    - contractYear: int32
    - contractId: string
    - planId: int32
    - stateAlphaCode: string
    - companyName: string
    - planName: string
    - monthlyRateCents: int32

struct SupplementalQuote
    - carrier: Carrier
    - planType: SupplementalPlanType
    - monthlyRateCents: int32
    - multiInsuredDiscountRateCents?: int32
    - livingWithSomeoneDiscountRateCents?: int32

struct DentalQuote
    - id: int64
    - stateAlphaCode: string
    - carrierNaic: string
    - carrierName: string
    - annualBenefitCents: int32
    - monthlyRateCents: int32

struct Quote
    - id: int64
    - parentId?: int64
    - urlId: string
    - agent: Agent
    - client: Client
    - effectiveDate: timestamp
    - irmaaBracket: IrmaaBracket
    - drugQuote?: DrugQuote
    - dentalQuote?: DentalQuote
    - supplementalCarrierPlanTypes: []SupplementalCarrierPlanType
    - hasMultiInsuredDiscount: bool
    - hasLivingWithSomeoneDiscount: bool
    - createdAt: timestamp
    - updatedAt: timestamp

struct ShortQuote
    - id: int64
    - urlId: string
    - agent: Agent
    - client: Client
    - effectiveDate: timestamp
    - createdAt: timestamp
    - updatedAt: timestamp

struct SupplementalCarrierPlanType
    - carrierNaic: string
    - planType: SupplementalPlanType

enum SearchResultType: string
    - Client = "Client"
    - Quote = "Quote"

struct SearchResult
    - type: SearchResultType
    - primaryDescription: string
    - secondaryDescription: string
    - id: int64

service Dashboard
    # Agent
    - WhoAmI() => (agent: Agent)
    - SignOut() => ()

    # Global search
    - Search(term: string) => (results: []SearchResult)

    # County
    - ListCountiesByZipCode(zipCode: string) => (counties: []County)

    # Client
    - SearchClients(term: string) => (clients: []Client)
    - GetClient(id: int64) => (client: Client)
    - IsClientEmailTaken(email: string, excludeId?: int64) => (isTaken: bool)
    - CreateClient(params: CreateClientParams) => (client: Client)
    - UpdateClient(params: UpdateClientParams) => (client: Client)

    # Irmaa bracket
    - ListIrmaaBracketsByEffectiveDate(effectiveDate: string) => (irmaaBrackets: []IrmaaBracket)

    # Drug quote
    - ListDrugQuotesByClientIdAndEffectiveDate(clientId: int64, effectiveDate: string) => (quotes: []DrugQuote)

    # Dental quote
    - ListDentalQuotesByClientId(clientId: int64) => (quotes: []DentalQuote)

    # Supplemental quote
    - ListSupplementalQuotesByClientIdAndEffectiveDate(clientId: int64, effectiveDate: string, plans: []SupplementalPlanType, carrierGroup: CarrierGroup) => (quotes: []SupplementalQuote)
    - ListSupplementalQuotesForQuote(quoteId: int64) => (quotes: []SupplementalQuote)

    # Quote
    - ListQuotes(params: ListQuotesParams) => (response: ListQuotesResponse)
    - GetQuote(id: int64) => (quote: Quote)
    - GetSpouseQuote(id: int64) => (quote: Quote)
    - CreateQuote(client: CreateQuoteParams, spouse?:CreateQuoteParams) => (quote: Quote)
    - UpdateQuote(client: UpdateQuoteParams, spouse?:UpdateSpouseQuoteParams) => (quote: Quote)
    - SendQuote(id: int64, emailOrPhone: string) => ()

service Public
    - GetQuote(urlId: string) => (quote: Quote)
    - GetSpouseQuote(urlId: string) => (quote: Quote)
    - ListSupplementalQuotesForQuote(urlId: string) => (supplementalQuotes: []SupplementalQuote)

struct CreateClientParams
    - firstName: string
    - lastName: string
    - dateOfBirth: string
    - gender: Gender
    - zipCode: string
    - countyFipsCode: string
    - email?: string
    - phone?: string
    - isTobaccoUser: bool

struct UpdateClientParams
    - id: int64
    - firstName: string
    - lastName: string
    - dateOfBirth: string
    - gender: Gender
    - zipCode: string
    - countyFipsCode: string
    - email?: string
    - phone?: string
    - isTobaccoUser: bool

struct CreateQuoteParams
    - clientId: int64
    - effectiveDate: string
    - irmaaBracketId: int64
    - drugQuoteId?: int64
    - dentalQuoteId?: int64
    - supplementalCarrierPlanTypes: []SupplementalCarrierPlanType
    - hasMultiInsuredDiscount: bool
    - hasLivingWithSomeoneDiscount: bool

struct UpdateQuoteParams
    - id: int64
    - clientId: int64
    - effectiveDate: string
    - irmaaBracketId: int64
    - drugQuoteId?: int64
    - dentalQuoteId?: int64
    - supplementalCarrierPlanTypes: []SupplementalCarrierPlanType
    - hasMultiInsuredDiscount: bool
    - hasLivingWithSomeoneDiscount: bool

struct UpdateSpouseQuoteParams
    - clientId: int64
    - effectiveDate: string
    - irmaaBracketId: int64
    - drugQuoteId?: int64
    - dentalQuoteId?: int64
    - supplementalCarrierPlanTypes: []SupplementalCarrierPlanType
    - hasMultiInsuredDiscount: bool
    - hasLivingWithSomeoneDiscount: bool

struct ListQuotesParams
    - clientId?: int64
    - startingAfter?: int64
    - endingBefore?: int64
    - limit: int32

struct ListQuotesResponse
    - data: []ShortQuote
    - totalCount: int32
    - hasMore: bool

struct GetQuoteResponse
    - quote: Quote
    - spouseQuote?: Quote

struct PublicQuotePageData
    - client: PublicQuoteClientData
    - spouse?: PublicQuoteClientData

struct PublicQuoteClientData
    - quote: Quote
    - irmaaBracket: IrmaaBracket
    - drugQuote?: DrugQuote

error 100 EntityNotFound "entity not found" HTTP 404
error 101 Unauthorized "unauthorized" HTTP 401
error 102 InvalidArgument "invalid argument" HTTP 400
error 103 Internal "internal" HTTP 500

================
File: .gitignore
================
##############################
# Go
##############################

# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib
bin/

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work
go.work.sum

# env file
.env

##############################
# Node
##############################

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

##############################
# Mac
##############################

**/.DS_Store

##############################
# Elm
##############################

# elm-package generated files
elm-stuff
# elm-repl generated files
repl-temp-*

================
File: Dockerfile
================
FROM node:20 AS frontendbuild
RUN mkdir -p /app/frontend
WORKDIR /app/frontend
COPY frontend/src/ ./src/
COPY frontend/static/ ./static/
COPY frontend/elm.json ./
COPY frontend/elm-land.json ./
COPY frontend/package.json ./
COPY frontend/package-lock.json ./
COPY frontend/postcss.config.js ./
COPY frontend/tailwind.config.js ./
RUN npm install
RUN npm run build

FROM golang:1.23 AS serverbuild
WORKDIR /app
COPY go.mod go.sum ./
RUN go mod download
COPY cmd/serverd/main.go ./cmd/serverd/
COPY internal/ ./internal/
COPY rpc/maxquote/ ./rpc/maxquote/
COPY embed.go ./

COPY --from=frontendbuild /app/frontend/dist ./frontend/dist
RUN CGO_ENABLED=0 GOOS=linux go build -o /bin/serverd ./cmd/serverd/main.go

FROM gcr.io/distroless/base AS releasebuild
COPY --from=serverbuild /bin/serverd /bin/serverd
CMD ["/bin/serverd"]

================
File: embed.go
================
package maxquote

import "embed"

//go:embed frontend/dist

var EmbeddedFS embed.FS

================
File: go.mod
================
module github.com/medicareschoolcom/maxquote

go 1.23.1

require (
	github.com/alexedwards/scs/pgxstore v0.0.0-20240316134038-7e11d57e8885
	github.com/alexedwards/scs/v2 v2.8.0
	github.com/coreos/go-oidc/v3 v3.11.0
	github.com/deckarep/golang-set/v2 v2.6.0
	github.com/go-chi/chi/v5 v5.1.0
	github.com/go-chi/httplog/v2 v2.1.1
	github.com/gocarina/gocsv v0.0.0-20240520201108-78e41c74b4b1
	github.com/google/go-cmp v0.6.0
	github.com/jackc/pgx-shopspring-decimal v0.0.0-20220624020537-1d36b5a1853e
	github.com/jackc/pgx/v5 v5.7.1
	github.com/matoous/go-nanoid v1.5.1
	github.com/oklog/run v1.1.0
	github.com/peterbourgon/ff/v3 v3.4.0
	github.com/sendgrid/rest v2.6.9+incompatible
	github.com/sendgrid/sendgrid-go v3.16.0+incompatible
	github.com/testcontainers/testcontainers-go v0.35.0
	github.com/testcontainers/testcontainers-go/modules/postgres v0.35.0
	github.com/twilio/twilio-go v1.23.6
	golang.org/x/oauth2 v0.23.0
)

require (
	dario.cat/mergo v1.0.0 // indirect
	github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect
	github.com/Masterminds/squirrel v1.5.4 // indirect
	github.com/Microsoft/go-winio v0.6.2 // indirect
	github.com/cenkalti/backoff/v4 v4.2.1 // indirect
	github.com/containerd/containerd v1.7.18 // indirect
	github.com/containerd/log v0.1.0 // indirect
	github.com/containerd/platforms v0.2.1 // indirect
	github.com/cpuguy83/dockercfg v0.3.2 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/distribution/reference v0.6.0 // indirect
	github.com/docker/docker v27.1.1+incompatible // indirect
	github.com/docker/go-connections v0.5.0 // indirect
	github.com/docker/go-units v0.5.0 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/go-jose/go-jose/v4 v4.0.2 // indirect
	github.com/go-logr/logr v1.4.1 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-ole/go-ole v1.2.6 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/golang/mock v1.6.0 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.2 // indirect
	github.com/klauspost/compress v1.17.4 // indirect
	github.com/lann/builder v0.0.0-20180802200727-47ae307949d0 // indirect
	github.com/lann/ps v0.0.0-20150810152359-62de8c46ede0 // indirect
	github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/moby/docker-image-spec v1.3.1 // indirect
	github.com/moby/patternmatcher v0.6.0 // indirect
	github.com/moby/sys/sequential v0.5.0 // indirect
	github.com/moby/sys/user v0.1.0 // indirect
	github.com/moby/term v0.5.0 // indirect
	github.com/morikuni/aec v1.0.0 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.1.0 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect
	github.com/shirou/gopsutil/v3 v3.23.12 // indirect
	github.com/shoenig/go-m1cpu v0.1.6 // indirect
	github.com/shopspring/decimal v1.4.0 // indirect
	github.com/sirupsen/logrus v1.9.3 // indirect
	github.com/stretchr/testify v1.9.0 // indirect
	github.com/tklauser/go-sysconf v0.3.12 // indirect
	github.com/tklauser/numcpus v0.6.1 // indirect
	github.com/yusufpapurcu/wmi v1.2.3 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 // indirect
	go.opentelemetry.io/otel v1.24.0 // indirect
	go.opentelemetry.io/otel/metric v1.24.0 // indirect
	go.opentelemetry.io/otel/trace v1.24.0 // indirect
	golang.org/x/crypto v0.31.0 // indirect
	golang.org/x/sync v0.10.0 // indirect
	golang.org/x/sys v0.28.0 // indirect
	golang.org/x/text v0.21.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)

================
File: Makefile
================
# Install tooling to generate project files and run db migrations
tools:
	brew tap webrpc/tap
	brew install webrpc-gen
	brew install sqlc
	brew install golang-migrate
	brew install libpq

# Run all database migrations
migrate-up:
	migrate -database ${DATABASE} -path ./db/migrations up

# Reverse all database migrations
migrate-down:
	migrate -database ${DATABASE} -path ./db/migrations down

# Drop all database migrations
migrate-drop:
	migrate -database ${DATABASE} -path ./db/migrations drop

# Populate the database with static values and initial production Agents
seed:
	psql -d ${DATABASE} -f ./db/seed/seed.sql

# Generate go and elm rpc libraries. The rpc libraries facilitate all frontend/backend communication.
gen-webrpc:
	webrpc-gen -schema=rpc/maxquote/service.ridl -target=github.com/eriklott/webrpc-gen-elm@v0.11.6 -module=Server -timeout=30000 -out=frontend/src/Server.elm
	webrpc-gen -schema=rpc/maxquote/service.ridl -target=golang -pkg=rpc -server -out=rpc/maxquote/service.gen.go

# Generate type safe code to interact with the database.
gen-sqlc:
	sqlc generate

# Generate all rpc and sql code.
gen: gen-webrpc gen-sqlc

# Build backend server
backend-build:
	go build -o bin/serverd cmd/serverd/main.go


# Build backend server
simplemaps-build:
	go build -o bin/simplemaps cmd/simplemaps/main.go

# Start backend development server
backend-serve: backend-build
	bin/serverd -config=.env

# Install frontend npm modules
frontend-install:
	npm --prefix ./frontend install

# Build frontend application. The frontend application gets embedded into the go backend binary, therefore, it is necessary to build the
# frontend before building the backend server.
frontend-build:
	npm --prefix ./frontend run build

# Serve the frontend in development
frontend-serve:
	OAUTH_GOOGLE_LOGIN_URL='http://localhost:8080/oauth/google/login' npm --prefix ./frontend run server

install: tools migrate-up seed gen frontend-install frontend-build

help: backend-build
	bin/serverd -h

test:
	go test ./internal/... -v

build: gen frontend-install frontend-build backend-build

================
File: README.md
================
# Max Quote

## Installation

Set the DATABASE environment variable with your PostgreSQL connection string:
```
export DATABASE='postgres://localhost:5432/<database_name>?sslmode=disable'
```

Install all required tools, migrate & seed the database, generate code, and build the frontend.
```
$ make install
```

## Configuration
A complete list of configuration settings can be viewed in the help menu.
```
$ make help
```
Configuration settings can be provided to the application via flags, environment variables, or a .env file.

### Flags
```
$ bin/serverd -base-url=http://localhost:1234 -database='postgres://localhost/mydb?sslmode=disable' -development=true ...
```
### Environment variables

Configuration settings as environment variables must be provided in uppercase. For example, `twilio-from-phone-number` would be set as `TWILIO_FROM_PHONE_NUMBER`.

```
$ export BASE_URL=http://localhost:1234
$ export DATABASE='postgres://localhost/mydb?sslmode=disable'
$ export DEVELOPMENT=true
$ bin/serverd
```
### Dot env file

Add a .env file to your working directory with the configuration settings contained within:

```
base-url http://localhost:1234
database postgres://localhost/<database_name>?sslmode=disable
development true
port 8080
cookie-name session
...
```
Provide the .env file path to the config flag when starting the backend binary.
```
$ bin/serverd -config=.env
```

## Database migration
Set the DATABASE environment variable with your PostgreSQL connection string:
```
export DATABASE='postgres://localhost:5432/<database_name>?sslmode=disable'
```

Migrate up
```
$ make migrate-up
```

Migrate down
```
$ make migrate-down
```

## Development


### Setup google authentication
A Google OAuth consent screen and OAuth credentials must be set up to log in successfully. After completing the Google OAuth setup, configure the application with the following configuration settings:

  - OAUTH_CLIENT_ID
  - OAUTH_CLIENT_SECRET
  - OAUTH_REDIRECT_URL (e.g. https://maxquote.medicareschool.com/oauth/google/callback)

### Development servers

During development, the frontend and backend services run on separate development servers.


Started the backend server with the `development` configuration setting enabled:
```
$ DEVELOPMENT=true make backend-serve
```


Next, open a new terminal window and start the frontend server:
```
$ make frontend-serve
```

View the application at http://localhost:1234


## Production/Deployment
For production, MaxQuote compiles to a single binary. The binary includes both the backend and frontend services.
```
$ make build
```
The binary will be located in the `bin/serverd` directory.

### Azure deployment
Each time a new tag is pushed to the MaxQuote repository, a github workflow will use the Dockerfile to produce a new container artifact, and push it to Azure container registry.
```
$ git tag -a v0.0.12 -m "v0.0.12"
$ git push origin v0.0.12
```

## Testing
Run tests with:
```
$ make test
```
Max Quote performs various infrastructure tests (e.g., database) in testing containers. Ensure Docker is installed and running before running tests.

## Generate
### RPC
After making changes to the RPC schema, run the following command to re-generate the frontend & backend RPC communication packages:
```
$ make gen-webrpc
```

### Database
After making changes to database migration or query files, run the following command to regenerate the Go database access package:
```
$ make gen-sqlc
```

## Directories

### `cmd/serverd`
Contains the main entry function to build the backend binary.

### `db`
Contains database migrations, queries, and seed data. The `queries` subdirectory is utilized by sqlc
to generate a type-safe Go package (`./internal/sqlc`) for database access.

### `frontend`
Contains the frontend client application, written in Elm using the Elm Land framework.

### `internal`
Contains packages related to the backend service, including app configuration, domain entities, value types, and application handlers.

### `rpc/maxquote`
Contains an RPC schema defining all communication between the backend API and frontend client. The schema is used by webrpc to auto-generate type-safe backend and frontend communication packages.

## Manual database management
MaxQuote contains database tables that need to be managed manually until additional administrative controls can be added to the frontend user interface.

### Insert a new agent
```
$ psql -d <database_url>
$ insert into agent (first_name, last_name, email, phone, phone_ext, created_at, updated_at) values ('John', 'Doe', 'john.doe@example.com', '123-456-7890', 123, current_timestamp, current_timestamp);
```

### Delete a new agent (WARNING - Destructive action)
```
$ psql -d <database_url>
$ delete from agent where id = <agent_id>;
```

### Insert a preferred_supplemental_carrier
```
$ psql -d <database_url>
$ insert into preferred_supplemental_carrier (naic, state_alpha_code, created_at) values ('10345', 'KS', current_timestamp);
```

### Delete a preferred_supplemental_carrier (WARNING - Destructive action)
```
$ psql -d <database_url>
$ delete from preferred_supplemental_carrier where naic = '10345' and state_alpha_code = 'KS';
```

================
File: sqlc.yaml
================
version: "2"
sql:
  - schema: "db/migrations"
    queries: "db/queries"
    engine: "postgresql"
    gen:
      go:
        package: "sqlc"
        out: "internal/sqlc"
        sql_package: "pgx/v5"
        emit_methods_with_db_argument: true
        emit_exact_table_names: true
        emit_result_struct_pointers: true
        omit_unused_structs: true
        emit_interface: true
        overrides:
          - db_type: "pg_catalog.numeric"
            go_type: "github.com/shopspring/decimal.Decimal"
            nullable: false
          - db_type: "pg_catalog.numeric"
            go_type: "github.com/shopspring/decimal.NullDecimal"
            nullable: true



================================================================
End of Codebase
================================================================
